<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="DataProviderRefactoring">Data Provider Refactoring</h1>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/385"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/385</a>
</li></ul><h2 id="Problemstatement">Problem statement</h2>
<p>
Current state of data provider interface is not extensible enough to fulfil needs of planned SSSD features such as <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs/sssctl.html"><span class="icon">​</span>SSSD Status Tool</a>. The main flaw that we aim to solve is to simplify adding of new methods, properties and possibly signals using our <em>sbus</em> interface. As a side effect we will also solve the following issues that are in current code:
</p>
<ul><li>encapsulate data provider from the rest of the code
</li><li>fix poor memory hierarchy which creates occasional race condition on shutdown
</li><li>convert method handlers to <em>simple</em> tevent requests that are not aware of data provider
</li><li>handle D-Bus message reply automatically in data provider code
</li></ul><h3 id="Terminology">Terminology</h3>
<p>
This section clarifies the terminology that is used in this document.
</p>
<ul><li><strong>Backend</strong>: Implementation of a domain (periodic tasks, online/offline callbacks, online check, ...)
</li><li><strong>Data Provider</strong>: Interface between backend and responders
</li><li><strong>Module</strong>: library implementing data provider interface (LDAP, IPA, AD, KRB5, PROXY)
</li><li><strong>Target</strong>: functionality implemented in modules (id, auth, chpass, selinux, autofs, sudo, hostid)
</li></ul><p>
A general overview of the communication process is as follows.
</p>
<ol><li>Responder issues a method call with Data Provider through DP D-Bus API
</li><li>Data Provider calls a method handler registered by configured module
</li><li>Method handler is finished
</li><li>Reply is sent to responder
</li></ol><h2 id="Currentstate">Current state</h2>
<p>
This is just a brief summarization, please refer to the code to get the whole picture.
</p>
<p>
At this moment each target can have only one method specified. The method is defined by providing bet_ops data in sssm_$module_$target_init function. Structure bet_ops contains <em>handler</em> that defines a method handler in addition with <em>check_online</em> which defines a method that should be called when SSSD is trying to check if it can reestablish a connection and it is used only in connection with ID provider. Field <em>finalize</em> was probably introduced as a clean up function, however it is not used at all at the moment.
</p>
<p>
Even though it is not possible with current code to have different private data for different methods, it is possible to extend this structure to allow more methods. However, it would be nice to have it in more automated and controlled way and we still can't use properties and signals this way though.
</p>
<pre class="wiki">struct bet_ops {
    be_req_fn_t check_online;
    be_req_fn_t handler;
    be_req_fn_t finalize;
};
</pre><p>
Each target is defined in <em>struct bet_data</em>.
</p>
<pre class="wiki">static struct bet_data bet_data[] = {
    {BET_NULL, NULL, NULL},
    {BET_ID, CONFDB_DOMAIN_ID_PROVIDER, "sssm_%s_id_init"},
    [...]
    {BET_MAX, NULL, NULL}
};
</pre><p>
Initialization function assigns the bet_ops structure together with private data. The private data are attached to <em>be_ctx</em> in talloc memory hierarchy which results in race conditions during shutdown process. This is currently solved by <em>be_spy</em> which basically forces the desired order of freeing data, however we have seen some crashes on shutdown which we were unable to figure out so far even with spies.
</p>
<pre class="wiki">/* Auth Handler */
struct bet_ops sdap_auth_ops = {
    .handler = sdap_pam_auth_handler,
    .finalize = sdap_shutdown
};

int sssm_ldap_auth_init(struct be_ctx *bectx,
                        struct bet_ops **ops,
                        void **pvt_data)
{
    struct sdap_auth_ctx *ctx;
    int ret;

    [...]

        *ops = &amp;sdap_auth_ops;
        *pvt_data = ctx;
    }

    return ret;
}
</pre><h3 id="Goalstoachieve">Goals to achieve</h3>
<ul><li>make adding a new client automated and error proof
</li><li>make adding a new target automated and error proof
</li><li>make adding a new method automated and error proof
</li><li>create a proper talloc hierarchy so we can control clean up process
</li><li>support module's contructor and private data shared across target's initialization functions
</li><li>make method handlers pure tevent requests that returns single error code
</li><li>make method handlers not aware of reply process
</li><li>improve debugging capabilities
<ul><li>keep track of active requests
</li><li>make each request clearly visible in logs
</li></ul></li><li>allow methods with different output parameters
</li><li>allow D-Bus objects, properties and signals
</li><li>properly terminate all requests on clean up
</li></ul><h3 id="Overviewofthesolution">Overview of the solution</h3>
<p>
A responder sends a <em>D-Bus method</em> to the data provider which is handled by a D-Bus method handler. Depending on the introspect file this handler may be called directly with <em>automatically parsed parameters or the parsing may be left to handler implementation</em>. In the handler, we process parameters and <em>create a data provider request</em>. This request will call a data provider method handler which is a basic <strong>tevent request</strong>. When the request is finished, data provider tevent callback is invoked and it send a reply back to the responder. Depenging on the request result the reply message may be either error, sending an error code and message, or success where a default or <em>custom _recv</em> function may be called to obtain and send additional attributes.
</p>
<p>
The whole data provider lifetime is controlled by a tevent request. There is only one way in <em>(_send)</em> and one way out <em>(_recv)</em> from the request. The data provider method handler has no knowledge about D-Bus or data provider at all. The data flow looks like this:
</p>
<pre class="wiki">Responder -&gt; (dbus) -&gt; DP D-Bus method handler -&gt; DP Request -&gt; (tevent) -&gt; DP method handler

... asynchronous processing ...

(tevent done) -&gt; (dp request done) -&gt; (error detected) -&gt; (dbus error) -&gt; Responder
                                   -&gt; (success)        -&gt; (recive callback) -&gt; (dbus) -&gt; Reponder
</pre><h4 id="DataProviderInitialization">Data Provider Initialization</h4>
<p>
This section describes what is needed to initialize data provider. It talks only about sections that may change in the future in order to extend SSSD's functionality, it does not describe how it works under the hood. The initializion basically consist of these steps:
</p>
<p>
<strong>1. Initialization of data provider modules and targets</strong>
</p>
<p>
Each modules and target needs to be initialized through it's initializer functions in <strong>src/providers/$modname/$modname_init.c</strong>. The whole module can contain a constructor that may create data shared across all or multiple modules, it is not required though. The functions names are generated as follows:
</p>
<p>
A constructor is named <strong>sssm_$modname_init</strong> and has header:
</p>
<pre class="wiki">errno_t sssm_$modname_init(TALLOC_CTX *mem_ctx, struct be_ctx *be_ctx, void **shared_data);
</pre><p>
A target initializer is named <strong>sssm_$modname_$target_init</strong> and has header:
</p>
<pre class="wiki">errno_t sssm_$modname_$target_init(TALLOC_CTX *mem_ctx, struct be_ctx *be_ctx, void *shared_data, struct dp_method *dp_methods);
</pre><p>
Target initializer will at the end set all methods that are implemented by this target via dp_set_method() example:
</p>
<pre class="wiki">errno_t sssm_ipa_sudo_init(TALLOC_CTX *mem_ctx,
                           struct be_ctx *be_ctx,
                           void *module_data,
                           struct dp_method *dp_methods)
{
    struct ipa_sudo_ctx *sudo_ctx;
    
    /* ... */

    dp_set_method(dp_methods, DPM_SUDO_FULL_REFRESH, dp_ipa_sudo_full_refresh_send, dp_ipa_sudo_full_refresh_recv, sudo_ctx);
    dp_set_method(dp_methods, DPM_SUDO_SMART_REFRESH, dp_ipa_sudo_smart_refresh_send, dp_ipa_sudo_smart_refresh_recv, sudo_ctx);
    dp_set_method(dp_methods, DPM_SUDO_RULES_REFRESH, dp_ipa_sudo_rules_refresh_send, dp_ipa_sudo_rules_refresh_recv, sudo_ctx);
}
</pre><p>
<strong>2. Registering a data provider client -- responders</strong>
</p>
<p>
When a responder wants to establish D-Bus connection with data provider it needs to send a Register method to handshake with the provider. Here we test that the client is known and setup D-Bus method handlers. Each client is monitored and when the connection is dropped we remove active requests of this client. Internally, we actually only remove sbus connection from the request but try to finish the request otherwise so we can completely save data that were already downloaded into the sysdb for further usage.
</p>
<p>
To add a new well-known client just add it into <strong>enum dp_clients</strong> in <em>dp_private.h</em> and alter <strong>dp_client_to_string()</strong> in <em>dp_client.c</em>.
</p>
<p>
<strong>3. Registering D-Bus methods</strong>
</p>
<p>
When the D-Bus service is created a D-Bus method handlers needs to be registered. The following steps are needed to add a new method or interface into the data provider.
</p>
<ol><li>Add new method (or interface) into data provider introspection file <strong>dp_iface.xml</strong>
</li><li>Register this interface or method in <strong>dp_iface.c</strong> by providing the interface structure generated from the instrospection file and ammending <strong>dp_map</strong> array
</li><li>(optionally if needed) Add new data provider method and/or target into <strong>enum dp_methods</strong> and <strong>enum dp_targets</strong> respectively
</li><li>Implement the method handler
</li></ol><h4 id="D-Busmethodhandlers">D-Bus method handlers</h4>
<p>
The purpose of a D-Bus method handler is to parse parameters from a D-Bus message (if they are not parsed automatically) and to create data specific to the method called. Then the handler issues a new data provider request through dp_file_request(). For example:
</p>
<pre class="wiki">int dp_sudo_full_refresh(struct sbus_request *sbus_req,
                         void *dp_cli,
                         uint32_t dp_flags)
{
    dp_file_request(dp_cli, "SUDO Full Refresh", sbus_req,
                    dp_req_reply_default,
                    DPT_SUDO, DPM_SUDO_FULL_REFRESH, dp_flags, NULL);

    return EOK;
}
</pre><p>
The current handler rewritten to the new data provider interface may look like:
</p>
<pre class="wiki">int dp_sudo_handler(struct sbus_request *sbus_req, void *dp_cli)
{
    struct dp_sudo_data *data;
    uint32_t dp_flags;
    errno_t ret;

    data = talloc_zero(sbus_req, struct dp_sudo_data);
    if (data == NULL) {
        return ENOMEM;
    }

    ret = dp_sudo_parse_message(data, sbus_req-&gt;message, &amp;dp_flags,
                                &amp;data-&gt;type, &amp;data-&gt;rules);
    if (ret != EOK) {
        return ret;
    }

    dp_file_request(dp_cli, "sudo", sbus_req, dp_req_reply_std,
                    DPT_SUDO, DPM_SUDO_HANDLER, dp_flags, data);

    return EOK;
}
</pre><p>
If dp_flags are provider the data provider will check the flags and act accordingly. Currently only DP_FAST_REPLY is available which if set sends <em>org.freedesktop.sssd.Error.<a class="missing wiki" href="https://docs.pagure.org/sssd-test2/DataProvider.html" rel="nofollow">DataProvider?</a>.Offline</em> immediately without calling the request handler.
</p>
<h4 id="DataProviderRequestHandlers">Data Provider Request Handlers</h4>
<p>
Data provider request handler is a tevent request implementing the following headers:
</p>
<pre class="wiki">struct dp_req_params {
    struct tevent_context *ev;
    struct be_ctx *be_ctx;
    struct sss_domain_info *domain;
    enum dp_methods method;
    void *method_data;
    void *req_data;
};

typedef struct tevent_req *
(*dp_req_send_fn)(TALLOC_CTX *mem_ctx, struct dp_req_params *params);

typedef errno_t
(*dp_req_recv_fn)(TALLOC_CTX *mem_ctx, struct tevent_req *req, void *data);
</pre><p>
All parameters except memory context are combined into one structure to simplify possible future extensions (thus when a new parameter needs to be added we don't have to modify existing handler). The <em>data</em> in recieve function may be used to pass output parameters into the D-Bus reply. For example, the following reply callback simulates current reply message which returns major and minor error together with error message.
</p>
<pre class="wiki">void dp_req_reply_std(const char *req_name,
                      struct sbus_request *sbus_req,
                      struct tevent_req *handler_req,
                      dp_req_recv_fn recv_fn,
                      void *pvt)
{
    struct dp_reply_data reply;
    const char *safe_err_msg;
    errno_t ret;

    ret = recv_fn(sbus_req, handler_req, &amp;reply);
    if (ret != EOK) {
        DEBUG(SSSDBG_CRIT_FAILURE, "Bug: !EOK code returned?\n");
        talloc_free(sbus_req);
        return;
    }

    safe_err_msg = safe_be_req_err_msg(reply.message, reply.dp_error);

    DP_REQ_DEBUG(SSSDBG_TRACE_LIBS, req_name, "Returning [%s]: %d,%d,%s",
                 dp_err_to_string(reply.dp_error), reply.dp_error,
                 reply.error, reply.message);

    sbus_request_return_and_finish(sbus_req,
                                   DBUS_TYPE_UINT16, &amp;reply.dp_error,
                                   DBUS_TYPE_UINT32, &amp;reply.error,
                                   DBUS_TYPE_STRING, &amp;safe_err_msg,
                                   DBUS_TYPE_INVALID);
}
</pre><h3 id="Onmemoryhierarchy">On memory hierarchy</h3>
<p>
The memory hierarchy is known strictly specified and should not be broken. It gives us the ability to cleary clean up all data provider data on SSSD exit.
</p>
<pre class="wiki">                               struct be_ctx
                                     |
                            struct data_provider
                        /            |              \
      struct dp_module[]      struct dp_target[]     struct dp_req [...]
                       |             |                |
              module_data     struct dp_methods[]    req_data,tevent_req state,...
                                     |
                                method_data
</pre><p>
A destructor on data_provider is set to ensure that all DP requests are correctly terminated (sending a proper error message back to responder) prior its private data is freed.
</p>
<h3 id="Implementationsteps">Implementation steps</h3>
<ol><li>(done) Implement the new data provider interface
</li><li>(wip) Convert modules init functions
</li><li>(wip) Convert existing handlers into tevent requests
</li><li>Switch to the new interface
</li><li>Add new methods and interfaces as needed
</li></ol><h3 id="Responders">Responders</h3>
<p>
In the first stage no change to the responders needs to be done. All existing data provider methods will always succeed and return three output parameters (major error, minor error, error message) as the current code does. New methods that return error or some output parameters may be added without affecting the current responder data provider code. When the new code is thoroughly tested we can change the existing methods to return either error or success but this requires also changes in responders. I would like to write something similar to cache_req but I don't have any specific plan so far.
</p>
<h3 id="Questions">Questions</h3>
<h3 id="Configurationchanges">Configuration changes</h3>
<p>
No configuration changes.
</p>
<h3 id="HowToTest">How To Test</h3>
<p>
All existing test must pass and no functionality is broken.
</p>
<h3 id="HowToDebug">How To Debug</h3>
<p>
Each data provider request life cycle can be tracked in debug logs with a special message prefix: <strong>DP Request [$name #$index]</strong>. The $name is the name of the request (i.e. which method was called), $index is a cyclic number assigned to the request. When we run out of number we siply start from 1 again.
</p>
<p>
In the debugger we can monitor active data provider request, clients, modules and targets in <strong>be_ctx-&gt;provider</strong>.
</p>
<h3 id="Authors">Authors</h3>
<p>
Pavel Březina &lt;<a class="mail-link" href="mailto:pbrezina@redhat.com"><span class="icon">​</span>pbrezina@redhat.com</a>&gt;
</p>
</body></html>