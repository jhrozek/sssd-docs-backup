<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h2 id="ActiveDirectoryclientaccesscontrol">Active Directory client access control</h2>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2082"><span class="icon">​</span>RFE:Add a new option ad_access_filter</a>
</li><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/1975"><span class="icon">​</span>RFE:Change the default of ldap_access_order</a>
</li><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/1977"><span class="icon">​</span>issues when combining the AD provider and ldap_access_filter</a>
</li></ul><p>
Somewhat related:
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2083"><span class="icon">​</span>Document the best practices for AD access control</a>
</li></ul><h3 id="ProblemStatement">Problem Statement</h3>
<p>
The recommended way of connecting a Linux client to an Active Directory domain
is using the <a class="ext-link" href="http://jhrozek.fedorapeople.org/sssd/1.11.0/man/sssd-ad.5.html"><span class="icon">​</span>AD provider</a>.
However, in the default configuration of the Active Directory
provider, only account expiration is checked. Very often, the administrator
needs to restrict the access to the client machine further, limiting the
access to a certain user, group of users, or using some other custom filtering
mechanism. In order to do so, the administrator is required to use an alternative access control provider.
However, none of the alternatives provide the full required functionality for all users
resolvable by the AD provider, moreover they are hard to configure. This design page proposes extension
of the AD access provider to address these concerns.
</p>
<h3 id="Currentaccesscontroloptions">Current access control options</h3>
<p>
With the existing SSSD, the administrator has two basic means
to restrict access control to the Linux client - using the
<a class="ext-link" href="http://jhrozek.fedorapeople.org/sssd/1.11.0/man/sssd-simple.5.html"><span class="icon">​</span>simple access control provider</a>
or configuring the LDAP access control provider. Each approach has its pros and cons.
</p>
<h4 id="Usingthesimpleaccessprovider">Using the simple access provider</h4>
<p>
The simple access provider grants or denies access based on the contents
of allow and deny lists. There are separate lists for user and group
names as well as allowed and denied objects.
</p>
<p>
The following example shows configuration that grants access to user named
<tt>tux</tt> and group called <tt>linuxadmins</tt>.
</p>
<pre class="wiki"> access_provider = simple
 simple_allow_users = tux
 simple_allow_groups = linuxadmins
</pre><ul><li>Pros:
<ul><li>Easy to configure
</li><li>Realmd provides an interface to configure the simple access provider using its CLI
</li></ul></li><li>Cons:
<ul><li>Account expiration is not checked
</li><li>Limited expresiveness. No way to combine several clauses
</li><li>Does not align with the LDAP structure the Active Directory uses
</li></ul></li></ul><h4 id="UsingtheLDAPaccessprovider">Using the LDAP access provider</h4>
<p>
The LDAP access provider offers a way to configure the access control
decision based on whether the user matches a preconfigured filter. Moreover,
the LDAP access provider also offers chaining other LDAP based checks. For
the vanilla AD environment, only account expiration check applies.
</p>
<p>
The following example illustrates configuration that allows access to those
users, who are members of group named <tt>linuxadmins</tt> AND have a valid home
directory set using the <tt>ldap_access_filter</tt> directive. The users who
match the configured filter are also checked whether they are expired
(<tt>ldap_access_order</tt> contains <tt>expire</tt>).
</p>
<pre class="wiki">    access_provider = ldap
    ldap_access_order = filter, expire
    ldap_account_expire_policy = ad
    ldap_access_filter = (&amp;(memberOf=cn=admins,ou=groups,dc=example,dc=com)(unixHomeDirectory=*))
    ldap_sasl_mech = GSSAPI
    ldap_sasl_authid = CLIENT_SHORTNAME$@EXAMPLE.COM
    ldap_schema = ad
</pre><ul><li>Pros:
<ul><li>Allows the administrator to base access control on a custom LDAP filter, making it possible to combine several conditions
</li><li>Conditions are not limited to user names or group membership
</li></ul></li><li>Cons:
<ul><li>Nontrivial and clumsy configuration that must include several low level LDAP settings, otherwise set automatically by the AD provider. Defeats the whole purpose of the AD provider
</li><li>The admin needs to combine AD and LDAP providers. Judging by experience from triaging support cases with Red Hat support, this is a problem for many admins.
</li><li>Account expiration check must be configured separately, which is not obvious
</li><li>No support for users from trusted AD domains
</li><li>No realmd integration
</li></ul></li></ul><h3 id="Proposedsolution">Proposed solution</h3>
<p>
The proposal is to add a new access filter configuration option to the
existing AD access provider. Adding the option to the AD provider would
greatly simplify the configuration when compared to the LDAP access control,
while maintaining the full expresiveness of <tt>ldap_access_filter</tt>. The
new option would be called <tt>ad_access_filter</tt>. If the new option was set,
then the AD access provider would first match the entry against the filter
in that option. If the entry matched, then the account would be checked
for expiration.
</p>
<p>
The following exapmple illustrates an example similar to the one above, using the proposed AD options:
</p>
<pre class="wiki">    access_provider = ad
    ad_access_filter = (&amp;(memberOf=cn=admins,ou=groups,dc=example,dc=com)(unixHomeDirectory=*))
</pre><p>
The main advantage is simplified configuration. The admin doesn't have to know or understand what "SASL ID" is.
</p>
<p>
In comparison with the two legacy solutions explained above:
</p>
<ul><li>Pros
<ul><li>Easy and intuitive configuration. Only one provider type is configured
</li><li>Sane defaults - always checks for expiration, also checks access filter if configured that way
</li><li>Would support users and groups from trusted domains by leveraging the existing AD provider infrastructure
</li></ul></li><li>Cons
<ul><li>No realmd integration
</li></ul></li></ul><h3 id="Realmdintegration">Realmd integration</h3>
<p>
After a short discussion with the realmd upstream maintainer, it was decided that these options do not fit the realmd use-cases well. If the user needs to use such advanced techniques as LDAP filters,
chances are that he doesn't need a tool like realmd to set them up in the config file.
</p>
<h3 id="Implementationdetails">Implementation details</h3>
<ol><li>The default value of what AD access_provider is set to should be changed
<ul><li>Currently, if <tt>access_provider</tt> is not set explicitly, the default is <tt>permit</tt>, thus allowing even expired accounts
</li><li>The new default would be <tt>ad</tt>, checking account expiration even with a minimal configuration
</li></ul></li><li>A new option would be added. The new option would be called <tt>ad_access_filter</tt>
</li><li>The LDAP access provider must be extended to allow connecting to a GC and support subdomains in general
<ul><li>Pass in <tt>struct sdap_domain</tt> and <tt>id_conn</tt> instead of using the connection from <tt>sdap_id_ctx</tt> directly
</li><li>The code must not read the <tt>sss_domain_info</tt> from <tt>be_ctx</tt> but only from <tt>sdap_domain</tt> in order to support subdomain users
</li></ul></li><li>The AD access provider must call the improved LDAP access provider internally with the right connection
<ul><li>The default should be GC
</li><li>If POSIX attributes are in use and GC lookup wouldn't match, optionally fall back to LDAP. This fallback could be tried just once to speed up subsequent access control
</li></ul></li><li>The default chain of LDAP access filter the AD provider sets internally must be changed.
<ul><li>Currently AD provider sets <tt>ldap_access_order=expire</tt>. If (and only if) <tt>ad_access_filter</tt> was set, the LDAP chain would become <tt>ldap_access_order=filter,expire</tt>
</li></ul></li></ol><h4 id="Parsingthead_access_filteroption">Parsing the <tt>ad_access_filter</tt> option</h4>
<ol><li>The <tt>ad_access_filter</tt> option is a comma-separated list of filters that apply globally, per-domain or per-forest. The most specific match is used
</li><li>If the <tt>ad_access_filter</tt> value starts with an opening bracket <tt>(</tt>, it is used as a filter for all entries from all domains and forests
<ul><li>example: <tt>(&amp;(memberOf=cn=admins,ou=groups,dc=example,dc=com)(unixHomeDirectory=*))</tt>
</li></ul></li><li>More advanced format can be used to restrict the filter to a specific domain or a specific forest. This format is <tt>KEYWORD:NAME:FILTER</tt>
<ul><li>KEYWORD can be one of <tt>DOM</tt> or <tt>FOREST</tt>
<ul><li>KEYWORD can be missing
</li></ul></li><li>NAME is a label.
<ul><li>if KEYWORD equals <tt>DOM</tt> or missing completely, the filter is applied for users from domain named NAME only
</li><li>if KEYWORD equals <tt>FOREST</tt>, the filter is applied on users from forest named NAME only
</li></ul></li><li>examples of valid filters are:
<ul><li>apply filter on domain called dom1 only:
<ul><li><tt>dom1:(memberOf=cn=admins,ou=groups,dc=dom1,dc=com)</tt>
</li></ul></li><li>apply filter on domain called dom2 only:
<ul><li><tt>DOM:dom2:(memberOf=cn=admins,ou=groups,dc=dom2,dc=com)</tt>
</li></ul></li><li>apply filter on forest called EXAMPLE.COM only:
<ul><li><tt>FOREST:EXAMPLE.COM:(memberOf=cn=admins,ou=groups,dc=example,dc=com)</tt>
</li></ul></li></ul></li></ul></li><li>If no filter matches the user's domain, access is denied
<ul><li>example <tt>ad_access_filter = dom1:(memberOf=cn=admins,ou=groups,dc=dom1,dc=com), dom2:(memberOf=cn=admins,ou=groups,dc=dom2,dc=com)</tt>, user logs in from dom3
</li></ul></li></ol><h3 id="Contingencyplan">Contingency plan</h3>
<p>
None needed. The existing options would still exist and function as they do now.
</p>
<h3 id="Howtotest">How to test</h3>
<ol><li>Check that <tt>access_provider=ad</tt> without any other options allows non-expired users
</li><li>Check that <tt>access_provider=ad</tt> without any other options denies expired users
</li><li>Test that setting <tt>ad_access_filter</tt> restricts access to users who match the filter
<ul><li>test that an expired user, even though he matches the filter, is denied access
</li><li>this test must include users from the primary domain as well as a sub domain
</li><li>Different filters should be tested to make sure the most speficic filter applies
<ul><li>example: add a restrictive filter for dom1 and permissive filter without specifying the domain. A user from dom1 must be denied access, while a user from other domain must be allowed access
</li></ul></li></ul></li><li>When access is denied, the SSSD PAM responder must return a reasonable return code (6)
</li></ol><p>
 
</p>
<h3 id="Futureandoptionalenhancements">Future and optional enhancements</h3>
<p>
In the future, we should extend the <tt>access_provider</tt> option itself and allow
chaining access providers. This enhancement would allow even more flexibility
and would allow the administrator to combine different access providers,
but is outside the scope of the change described by this design page.
</p>
<h3 id="Authors">Author(s)</h3>
<ul><li>Jakub Hrozek &lt;<a class="mail-link" href="mailto:jhrozek@redhat.com"><span class="icon">​</span>jhrozek@redhat.com</a>&gt;
</li><li>Sumit Bose &lt;<a class="mail-link" href="mailto:sbose@redhat.com"><span class="icon">​</span>sbose@redhat.com</a>&gt;
</li></ul></body></html>