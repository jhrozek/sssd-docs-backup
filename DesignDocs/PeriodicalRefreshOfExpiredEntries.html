<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="Periodicalrefreshofexpiredentries">Periodical refresh of expired entries</h1>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/1713"><span class="icon">​</span>Add a task to the SSSD to periodically refresh cached entries</a>
</li></ul><h2 id="ProblemStatement">Problem Statement</h2>
<p>
Large deployments may suffer from latency when refreshing a big number of expired entries, for instance during logins that involve refreshing netgroups.
</p>
<h2 id="Overviewofthesolution">Overview of the solution</h2>
<p>
We will create a back end task, that will periodically search and update all expired NSS entries.
The periodic task it self is provider independent and it leverage new <a class="wiki" href="https://docs.pagure.org/sssd-test2/DesignDocs/PeriodicTasks.html">periodic tasks API</a>.
The task will fetch all expired entries and invoke a provider specific callback to update those entries.
</p>
<h2 id="Implementationdetails">Implementation details</h2>
<pre class="wiki">typedef struct tevent_req *
(*nss_refresh_records_send_t)(TALLOC_CTX *mem_ctx,
                              struct be_ctx *be_ctx,
                              const char **dn,
                              void *pvt);

typedef errno_t
(*nss_refresh_records_recv_t)(struct tevent_req *req);

struct nss_refresh_records_cb {
    bool enabled;
    nss_refresh_records_send_t send;
    nss_refresh_records_recv_t recv;
    void *pvt;
}

enum nss_refresh_type {
    NSS_REFRESH_TYPE_USERS,
    NSS_REFRESH_TYPE_GROUPS,
    ... for all NSS objects

    NSS_REFRESH_TYPE_SENTINEL
};

struct nss_refresh_records_ctx {
    struct nss_refresh_records_cb callbacks[NSS_REFRESH_TYPE_SENTINEL];
};

struct nss_refresh_records_init();

errno_t
nss_refresh_records_add_cb(struct nss_refresh_records_ctx *ctx,
                           enum nss_refresh_type type,
                           nss_refresh_records_send_t send,
                           nss_refresh_records_recv_t recv,
                           void *pvt);

struct tevent_req *
nss_refresh_records_send(TALLOC_CTX *mem_ctx,
                         struct be_ctx *be_ctx,
                         void *pvt /* struct nss_refresh_records_ctx */

errno_t
nss_refresh_records_recv(struct tevent_req *req);
</pre><p>
A new nss_refresh_records_ctx is created during back end start up and it is made a member of be_ctx. Every ID provider can install an update function during its initialization via <em>nss_refresh_records_add_cb()</em>. Every callback can be installed only once. After all providers are initialized, back end creates a new periodic task for refreshing NSS expired entries.
</p>
<p>
<em>nss_refresh_records_send()</em> will go through the callback list. When a callback is enabled it will acquire a list of all expired entries distinguish names and call the provider-specific request to refresh them.
</p>
<h2 id="Authors">Author(s)</h2>
<p>
Pavel Březina &lt;<a class="mail-link" href="mailto:pbrezina@redhat.com"><span class="icon">​</span>pbrezina@redhat.com</a>&gt;
</p>
</body></html>