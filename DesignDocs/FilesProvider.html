<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#FeatureName">Feature Name</a>
    <ol>
      <li>
        <ol>
          <li>
            <a href="#Problemstatement">Problem statement</a>
          </li>
          <li>
            <a href="#Usecases">Use cases</a>
            <ol>
              <li>
                <a href="#UseCase:DefaultConfiguration">Use Case: Default Configuration</a>
              </li>
              <li>
                <a href="#UseCase:ProgramaticallymanagingPOSIXattributesofauseroragroup">Use Case: Programatically managing POSIX attributes of a user or a group</a>
              </li>
              <li>
                <a href="#UseCase:Manageextendedattributesofusersandgroups">Use Case: Manage extended attributes of users and groups</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#Overviewofthesolution">Overview of the solution</a>
          </li>
          <li>
            <a href="#Implementationdetails">Implementation details</a>
          </li>
          <li>
            <a href="#Configurationchanges">Configuration changes</a>
          </li>
          <li>
            <a href="#Performanceimpact">Performance impact</a>
          </li>
          <li>
            <a href="#Compatibilityissues">Compatibility issues</a>
          </li>
          <li>
            <a href="#Packagingissues">Packaging issues</a>
          </li>
          <li>
            <a href="#HowToTest">How To Test</a>
          </li>
          <li>
            <a href="#HowToDebug">How To Debug</a>
          </li>
          <li>
            <a href="#Authors">Authors</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h1 id="FeatureName">Feature Name</h1>
<p>
"Files" data provider
</p>
<p>
Related ticket(s):
</p>
<ul><li>The umbrella tracking ticket: <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2228"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2228</a>
</li></ul><p>
which includes the following sub-tasks:
</p>
<ul><li>Ship an immutable recovery mode config for local accounts - <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2229"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2229</a>
</li><li>[RFE] Support UID/GID changes - <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2244"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2244</a>
</li><li>Provide a "writable" D-Bus management API for local users - <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/3242"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/3242</a>
</li></ul><h3 id="Problemstatement">Problem statement</h3>
<p>
SSSD does not behave well with nscd, so we recommend that it be disabled. However, this comes with a price in the form of every nameservice lookup hitting the disk for <tt>/etc/passwd</tt> and friends every time. SSSD should be able to read and monitor these files and serve them from its cache, allowing <tt>sss</tt> to sort before <tt>files</tt> in <tt>/etc/nsswitch.conf</tt>
</p>
<p>
In addition, SSSD provides some useful interfaces, such as <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs/DBusUsersAndGroups.html"><span class="icon">​</span>the dbus interface</a> which only work for users and groups SSSD knows about.
</p>
<h3 id="Usecases">Use cases</h3>
<h4 id="UseCase:DefaultConfiguration">Use Case: Default Configuration</h4>
<p>
SSSD (and its useful APIs) should always be available. This means that SSSD must ship with a default configuration that works (and requires no manual configuration or joining a domain). This default configuration should provide a fast in-memory cache for all user and group information that SSSD can support, including those traditionally stored in <tt>/etc/passwd</tt> and friends.
</p>
<h4 id="UseCase:ProgramaticallymanagingPOSIXattributesofauseroragroup">Use Case: Programatically managing POSIX attributes of a user or a group</h4>
<p>
Currently the available ways to manage users and groups is either spawn and call shadow-utils binaries like <tt>useradd</tt> or libuser. SSSD already has a D-Bus API used to provide custom attributes of domain users. This interface should be be extended to provide 'writable' methods to manage users and groups from files. This is tracked by <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/3242"><span class="icon">​</span>ticket #3242</a>
</p>
<h4 id="UseCase:Manageextendedattributesofusersandgroups">Use Case: Manage extended attributes of users and groups</h4>
<p>
Some applications (such as desktop environments) additional attributes (such as keyboard layout) should be stored along with the user. Since the passwd file has only a fixed number of fields, it might make sense to allow additional attributes to be stored in SSSD database and retrieved with sssd's D-Bus interface. Again, this is tracked by <a class="ext-link" href="https://fedorahosted.org/sssd/ticket/3242"><span class="icon">​</span>ticket #3242</a>
</p>
<h3 id="Overviewofthesolution">Overview of the solution</h3>
<p>
SSSD should ship a <tt>files</tt> provider as part of its required minimal package. Absent any user modifications, SSSD should be configured to start at boot and use this provider to serve local identity information.
</p>
<p>
This provider may or may not be optional. For example, we might decide that it always exists as the first domain in the list, even if not explicitly specified. Alternatively, distributions that wish to always include the files provider will be able (starting with SSSD 1.14 and its <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs/ding-libs/INIConfigMerge.html"><span class="icon">​</span>config merging feature</a>) to drop a definition of the files provider into <tt>/etc/sssd/conf.d</tt>. In order for this functionality to work, we would have to deprecate the <tt>domains</tt> line and instead load all <tt>[domain/XXXX]</tt> sections from all available sources, unless the <tt>domains</tt> line is specified for backwards-compatibility.
</p>
<h3 id="Implementationdetails">Implementation details</h3>
<p>
Upon SSSD startup, the <tt>files</tt> provider will always run a complete enumeration pass on the <tt>/etc/passwd</tt>, <tt>/etc/group</tt> and other files as appropriate. The provider will then configure an appropriate set of file monitors (using <tt>inotify()</tt>) and will re-run the enumeration if any of those files are modified or replaced. The implementation of enumeration would use the <tt>nss_files</tt> module interface - we would <tt>dlopen</tt> the module and <tt>dlsym</tt> the appropriate functions like <tt>__nss_files_getpwent</tt>.
</p>
<p>
The fast-cache must also be flushed any time the enumeration is run, to ensure that stale data is cleaned up. We should also consider turning off the fast memory cache while we are performing the update.
</p>
<p>
In addition, the nscd cache (if applicable) should also be flushed during an update. The updates to the files should be sufficiently rare so the performance impact would be negligible.
</p>
<p>
The <tt>files</tt> provider in its first incarnation is expected to be a read-only tool, making no direct modifications to local passwords. In future enhancements, the Infopipe may grow the capability to serve the AccountsServices API and make changes.
</p>
<p>
When a change in the files is detected, we should also flush the negative cache - either only the changes or just flush it whole. This would prevent scenarios like:
</p>
<pre class="wiki">    getent passwd foo # see that there is no user foo
    useradd foo       # OK, let's add it then
    getent passwd foo # still no user returned until the negative cache expires
</pre><p>
from confusing admins.
</p>
<h3 id="Configurationchanges">Configuration changes</h3>
<p>
We may need the ability to choose non-default locations for files. This can be a hidden (undocumented) option in the first version and if there is a need to actually configure a non-default location, we can later expose these configuration options.
</p>
<p>
We may also need to set a configurable number of seconds between detecting a change and running enumerations. This could be implemented in waiting a short time (2-3 seconds perhaps?) before detecting the change and running the enumeration to avoid excessive enumerations and invalidating the fastacache during subsequent shadow-utils invocations.
</p>
<h3 id="Performanceimpact">Performance impact</h3>
<p>
For measuring performance impact, we have developed a simple project called
<a class="ext-link" href="https://github.com/jhrozek/nssbench"><span class="icon">​</span>nssbench</a> which measures the time
spent in NSS with systemtap. For each case, results are included for a
single lookup which simulate the simplest case of an application that
is spawned and exists and a case where an application performs several
lookup and is able to benefit from the memory cache which is opened once
per application. For single lookups, we ran the tests 10 times and averaged the Below are test results from different scenarios:
</p>
<ol><li>Base-line: Looking up a local user directly from <tt>nss_files</tt>
<ul><li>Single lookup
<pre class="wiki">nss operation getpwnam(jhrozek) took 226 us
_nss_files_getpwnam cnt:1 avg:30 min:30 max:30 sum:30 us
_nss_sss_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
</pre></li><li>100 lookups
<pre class="wiki">nss operation getpwnam(jhrozek) took 2717 us
_nss_files_getpwnam cnt:100 avg:21 min:14 max:524 sum:2159 us
_nss_sss_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
</pre></li></ul></li><li>Failover from <tt>sss</tt> to <tt>files</tt> when SSSD is not running - this is the 'worst' case where <tt>sss</tt> is enabled in <tt>nsswitch.conf</tt> but the deamon is not running at all, so the system falls back from <tt>sss</tt> to <tt>files</tt> for user lookups.
<ul><li>Single lookup
<pre class="wiki">nss operation getpwnam(jhrozek) took 549 us
_nss_files_getpwnam cnt:1 avg:32 min:32 max:32 sum:32 us
_nss_sss_getpwnam cnt:1 avg:72 min:72 max:72 sum:72 us
</pre></li><li>100 lookups
<pre class="wiki">nss operation getpwnam(jhrozek) took 6078 us
_nss_files_getpwnam cnt:100 avg:19 min:16 max:42 sum:1907 us
_nss_sss_getpwnam cnt:100 avg:22 min:19 max:74 sum:2248 us
</pre></li></ul></li><li>Round-trip between SSSD deamon's populated cache and OS when the memory cache is not used or not populated
<ul><li>Single lookup
<pre class="wiki">nss operation getpwnam(jhrozek) took 755 us
_nss_files_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
_nss_sss_getpwnam cnt:1 avg:384 min:384 max:384 sum:384 us
</pre></li><li>100 lookups
<pre class="wiki">nss operation getpwnam(jhrozek) took 97831 us
_nss_files_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
_nss_sss_getpwnam cnt:100 avg:968 min:115 max:22153 sum:96812 us
</pre></li></ul></li><li>Performance benefit from using the memory cache
<ul><li>Single lookup
<pre class="wiki">nss operation getpwnam(jhrozek) took 373 us
_nss_files_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
_nss_sss_getpwnam cnt:1 avg:37 min:37 max:37 sum:37 us
</pre></li><li>100 lookups
<pre class="wiki">nss operation getpwnam(jhrozek) took 1355 us
_nss_files_getpwnam cnt:0 avg:0 min:0 max:0 sum:0 us
_nss_sss_getpwnam cnt:100 avg:4 min:3 max:42 sum:408 us
</pre></li></ul></li></ol><p>
The testing shows substantial benefit from SSSD cache for applications
that perform several lookup. The first lookup, which opens the memory
cache file takes about as much time as lookup against files. However,
subsequent lookups are almost an order of magnitude faster.
</p>
<p>
For setups that do not run SSSD by default, there is a performance hit by
failover from <tt>sss</tt> to <tt>files</tt>. During testing, the failover took up to
300us, about ~70us was spent in the <tt>sss</tt> module and about ~200 us seems
to be the failover in libc itself.
</p>
<h3 id="Compatibilityissues">Compatibility issues</h3>
<p>
Unless the ordering is specified, the files provider should be loaded first.
</p>
<p>
Other distributions should be involved as well - we should work with Ubuntu as well.
</p>
<p>
abrt and coredumpd must be run with <tt>SSS_LOOPS=no</tt> in order to avoid looping when analyzing a crash. We need to test this by reverting the order of modules, attaching a debugger and crashing SSSD on purpose.
</p>
<h3 id="Packagingissues">Packaging issues</h3>
<p>
We need to add conflicts between glibc an an sssd version that doesn't provide the files provider.
</p>
<h3 id="HowToTest">How To Test</h3>
<p>
When properly configured, SSSD should be able to serve local users and groups. Testing this could be as simple as
</p>
<pre class="wiki">getent -s sss passwd localuser
</pre><p>
Of course, testing on the distribution level could be more involved. For the first phase, of just adding the files provider, nothing should break and the only thing the user should notice is improved performance.
Corner cases like running <tt>sssd_nss</tt> under gdb or corefile generation with setup where <tt>sss</tt> is set first in nsswitch.conf must be done as well.
</p>
<h3 id="HowToDebug">How To Debug</h3>
<p>
A simple way of checking is some issue is caused by this new setup is to revert the order of NSS modules back to read <tt>files sss</tt>.
</p>
<h3 id="Authors">Authors</h3>
<ul><li>Stephen Gallagher &lt;<a class="mail-link" href="mailto:sgallagh@redhat.com"><span class="icon">​</span>sgallagh@redhat.com</a>&gt;
</li><li>Jakub Hrozek &lt;<a class="mail-link" href="mailto:jhrozek@redhat.com"><span class="icon">​</span>jhrozek@redhat.com</a>&gt;
</li></ul></body></html>