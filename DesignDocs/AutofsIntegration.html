<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="SSSDandautomounterintegration">SSSD and automounter integration</h1>
<p>
This design page describes integration of autofs and SSSD in a more centralized manner. The discussion started on SSSD mailing list and then in <a class="ext-link" href="https://bugzilla.redhat.com/show_bug.cgi?id=683523"><span class="icon">â€‹</span>Red Hat Bugzilla</a>.
This page summarizes the discussions and design.
</p>
<p>
Autofs is able to look up maps stored in LDAP. However, autofs does all the lookups on its own. Even though autofs uses the <tt>nsswitch.conf</tt> configuration file, there is no glibc interface such as those for retreiving users and groups and by extension no nscd caching.
</p>
<p>
The benefits of the integration would be:
</p>
<ul><li>unified configuration of LDAP servers, timeout parameters, DNS SRV lookups, ...
</li><li>only one connection to the LDAP server open
</li><li>caching of the data
</li><li>offline access - even though if the client cannot connect to the LDAP server chances are that the NFS server is unreachable as well
</li><li>back end abstraction - data may be stored in NIS or other databases and accessed by the automounter transparently
</li></ul><p>
The solution we selected is to provide a new automounter lookup module that would communicate with SSSD.
</p>
<h2 id="autofslookupmodules">autofs lookup modules</h2>
<p>
There are several internal interfaces within autofs implemented as shared libraries, one is the lookup module.
</p>
<p>
A lookup module is implemented for each information source and they each have a fixed interface. Upon loading, automount will get the library entry points via dlopen(). There are several entry points such as:
</p>
<ul><li><tt>lookup_init()</tt> and <tt>lookup_done()</tt> are called when the module is first used and when the module is no longer needed. 
</li><li><tt>lookup_read_master()</tt> is called at program start to read the master map.
</li><li><tt>lookup_read_map()</tt> reads the entire map.
</li><li><tt>lookup_mount()</tt> looks up an automount map key.
</li></ul><p>
The lookup module is passed autofs internal data structures and must handle all the corner cases there can be - so the lookup module shouldn't be exposed outside autofs and should be developed as part of autofs.
</p>
<p>
The lookup modules are named <tt>&lt;autofs library dir&gt;/lookup_&lt;source&gt;.so</tt> where <tt>&lt;source&gt;</tt> is the source name from the "automount:" line of <tt>/etc/nssswitch.conf</tt>. So the SSSD lookup module would be named <tt>lookup_sss.so</tt> and selected in nsswitch.conf with the directive <tt>automount: files sss</tt> (to allow for local client overrides) or just <tt>automount: sss</tt>.
</p>
<p>
In particular, the lookup module calls an iterator to walk through the &lt;key, value&gt; pairs in a map or lookup a key by name in a map.
</p>
<p>
The lookup_sss module needs to connect to SSSD and request the data from SSSD somehow. This would be done by adding a couple of functions into the libnss_sss.so module. The lookup_sss.so module would dlopen() libnss_sss.so and dlsym() the functions needed.
</p>
<h2 id="TheAPIprovidedbySSSD">The API provided by SSSD</h2>
<p>
The SSSD API would live in libnsss_sss.so. That means polluting the library a little with functions that are not strictly name-service-switch related, but would allow us to reuse a fair amount of code and talk to the NSS responder socket easily.
</p>
<p>
The API itself would define the following functions:
</p>
<ul><li>iterator start that would allocate the private struct automtent and pass it out as context
</li></ul><blockquote>
<blockquote>
<p>
<tt>errno_t _sss_setautomntent(const char *mapname, void **context);</tt>
</p>
</blockquote>
</blockquote>
<ul><li>iterator end that would free the private struct automtent
</li></ul><blockquote>
<blockquote>
<p>
<tt>errno_t _sss_endautomntent(void **context);</tt>
</p>
</blockquote>
</blockquote>
<ul><li>function that returns the next (key,value) pair given a context
</li></ul><blockquote>
<blockquote>
<p>
<tt>errno_t _sss_getautomntent_r(const char **key, const char **value, void *context);</tt>
</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>
The <tt>key</tt> and <tt>value</tt> strings are allocated with <tt>malloc()</tt> and must be freed by the caller
</p>
</blockquote>
</blockquote>
<ul><li>function that looks up data for a given key
</li></ul><blockquote>
<blockquote>
<p>
<tt>errno_t _sss_getautomntbyname_r(const char *key, const char **value, void *context);</tt>
</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>
The <tt>value</tt> string is allocated with <tt>malloc()</tt> and must be freed by the caller
</p>
</blockquote>
</blockquote>
<p>
The context parameter is a private structure defined in the libnss_sss library that would keep track of the iterator:
</p>
<pre class="wiki">struct automtent {
    const char *mapname;
    size_t cursor;
    /* Other data TBD as needed */
};
</pre><p>
The iterator is passed as the last parameter of the functions which may seem a bit odd, but it is an autofs convention. Because the sole consumer of this interface would be autofs itself, I decided to keep it the autofs way.
</p>
<p>
When the API functions are called, SSSD would send a request through the NSS pipe to the responder, which would consult the back end similar to how other name service switch requests are handled.
</p>
<h3 id="StoringthedatainSSSDcache">Storing the data in SSSD cache</h3>
<p>
In the first version, SSSD should just schedule a periodic task to download automounter data similar to how user/group enumeration task is scheduled. The automounter maps can potentially be huge, so we might need to optimize the download task in later versions. One idea for future enhancement is to use entryUSN number in deployments that support it.
</p>
<h3 id="TheLDAPschemausedbyautofs">The LDAP schema used by autofs</h3>
<p>
There are three schemas that can be used for storing autofs data in LDAP. They do not differ in semantics the way RFC2307 and RFC2307bis schemas differ in the member/memberuid attribute. The difference in schemas is mostly
attribute and objectclasses naming and how the DNs are constructed. The DNs are also not used by the client. SSSD should convert the data into a cache-specific schema. The cache specific schema will be based on the RFC2307bis automounter schema, which is by far the most widely used schema.
</p>
<p>
Each of the schemas define objectclass names for map and entry and attribute names for map name (used by map) and key and value attribute names (used by map entry).
</p>
<div class="document">
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="28%" />
<col width="15%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><em>attribute</em></th>
<th class="head"><em>RFC2307bis</em></th>
<th class="head"><em>NIS</em></th>
<th class="head"><em>RFC2307 extension</em></th>
</tr>
</thead>
<tbody valign="top">
<tr><td><em>map objectclass</em></td>
<td>automountMap</td>
<td>nisMap</td>
<td>automountMap</td>
</tr>
<tr><td><em>entry objectclass</em></td>
<td>automount</td>
<td>nisObject</td>
<td>automount</td>
</tr>
<tr><td><em>map attribute</em></td>
<td>automountMapName</td>
<td>nisMapName</td>
<td>ou</td>
</tr>
<tr><td><em>entry attribute</em></td>
<td>automountKey</td>
<td>cn</td>
<td>cn</td>
</tr>
<tr><td><em>value attribute</em></td>
<td>automountInformation</td>
<td>nisMapEntry</td>
<td>automountInformation</td>
</tr>
</tbody>
</table>
</div>
<p>
An example of the RFC2307bis schema showing an entry for /home/foo included in the master map:
</p>
<pre class="wiki">dn: automountMapName=auto.master,dc=example,dc=com
objectClass: top
objectClass: automountMap
automountMapName: auto.master

dn: automountMapName=auto.master,dc=example,dc=com
objectClass: automount
cn: /home
automountKey: /home
automountInformation: auto.home

dn: automountMapName=auto.home,dc=example,dc=com
objectClass: automountMap
automountMapName: auto.home

dn: automountKey=foo,automountMapName=auto.home,dc=example,dc=com
objectClass: automount
automountKey: foo
automountInformation: filer.example.com:/export/foo
</pre><p>
Most, if not all, of the autofs documentation out there describes the naming schema as per RFC2307bis, but it is technically possible to use autofs objects created according to RFC2307bis and user/group objects created according to plain RFC2307 in the same tree.
Because the schemas differ in attribute naming only, not semantically, it is trivial to override the schema in the config file. We just need to pick the right defaults and adjust according to user feedback.
</p>
<p>
One difference between filesystem entries and entries in LDAP is that the "cn" attribute is case-insensitive, unlike key names which are essentially directory names. This seems to be one of the reasons the RFC2307bis schema was adopted.
</p>
<h3 id="SSSDConfiguration">SSSD Configuration</h3>
<p>
The autofs support would be turned on by specifying <tt>autofs_provider = ldap</tt> in a domain section. A new search base <tt>ldap_autofs_search_base</tt> option will be introduced as well. The periodic download task will default to <tt>ldap_search_base</tt>.
</p>
<p>
SSSD will also include new attribute overrides for the new autofs map in order to support all the schemas users might have been using.
</p>
<p>
This work is targeted at the same SSSD milestone as separating the cache timeout parameters, so we might also need to include a new autofs cache timeout.
</p>
<p>
We also need to create a migration document for users of the native autofs LDAP support. 
</p>
<h4 id="FullyQualifiedNames">Fully Qualified Names</h4>
<p>
With user/group lookups, the domain can be specified by using a "fully-qualified-name", for example getent passwd <a class="mail-link" href="mailto:jhrozek@redhat.com"><span class="icon">â€‹</span>jhrozek@redhat.com</a>. We should support something similar with autofs. However, maps can include any characters that are valid for filesystem path names, including '@', so there's a potential conflict.
</p>
<ul><li>if there are more LDAP domains with autofs on, they are searched sequentially until a match is found. This is how user searches work, too
</li><li>FQDN requests will be allowed by default, but not required unless <tt>use_fully_qualified_names</tt> is set to TRUE
</li><li>The FQDN name-domain separator is @ by default, but SSSD allows it to be configurable even in the current using the <tt>re_expression</tt> parameter.
</li></ul><h3 id="Futureandmiscellanouswork">Future and miscellanous work</h3>
<p>
The first iteration will aim at providing a working autofs integration for generic LDAP servers. There is a number of tasks that might not make the first iteration but should be tracked and done in the future.
</p>
<ol><li>Native IPA automount schema
<ul><li>autofs client does not know the concept of "locations" but that doesn't really matter. The locations objects in LDAP are of the "nscontainer" class and are only part of the DN. The client does not care about DNs, so we are safe storing the locations in cache as-is.
</li></ul></li><li>A migration script
<ul><li>this can be lower priority with the migration documentation in place 
</li></ul></li></ol></body></html>