<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="FeatureName">Feature Name</h1>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2553"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2553</a>
</li></ul><h3 id="Problemstatement">Problem statement</h3>
<p>
The InfoPipe responder adds a listing capability to the frontend code,
allowing the user to list users matching a very simple filter. To implement
the back end part of this feature properly, we need to add the possibility
to retrieve multiple, but not all entries with a single DP request.
</p>
<p>
For details of the InfoPipe API, please see the <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs/DBusUsersAndGroups.html"><span class="icon">​</span>DBus responder design page</a>.
</p>
<h3 id="Usecases">Use cases</h3>
<p>
A web application, using the InfoPipe interface requests all users starting
with the letter 'a' so the users can be displayed in the application UI
on a sigle page. The SSSD must fetch and return all matching user entries,
but without requiring enumeration, which would pull down too many users.
</p>
<h3 id="Overviewofthesolution">Overview of the solution</h3>
<p>
Currently, the input that Data Provider receives can only be a single user
or group name. Wildcards are not supported at all, the back end actively
sanitizes the input to escape any characters that have a special meaning
in LDAP. Therefore, we need to add functionality to the Data Provider to
mark the request as a wildcard.
</p>
<p>
Only requests by name will support wildcards, not i.e. requests by
SID, mostly because there would be no consumer of this functionality.
Technically we could allow wildcard searches on any attribute
with the same code, though. Also, only requests for users and groups will
support wildcards.
</p>
<p>
When the wildcard request is received by the back end, sanitization will
be done, but modified in order to avoid escaping the wildcard. After the
request finishes, a search-and-delete operation must be run in order to
remove entries that matched the wildcard search previously but were removed
from the server.
</p>
<h3 id="Implementationdetails">Implementation details</h3>
<p>
The wildcard request will only be used by the InfoPipe responder, but will be implemented
in the common responder code, in particular the new <tt>cache_req</tt> request.
</p>
<p>
The following sub-sections document the changes explained earlier in more detail.
</p>
<h4 id="Responderlookupchanges">Responder lookup changes</h4>
<p>
The responder code changes will be done only in the new cache lookup
code (<tt>src/responder/common/responder_cache_req.c</tt>). Since the NSS responder
wouldn't initially expose the functionality of wildcard lookups, we don't need
to update the lookup code currently in use by the NSS responder.
</p>
<p>
The <tt>cache_req_input_create()</tt> function should be extended to denote that
the <tt>name</tt> input contains a wildcard to make sure the caller really intends
to left the asterisk unsanitized. Internally, the <tt>cache_req_type</tt> would add
a new value as well.
</p>
<p>
We might add a new user function and a group function that would grab
all entries by sysdb filter, which can be more or less a wrapper around
<tt>sysdb_search_entry</tt>, just setting the right search bases and default
attributes. This new function must be able to handle views.
</p>
<p>
These responder changes should be developed as a first phase of the work as
they can be initially tested with enumeration enabled on the back end side.
</p>
<h4 id="Responder-DataProvidercommunication">Responder &lt;-&gt; Data Provider communication</h4>
<p>
The request between the responders and the Data Provider is driven by a string filter, formatted as follows:
</p>
<pre class="wiki">    type:value:extra
</pre><p>
Where <tt>type</tt> can be one of <tt>name</tt>, <tt>idnumer</tt> or <tt>secid</tt>. The <tt>value</tt> field
is the username, ID number or SID value and extra currently denotes either
lookup with views or lookup by UPN instead of name.
</p>
<p>
To support the wildcard lookups, we have two options here - add a new
<tt>type</tt> option (perhaps <tt>wildcard_name</tt>) or add another <tt>extra_value</tt>.
</p>
<p>
Adding a new <tt>type</tt> would be easier since it's just addition of new code, not
changing existing code. On the backend side, the <tt>type</tt> would be typically
handled together with <tt>name</tt> lookups, just sanitize the input differently.
The downside is that if we wanted to ever allow wildcard lookups for
anything else, we'd have to add yet another type. Code-wise, adding a new
type would translate to adding new values for the <tt>sss_dp_acct_type</tt> enum which
would then print the new type value when formatting the sbus message.
</p>
<p>
The other option would be to allow multivalued <tt>extra</tt> field:
</p>
<pre class="wiki">    type:value:extra1:extra2:...:extraN
</pre><p>
However, that would involve changing how we currently handle the <tt>extra</tt>
field, which is higher risk of regressions. Also, the back ends can
technically be developed by a third party, so we should be extremely careful
about changing the protocol between DP and providers. Since we don't expect
to allow any other wildcard requests than by name yet, I'm proposing to
go with the first option and add a comment to the code to change to using
the extra field if we need wildcard lookups by another attribute.
</p>
<h4 id="Relaxthesss_filter_sanitizefunction">Relax the <tt>sss_filter_sanitize</tt> function</h4>
<p>
When a wildcard request is received, we still need to sanitize the input and
escape special LDAP characters, but we must not escape the asterisk (<tt>*</tt>).
</p>
<p>
As a part of the patchset we need to add a parameter that will denote
characters that should be skipped during sanitization.
</p>
<h4 id="Deletecachedentriesremovedfromtheserver">Delete cached entries removed from the server</h4>
<p>
After a request finishes, the back end needs to remove entries that are
cached from a previous lookup using the same filter, but no longer present
on the server.
</p>
<p>
Because wildcard requests can match multiple entries, we need to save the time
of the backend request start and delete all entries that match a sysdb filter
analogous to the LDAP filter, but were last updated prior to the start of 
the request.
</p>
<p>
Care must be taken about case sensitivity. Since the LDAP servers are
typically case-insensitive, but sysdb (and POSIX systems) are case-sensitive,
we will default to matching only case-sensitive <tt>name</tt> attribute by default
as well. With case-insensitive back ends, the search function must match
also the <tt>nameAlias</tt> attribute.
</p>
<h4 id="LDAPproviderchanges">LDAP provider changes</h4>
<p>
The LDAP provider is the lowest common denominator of other providers and hence
it would contain the low-level changes related to this feature.
</p>
<p>
In the LDAP provider, we need to use the relaxed version of the input
sanitizing and the wildcard method to delete matched entries. These changes
will be contained to the <tt>users_get_send()</tt> and <tt>groups_get_send()</tt> requests.
</p>
<p>
The requests that fetch and store the users or groups from LDAP currently
have a parameter called <tt>enumerate</tt> that is used to check whether it's
OK to receive multiple results or not. We should rename the parameter or
even invert it along with renaming (i.e change the name to <tt>direct_lookup</tt>
or similar).
</p>
<p>
We also need to limit the number of entries returned from the
server, otherwise the wildcard request might easily turn into a full
enumeration. To this end, we will add a new configuration option
<tt>wildcard_search_limit</tt>. Internally, we would change the boolan
parameter of <tt>sdap_get_users_send</tt> to a tri-state that would control
whether we expect only a single entry (ie don't use the paging control),
multiple entries with a search limit (wildcard request) or multiple entries
with no limit (enumeration). We need to make sure during implementation that
it is discoverable via DEBUG messages that the upper limit was reached.
</p>
<h4 id="IPAproviderchanges">IPA provider changes</h4>
<p>
The tricky part about IPA provider are the views. The lookups with views
have two branches - either an override object matches the input and then
we look up the corresponding original object or the other way around. The
code must be changed to support multiple matches for both overrides and
original objects in the first pass. We might end up fetching more entries
than needed because the resulting object wouldn't match in the responder
after applying the override, but the merging on the responder side will
only filter out the appropriate entries.
</p>
<p>
Currently, the request handles all account lookups in a single tevent
request, with branches for special cases, such as initgroup lookups or
resolving ghost members during group lookups. We might need to refactor
the single request a bit into per-object tevent lookups to keep the code
readable.
</p>
<p>
Please keep in mind that each tevent request has a bit of performance
overhead, so adding new request is always a trade-off. Care must be taken
to not regression performance of the default case unless necessary.
</p>
<p>
If the first override lookup matches, then we must loop over all returned
overrides and find matching originals. The current code re-uses the state-&gt;ar
structure, which is single-valued, we need to add another multi-valued
structure instead (<tt>state-&gt;override_ar</tt>) and perhaps even split the lookup
of original objects into a separate request, depending on the complexity.
</p>
<p>
Conversely, when the original objects match first, we need to loop over the
original matches and fetch overrides for each of the objects found. Here,
the <tt>get_object_from_cache()</tt> function needs to be able to return multiple
results and the following code must be turned into a loop.
</p>
<p>
When looking up the overrides, the <tt>be_acct_req_to_override_filter()</tt>
must be enhanced to be able to construct a wildcard filter. The
<tt>ipa_get_ad_override_done</tt> must also return all matched objects if needed,
not just the first array entry. The rest of the <tt>ipa_get_ad_override_send()</tt>
request is generic enough already.
</p>
<h4 id="IPAsubdomainlookupsviatheextdomplugin">IPA subdomain lookups via the extdom plugin</h4>
<p>
Currently the extdom plugin only supports direct entry lookups, even on the
server side. We could add a new request that accepts a filter with asterisk
and returns a list of matching DNs or names, but because of the complexity
of the changes, this part of implementation should be deferred until requested specifically.
</p>
<p>
If the IPA subdomain would receive a wildcard request, it would reply with
an error code that would make it clear this request is not supported.
</p>
<p>
Making sure the IPA provider in server mode is capable of returning wildcard
entries and adding a wildcard-enabled function for the <tt>libnss_sss_idmap</tt>
library would a prerequisity so that the extop plugin can request multiple
entries from the SSSD running in the server mode.
</p>
<h4 id="ADproviderchanges">AD provider changes</h4>
<p>
No changes seem to be required for the AD provider, since the AD provider
mostly just passes around the original <tt>ar</tt> request to a Global Catalog
lookup or an LDAP lookup. However, testing must be performed in an
environment where some users have POSIX attributes but those attributes are
not replicated to the Global Catalog to make sure we handle the fallback
between connections well.
</p>
<h4 id="Otherproviders">Other providers</h4>
<p>
Proxy provider support is not realistic, since the proxy provider only
uses the NSS functions of the wrapped module which means it would rely
on enumeration anyway. With enumeration enabled, the responders would be
able to return the required matching entries already. The local provider
is not a real back end, so it should get the wildcard support for free,
just with the changes to the responder.
</p>
<h3 id="Configurationchanges">Configuration changes</h3>
<p>
A new option <tt>wildcard_search_limit</tt> will be added. The default value
would be 1000, which is also typically the size of one page.
</p>
<h3 id="HowToTest">How To Test</h3>
<p>
When the InfoPipe API is ready, then testing will be done using the methods
such as ListByName. Until then, the feature is not exposed or used anyway,
so developers can test using a special command-line tool that would send the
DP request directly. This tool wouldn't be commited to the git tree.
</p>
<h3 id="Authors">Authors</h3>
<ul><li>Jakub Hrozek &lt;<a class="mail-link" href="mailto:jhrozek@redhat.com"><span class="icon">​</span>jhrozek@redhat.com</a>&gt;
</li></ul></body></html>