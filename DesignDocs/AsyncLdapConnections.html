<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="AsynchronousLDAPconnections">Asynchronous LDAP connections</h1>
<h2 id="ProblemStatement">Problem Statement</h2>
<p>
Currently, connecting to an LDAP server by the openldap library is
blocking. This means that when SSSD attempts to connect to an unresponsive
server, it can block up to 5 second (the current default setting of
<tt>ldap_network_timeout</tt>). This is not ideal, as we would like to be
able to do something else while the connection is being made.
</p>
<h2 id="GeneralApproach">General Approach</h2>
<p>
Recent versions of openldap have a new (and not very well documented) option
<tt>LDAP_OPT_CONNECT_ASYNC</tt> that can be set by <tt>ldap_set_option()</tt>. This
option will cause all ldap functions that create a new connection to only
invoke <tt>connect()</tt> and not wait for the socket to become ready for writing.
If it is not, the function will return <tt>LDAP_X_CONNECTING</tt> and it has to be
executed again after the socket becomes ready.
</p>
<h2 id="Implementation">Implementation</h2>
<p>
Because a lot of ldap functions can cause the creation of a new socket,
every such function will be wrapped into a tevent_req interface. Every such
wrapper will consist of a standard <tt>send</tt> and <tt>recv</tt> function, as well as
a so called <tt>try</tt> function.
</p>
<p>
The <tt>send</tt> function will copy all the arguments into the state data
structure and invoke the <tt>try</tt> function, passing the <tt>tevent_req</tt> to it.
The try function will invoke the openldap function with all the arguments
from the state. The <tt>try</tt> function will then return <tt>0</tt> if
<tt>LDAP_X_CONNECTING</tt> was returned signaling that we will have to invoke it
one more time later. In case the connection was already available,
<tt>tevent_req_done()</tt> or <tt>tevent_req_error()</tt> is invoked and <tt>1</tt> is returned.
</p>
<h3 id="Callbacks">Callbacks</h3>
<p>
The implementation will make a heavy use of both openldap and tevent
callbacks. Our goal is to be able to invoke the <tt>try</tt> function from the
tevent callback (which will be invoked by tevent after the socket is ready
for writing). The main problem is to make both the <tt>try</tt> function and the
<tt>tevent_req</tt> available to this callback. The callbacks that we need work as
follows:
</p>
<ol><li>Openldap callbacks are set by <tt>ldap_set_option()</tt> with the <tt>option</tt> argument set
to <tt>LDAP_OPT_CONNECT_CB</tt>. Additional data structure (`struct
ldap_cb_data`) is passed in as well. This data structure will always be
passed to the openldap callback. This is currently done in
<tt>setup_ldap_connection_callbacks()</tt>.
</li><li>Right after an openldap function creates a connection, it will call the
callback passing to it (among other things) the newly created socket.
In SSSD, this callback is <tt>sdap_ldap_connect_callback_add()</tt>.
</li><li>The callback will then register a tevent callback <tt>sdap_ldap_result()</tt>
which is invoked when the socket is ready for writing and is
responsible for calling <tt>ldap_result()</tt>.
</li></ol><p>
What we need to do is to make sure that the tevent callback is called not
only when the socket is ready for reading, but also when it is ready for
writing (but only once, since it will always be ready for writing after the
connection is made). We also need to provide the tevent callback with the
<tt>try</tt> function and the associated <tt>tevent_req</tt> structure. After the socket
is ready for writing, we call the <tt>try</tt> function and pass it the
<tt>tevent_req</tt> so it can call the ldap function again and mark the tevent
request as finished.
</p>
<p>
To pass the tevent request to the tevent callback, we need to take a bit of
a detour. Every <tt>try</tt> function, before calling the ldap function has to
call <tt>set_fd_retry_cb()</tt> passing in a pointer to itself and the tevent
request. This function will save these to the data structure that is
available to the ldap callback. This callback is called after the socket is
created and in turn, the function pointer and the tevent request are made
available to the newly registered tevent callback, which is what we wanted.
The <tt>try</tt> function also has to call <tt>set_fd_retry_cb()</tt> again after the
ldap function is called and set both the function pointer and the tevent
request pointer to <tt>NULL</tt>. So now when it's all set, after the socket is
ready for writing we can call the <tt>try</tt> function from the tevent callback
to finish the whole transaction.
</p>
<h2 id="Spies">Spies</h2>
<p>
One problem with the approach described in the previous section is with
storing the tevent request in a place out of the tevent chain. If the
request gets freed before there is a chance to call the <tt>try</tt> function, we
will be left with a dangling pointer that might eventually be dereferenced.
</p>
<p>
To solve this problem, we create a sort of a "spy" that will free the
<tt>fd_event_item</tt> associated with the tevent callback in case the request is
freed. The spy is created in the ldap callback. The following diagram and
code illustrate how the spy is used to make sure there are no dangling
pointers left:
</p>
<p>
<a style="padding:0; border:none"><img /></a>
</p>
<div class="code"><pre>request_spy_destructor<span class="p">(</span><span class="k">struct</span> request_spy <span class="o">*</span>spy<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>spy<span class="o">-&gt;</span>ptr<span class="p">)</span> <span class="p">{</span>
        spy<span class="o">-&gt;</span>ptr<span class="o">-&gt;</span>spy <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        talloc_free<span class="p">(</span>spy<span class="o">-&gt;</span>ptr<span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

fd_event_item_destructor<span class="p">(</span><span class="k">struct</span> fd_event_item <span class="o">*</span>fd_event_item<span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>fd_event_item<span class="o">-&gt;</span>spy<span class="p">)</span>
        fd_event_item<span class="o">-&gt;</span>spy<span class="o">-&gt;</span>ptr <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></body></html>