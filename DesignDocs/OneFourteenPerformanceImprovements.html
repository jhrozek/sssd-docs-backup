<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="FeatureName">Feature Name</h1>
<p>
SSSD Performance enhancements for the 1.14 release
</p>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2602"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2602</a>
</li><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2062"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2062</a>
</li></ul><h3 id="Problemstatement">Problem statement</h3>
<p>
At the moment SSSD doesn't perform well in large environments. Most of
the use-cases we've had reported revolved around logins of users who are
members of large groups or a large amount of groups. Another reported
use-case was the time it takes to resolve a large group.
</p>
<p>
While workarounds are available for some of the issues (such as using
<tt>ignore_group_members</tt> for resolution of large groups), our goal is to be
able to perform well without these workarounds.
</p>
<h3 id="Usecases">Use cases</h3>
<ul><li>User who is a member of a large amount of AD groups logs in to a Linux server that is a member of the AD domain.
</li><li>User who is a member of a large amount of AD or IPA groups logs in to a Linux server that is a member of an IPA domain with a trust relationship to an AD domain
</li><li>Administrator of a Linux server runs "ls -l" in a directory where files are owned by a large group. An example would be group called "students" in an university setup
</li></ul><h3 id="Overviewofthesolution">Overview of the solution</h3>
<p>
During performance analysis with systemtap, we found out that the biggest
delay happens when SSSD writes an entry to the cache, especially for large group entries.
This is also confirmed by empirical evidence from our users, where most
deployments were OK with SSSD performance once the cache was moved to tmpfs or
even when <tt>ignore_group_members</tt> option was enabled.
</p>
<p>
We can't skip cache writes completely, even if no attributes changed,
because we store also the expiration timestamps in the cache. Also, even if
a single attribute (like the timestamp) changes, ldb would need to unpack the
whole entry, change the record, pack it back and then write the whole blob.
</p>
<p>
In order to mitigate the costly cache writes, we should avoid writing the
whole cache entry on every cache update, but only write the entries if something
actually changed.
</p>
<p>
To avoid this, we will split the monolithic ldb cache representing the
sysdb cache into two ldb files. One would contain the entry itself and would
be fully synchronous. The other (new one) would only contain the timestamps
and would be open using the <tt>LDB_FLG_NOSYNC</tt> to avoid synchronous cache writes.
</p>
<p>
This would have two advantages:
</p>
<ol><li>If we detect that the entry hasn't changed on the LDAP server at all, we could avoid writing into the main ldb cache which would still be costly. We would use the value of the <tt>modifyTimestamp</tt> attribute of the LDAP entry to see if the entry had changed or not.
</li><li>The writes to the new async ldb cache would be much faster, because the entry is smaller and because the writes wouldn't call <tt>fsync()</tt> due to using the async flag, but rather rely on the underlying filesystem to sync the data to the disk.
</li></ol><p>
On SSSD shutdown, we would write a canary to both the timestamp cache
and the main sysdb cache, denoting graceful shutdown. On SSSD startup,
if the canary wasn't found or if the values differ, we would just ditch
the timestamp cache, which would result in refresh and write of the entry
on the next lookup.
</p>
<p>
The basic idea is to use a combination of the operational <tt>modifyTimestamp</tt>
attribute and checking the entry itself to see if the entry changed at
all and if not, avoid writing to the cache.
</p>
<p>
Checking the value of <tt>modifyTimestamp</tt> would be enough for group entries,
which should be the first iteration of this work. For checking if other
entries (mostly users) have changed, we need to compare the value of
the attributes in the cache with what we are about to store in the cache.
</p>
<p>
Therefore, these enhancements are proposed for the 1.14 versions, sorted by the importance as observed with systemtap testing:
</p>
<ul><li>only write the cache entry if the <tt>modifyTimestamp</tt> of the original entry had changed. If it hasn't changed, only the timestamps would be written to the timestamp cache
</li><li>if the <tt>modifyTimestamp</tt> had changed, compare the attributes of the cache entry with the attributes we are about to write. If there are no differences, only write to the timestamp cache
</li><li>refactor the nested group processing to make sure expensive lookups (such as lookups of all members of the group, there can potentially be thousands of these) are only performed once and intermediate results are stored in-memory.
</li><li>attempt to shortcut parsing the attributes of the entry returned from LDAP sooner. The idea behind this is that if the <tt>modifyTimestamp</tt> did not change, we can reuse the entry we already cached.
</li></ul><p>
Minor enhancements in later versions might include:
</p>
<ul><li>using syncrepl in the server mode for HBAC rules and external groups in refreshAndPersistMode. This would provide performance benefit for legacy clients that rely on server's HBAC rules for access control.
</li><li>using syncrepl in the server mode for external groups in refreshAndPersistMode. This would mainly simplify the external groups handling, rather than improve performance
</li><li>A lot of time is spent looking up attributes in the <tt>sysdb_attrs</tt> array. This is something we might want to optimize after we're done with the cache writes.
</li><li>We might even consider offering syncrepl in refreshOnly mode as an client-side option for enumeration. However, this would have to be an opt-in because every refresh causes the server to walk the changelog since the last refresh operation. Enabling this option on all clients would trash the server performance.
</li></ul><h3 id="Implementationdetails">Implementation details</h3>
<p>
The <tt>sysdb_ctx</tt> already contains a handle of the main sysdb cache. We
would add another ldb file that only contains the timestamp and the DN of
an entry. This ldb file would be opened in the nosync mode. Attributes used
for lookups, like <tt>dataExpireTimestamp</tt> must be indexed in this database
as well.
</p>
<p>
When storing a user or a group to sysdb using functions like
<tt>sysdb_store_user</tt>, we first check the difference between <tt>modifyTimestamp</tt>
attributes. If there are no differences, only the timestamp attributes,
such as <tt>lastUpdate</tt> or <tt>dataExpireTimestamp</tt> would be updated in the
timestamp cache. We need to do this check in the lower-level sysdb calls
to make sure this enhancement also works for users and groups retrieved
through the extop plugin.
</p>
<p>
If the value of <tt>modifyTimestamp</tt> differs, we proceed to checking the diff
between values in the cache and the values read from LDAP.
</p>
<p>
Details about shortcut of attribute parsing will be added to this design
page later.
</p>
<h3 id="Configurationchanges">Configuration changes</h3>
<p>
Currently no configuration changes are expected. We might add some if we decide to implement on-demand syncrepl.
</p>
<h3 id="HowToTest">How To Test</h3>
<p>
If the entries on the server did not change (except timestamps), then actions like user and group lookups and logins should be considerably faster.
</p>
<p>
The SSSD should also correctly detect when the entries in fact did change on the server. In this case, a full cache write will be performed.
</p>
<h3 id="Authors">Authors</h3>
<ul><li>Jakub Hrozek &lt;<a class="mail-link" href="mailto:jhrozek@redhat.com"><span class="icon">​</span>jhrozek@redhat.com</a>&gt; with the kind help of
</li><li>Sumit Bose &lt;<a class="mail-link" href="mailto:sbose@redhat.com"><span class="icon">​</span>sbose@redhat.com</a>&gt;
</li><li>Ludwig Krispenz &lt;<a class="mail-link" href="mailto:lkrispen@redhat.com"><span class="icon">​</span>lkrispen@redhat.com</a>&gt;
</li><li>Simo Sorce &lt;<a class="mail-link" href="mailto:simo@redhat.com"><span class="icon">​</span>simo@redhat.com</a>&gt;
</li></ul></body></html>