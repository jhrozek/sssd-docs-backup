<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="SocketActivatableResponders">Socket Activatable Responders</h1>
<p>
Related ticket(s):
</p>
<ul><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/2243"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/2243</a>
</li><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/3129"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/3129</a>
</li><li><a class="ext-link" href="https://fedorahosted.org/sssd/ticket/3245"><span class="icon">​</span>https://fedorahosted.org/sssd/ticket/3245</a>
</li></ul><h3 id="Problemstatement">Problem statement</h3>
<p>
SSSD has some responders which don't have to be running all the time, but could be socket-activated instead in platforms where it's supported. That's the case, for instance, for the IFP, ssh and sudo responders.
Making these responders socket-activated would provide a better use experience, as these services could be started on-demand when a client needs them and exist after a period of inactivity. Currently the admin
has to explicitly list all the services that might potentially be needed in the <tt>services</tt> section and the processes have to be running all the time.
</p>
<h3 id="Usecases">Use cases</h3>
<h4 id="sssctl">sssctl</h4>
<p>
As more and more features that had been added depending on the IFP responder, we should make sure that the responder is activated on demand and the admins doesn't have to activate it manually.
</p>
<h4 id="KCM">KCM</h4>
<p>
The KCM responder is only seldom needed, when libkrb5 needs to access the credentials store. At the same time, the KCM responder must be running if the Kerberos credentials cache defaults to <tt>KCM</tt>. Socket-activating the responder would solve both of these cases.
</p>
<h4 id="autofs">autofs</h4>
<p>
The autofs responder is typically only needed when a share is about to be mounted.
</p>
<h3 id="Overviewofthesolution">Overview of the solution</h3>
<p>
The solution agreed on the mailing list is to add a new unit for each one of the responders. Once a responder is started, it will communicate to the monitor in order to let the monitor know that it's up and the monitor will do the registration of the responder, which basically consists in marking the service as started, increasing the services' counter, getting the responder's configuration, adding the responder to the service's list.
A configurable idle timeout will be implemented in each responder, as part of this task, in order to exit the responder in case it's not used for a few minutes.
</p>
<h3 id="Implementationdetails">Implementation details</h3>
<p>
In order to achieve our goal we will need a small modification in responders' common code in order to make it ready for socket-activation, add some systemd units for each of the responders and finally small changes in the monitor code in order to manage the new activated service.
</p>
<p>
The change in the responders' common code is quite trivial, just change the sss_process_init code to call activate_unix_sockets() istead of set_unix_socket(). Something like:
</p>
<pre class="wiki">-    ret = set_unix_socket(rctx, conn_setup);
+    ret = activate_unix_sockets(rctx, conn_setup);
</pre><p>
The units that have to be added for each responder must look like:
</p>
<p>
sssd-@responder@.service.in (for services which can be run as unprivileged user):
</p>
<pre class="wiki">[Unit]
Description=SSSD SSH Service responder
Documentation=man:sssd.conf(5)
After=sssd.service
BindsTo=sssd.service

[Install]
Also=sssd-ssh.socket

[Service]
ExecStartPre=-/bin/chown @SSSD_USER@:@SSSD_USER@ @logpath@/sssd_ssh.log
ExecStart=@libexecdir@/sssd/sssd_@responder@ --debug-to-files --socket-activated
Restart=on-failure
User=@SSSD_USER@
Group=@SSSD_USER@
PermissionsStartOnly=true
</pre><p>
sssd-@responder@.service.in (for services which cannot be run as unprivileged user):
</p>
<pre class="wiki">[Unit]
Description=SSSD NSS Service responder
Documentation=man:sssd.conf(5)
After=sssd.service
BindsTo=sssd.service

[Install]
Also=sssd-nss.socket

[Service]
ExecStartPre=-/bin/chown root:root @logpath@/sssd_nss.log
ExecStart=@libexecdir@/sssd/sssd_nss --debug-to-files --socket-activated
Restart=on-failure
</pre><p>
sssd-@responder@.socket.in:
</p>
<pre class="wiki">[Unit]
Description=SSSD NSS Service responder socket
Documentation=man:sssd.conf(5)
BindsTo=sssd.service

[Socket]
ListenStream=@pipepath@/@responder@
SocketUser=@SSSD_USER@
SocketGroup=@SSSD_USER@

[Install]
WantedBy=sssd.service
</pre><p>
Some responders may have more than one socket, which is the case of PAM, so another unit will be needed.
</p>
<p>
sssd-@<a class="mail-link" href="mailto:responder@-priv.socket.in"><span class="icon">​</span>responder@-priv.socket.in</a>:
</p>
<pre class="wiki">[Unit]
Description=SSSD PAM Service responder private socket
Documentation=man:sssd.conf(5)
BindsTo=sssd.service
BindsTo=sssd-@responder@.socket

[Socket]
Service=sssd-@responder@.service
ListenStream=@pipepath@/private/@responder@
SocketUser=root
SocketGroup=root
SocketMode=0600

[Install]
WantedBy=sssd.service
</pre><p>
Last but not least, the IFP responder doesn't have a socket. It's going to be D-Bus activated and some small changes will be required on its D-Bus service unit (for platforms where systemd is supported).
</p>
<pre class="wiki">-Exec=@libexecdir@/sssd/sss_signal
+ExecStart=@libexecdir@/sssd/sssd_@responder@ --uid 0 --gid 0 --debug-to-files --dbus-activated
+SystemdService=sssd-ifp.service
+Restart=on-failure
</pre><p>
And, finally, the code in the monitor side will have to have some adjustments in order to properly deal with an empty list of services and, also, to register the service when it's started.
</p>
<p>
As just the responders' will be socket-activated for now, the service type will have to exposed and passed through sbus when calling the <a class="missing wiki" href="https://docs.pagure.org/sssd-test2/RegistrationService.html" rel="nofollow">RegistrationService?</a> method and the monitor will have to properly do the registration of the service when <a class="missing wiki" href="https://docs.pagure.org/sssd-test2/RegistrationService.html" rel="nofollow">RegistrationService?</a>'s callback is triggered. As mentioned before, the "registration" that has to be done from the monitor's side is:
</p>
<ul><li>Mark the service as started;
</li><li>Increase the services' counter;
</li><li>Get the responders' configuration;
</li><li>Set the service's restart number;
</li><li>Add the service to the services' list.
</li></ul><p>
"Unregistering" a socket-activated service will be done when the connection between the service and the monitor is closed.
</p>
<h3 id="Configurationchanges">Configuration changes</h3>
<p>
After this design is implemented, the "services" line in sssd.conf will become optional for platforms where systemd is present. Note that in order to keep backward compatibility, if the "services" line is present, the services will behave exactly as they did before these changes.
</p>
<h3 id="HowToTest">How To Test</h3>
<p>
The easiest way to test is removing the "services" line from sssd.conf and try to use SSSD normally.
Using sssctl tool without having the ifp responder set in the "services" line is another way to test.
</p>
<h3 id="HowToDebug">How To Debug</h3>
<p>
The easiest way to debug this new feature is taking a look on the responders' common initialization code and in the monitors' client registration code.
Is worth to mention that disabling the systemd's services/sockets will prevent the responders' services to be started.
</p>
<h3 id="Authors">Authors</h3>
<p>
Fabiano Fidêncio &lt;<a class="mail-link" href="mailto:fidencio@redhat.com"><span class="icon">​</span>fidencio@redhat.com</a>&gt;
</p>
</body></html>