<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <ol>
      <li>
        <a href="#About">About</a>
      </li>
      <li>
        <a href="#Installation">Installation</a>
      </li>
      <li>
        <a href="#Upgradingfromapreviousversion">Upgrading from a previous version</a>
      </li>
      <li>
        <a href="#RunningSSSD">Running SSSD</a>
      </li>
      <li>
        <a href="#Configuration">Configuration</a>
        <ol>
          <li>
            <a href="#ConfigureNSSforfetchinguserandgroupinformation">Configure NSS for fetching user and group information</a>
          </li>
          <li>
            <a href="#ConfigurePAMforauthentication">Configure PAM for authentication</a>
          </li>
          <li>
            <a href="#SSSDdaemonconfiguration">SSSD daemon configuration</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Configuringservices">Configuring services</a>
        <ol>
          <li>
            <a href="#Generalconfigurationoptions">General configuration options</a>
          </li>
          <li>
            <a href="#NSSconfigurationoptions">NSS configuration options</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Configuringdomains">Configuring domains</a>
        <ol>
          <li>
            <a href="#Domainconfigurationoptions">Domain configuration options</a>
          </li>
          <li>
            <a href="#Optionsvalidforproxyidentitydomains">Options valid for proxy identity domains</a>
          </li>
          <li>
            <a href="#TheLOCALprovider">The LOCAL provider</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Domainconfigurationexamples">Domain configuration examples</a>
        <ol>
          <li>
            <a href="#Example1:AstandaloneLOCALdomain">Example 1: A standalone LOCAL domain</a>
          </li>
          <li>
            <a href="#Example2:AuthenticatingagainstanativeLDAPdomain">Example 2: Authenticating against a native LDAP domain</a>
          </li>
          <li>
            <a href="#Example3:AuthenticatingagainstaKerberosserver">Example 3: Authenticating against a Kerberos server</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h2 id="About">About</h2>
<p>
SSSD provides a set of daemons to manage access to remote directories and authentication mechanisms, it provides an NSS and PAM interface toward the system and a pluggable backend system to connect to multiple different account sources. It is also the basis to provide client auditing and policy services for projects like FreeIPA.
</p>
<p>
SSSD takes advantage of the common set of tools. More information about those tools can be found <a class="wiki" href="https://docs.pagure.org/sssd-test2/WikiPage/SSSDTools.html">here.</a>    
</p>
<p>
This page is intended to outline a series of steps needed to install and configure SSSD. 
It is aimed at Fedora primarily in terms of commands and config file placement, but in general, things should work on other distributions, too.
</p>
<p>
More information about SSSD can be found on its <a class="ext-link" href="https://fedorahosted.org/sssd/"><span class="icon">â€‹</span>project page</a>.
</p>
<p>
This document is being updated for the development version of SSSD.
</p>
<h2 id="Installation">Installation</h2>
<p>
On Fedora (since F11), all that is needed is:
</p>
<pre class="wiki">yum install sssd
</pre><p>
If you're using another distribution or want to get the latest bits from the git repository, clone the SSSD repository:
</p>
<pre class="wiki">git-clone git://fedorahosted.org/sssd/ sssd.git
cd sssd.git
</pre><p>
You can now build and install SSSD locally. The complete process is described into great detail in a text file <tt>BUILD.txt</tt> in sssd's source tree.
</p>
<p>
Another option is to build and install RPMs from the git tree, issue:
</p>
<pre class="wiki">make rpms
</pre><p>
For this to work, you'll also need to have git, and all the build requirements of SSSD installed.
The built RPMs will be in the <tt>rpmbuild/RPMS</tt> subdirectory.
</p>
<h2 id="Upgradingfromapreviousversion">Upgrading from a previous version</h2>
<p>
Starting from version 0.6.0, SSSD uses a different and simplified
configuration file format. Existing config files need to be migrated to the new format and
SSSD provides a script to automate the migration process.
</p>
<p>
If you are using RPMs, the script will be run automatically when upgrading the
package to the new version. Your <tt>/etc/sssd/sssd.conf</tt> config file will be upgraded in-place,
copying the old one to <tt>/etc/sssd/sssd.conf.bak</tt>.
</p>
<p>
If you need to run the script manually, perhaps when using SSSD built from
source, the synopsis is as follows:
</p>
<pre class="wiki">    upgrade_config.py [-f FILE] [-o OUTFILE] [--verbose] [--no-backup]
</pre><p>
When not given, both <tt>FILE</tt> and <tt>OUTFILE</tt> default to <tt>/etc/sssd/sssd.conf</tt>,
performing the conversion in-place and copying the original to <tt>/etc/sssd/sssd.conf.bak</tt>.
Adding the <tt>--no-backup</tt> option would turn off producing the backup files.
</p>
<h2 id="RunningSSSD">Running SSSD</h2>
<p>
To start the daemon, just start the sssd service:
</p>
<pre class="wiki">service sssd start
</pre><p>
For debugging, it may be more comfortable to run the daemon in foreground:
</p>
<pre class="wiki">/usr/sbin/sssd -i
</pre><p>
Another option that might be of interest especially for testing a
configuration is <tt>-d/--debug-level</tt>, that tells sssd to print more debug
information according to debug level specified. The debug level can also be
specified per-service (see below). Timestamps can be added to the debug
information by specifying '--debug-timestamps'
</p>
<h2 id="Configuration">Configuration</h2>
<p>
The configuration of the deamon itself is done via editing
<tt>/etc/sssd/sssd.conf</tt>. The file has a ini-style syntax -  the file consists
of sections that in turn consist of key=value pairs. If you need to use
more values, separate them with commas. For example:
</p>
<pre class="wiki">[section]
key = value
key2 = val,val2
</pre><p>
A comment starts with a hash sign (<tt>#</tt>) or a semicolon (<tt>;</tt>). The data types used
are string, integer and bool (with values of <tt>TRUE/FALSE</tt>).
</p>
<p>
It is also possible to use an alternate config file by using the <tt>-c/--config</tt> parameter of sssd.
</p>
<p>
For more information on configuring SSSD, see the <tt>sssd.conf(5)</tt> man page that
comes with SSSD.
</p>
<h3 id="ConfigureNSSforfetchinguserandgroupinformation">Configure NSS for fetching user and group information</h3>
<p>
In order to configure your system to use sssd for user information, SSSD provides a new <em>nss_sss</em> NSS module. To use it, you
need to configure NSS to use the <em>sss</em> name database along with the classic UNIX file database. Edit your <tt>/etc/nsswitch.conf</tt>:
</p>
<pre class="wiki">passwd:     files sss
group:      files sss
</pre><h3 id="ConfigurePAMforauthentication">Configure PAM for authentication</h3>
<p>
Configuring PAM should be done with extreme care. A mistake or typo in the PAM config file can lock you out of the system completely. Always backup your config files before doing any changes and keep a session open in order to be able to revert changes you do.
</p>
<p>
Enable the use of the SSSD for PAM. If you are changing the default PAM config on Fedora, it should look like:
</p>
<pre class="wiki">#%PAM-1.0
# This file is auto-generated.
# User changes will be destroyed the next time authconfig is run.
auth        required      pam_env.so
auth        sufficient    pam_unix.so nullok try_first_pass
auth        requisite     pam_succeed_if.so uid &gt;= 500 quiet
auth        sufficient    pam_sss.so use_first_pass
auth        required      pam_deny.so

account     required      pam_unix.so broken_shadow
account     sufficient    pam_localuser.so
account     sufficient    pam_succeed_if.so uid &lt; 500 quiet
account     [default=bad success=ok user_unknown=ignore] pam_sss.so
account     required      pam_permit.so

password    requisite     pam_cracklib.so try_first_pass retry=3
password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok
password    sufficient    pam_sss.so use_authtok
password    required      pam_deny.so

session     required      pam_mkhomedir.so umask=0022 skel=/etc/skel/
session     optional      pam_keyinit.so revoke
session     required      pam_limits.so
session     [success=1 default=ignore] pam_succeed_if.so service in crond quiet use_uid
session     sufficient    pam_sss.so
session     required      pam_unix.so

</pre><p>
Recent PAM implementations allow to include PAM configurations, e.g.
</p>
<pre class="wiki">...
session     include      system-auth
session     optional     pam_console.so
...
</pre><p>
If you use includes please note that in the example above pam_console.so is not executed
if a sufficient condition from system-auth returns PAM_SUCCESS. 
</p>
<p>
Some of the later examples use a proxy auth provider between pam_sss and other
PAM modules using the <tt>pam-target</tt> configuration directive that
references a file in <tt>/etc/pam.d</tt>. It is important <strong>not</strong> to include
<tt>pam_sss.so</tt> modules in these proxied targets, otherwise the PAM stack may go
into a loop.
</p>
<h3 id="SSSDdaemonconfiguration">SSSD daemon configuration</h3>
<p>
I suggest that you start with the <tt>/etc/sssd/sssd.conf</tt> file that comes
with the Fedora RPMs as it contains comments to aid you.  The source
distribution contains an example config file in the <tt>server/examples</tt>
subdirectory.
</p>
<h2 id="Configuringservices">Configuring services</h2>
<p>
Individual pieces of SSSD functionality are provided by special SSSD
services that are started and stopped together with SSSD. The services
provided by SSSD have their own configuration sections.
The <tt>[sssd]</tt> section also lists the services that are active
and should be started when sssd starts within the <tt>services</tt> directive.
</p>
<p>
At present, we use three services in this HOWTO - NSS, PAM and a service called monitor
that watches over other services, starts or restarts them as needed.
</p>
<ul><li>An NSS provider service that answers NSS requests from the <tt>nss_sss</tt> module
</li><li>A PAM provider service that manages a PAM conversation through the <tt>pam_sss</tt> PAM module
</li><li>The monitor service maintains the other processes and restarts them if they die. Its options are specified in the [sssd] section
</li></ul><pre class="wiki">[sssd]
services = nss, pam
sbus_timeout = 30

[nss]
filter_users = root
filter_groups = root
</pre><p>
The following subsections list only the most important configuration optiosn. See the <tt>sssd.conf(5)</tt> manual page that is shipped with SSSD for all the configuration options available.
</p>
<h3 id="Generalconfigurationoptions">General configuration options</h3>
<dl class="wiki"><dt><strong>debug_level</strong> (integer)</dt><dd>
This is a per-service setting (that is, it can appear in any of the service sections and sets the debug level for that service.
</dd><dt><strong>reconnection_retries</strong> (integer)</dt><dd>
Number of times services should attempt to reconnect in the event of a Data Provider Backend crash or restart before they give up
</dd></dl>
<h3 id="NSSconfigurationoptions">NSS configuration options</h3>
<dl class="wiki"><dt><strong>enum_cache_timeout</strong> (integer)</dt><dd>
How long should <tt>nss_sss</tt> cache enumerations (requests for info about all users)
</dd><dt><strong>entry_cache_nowait_timeout</strong> (integer)</dt><dd>
How long should nss_sss return cached entries before initiating an out-of-band cache refresh (0 disables this feature)
</dd><dt><strong>entry_negative_timeout</strong> (integer)</dt><dd>
How long should <tt>nss_sss</tt> cache negative cache hits (that is, queries for invalid database entries, like nonexitent ones) before asking the backend again
</dd><dt><strong>filter_users</strong>, <strong>filter_groups</strong> (string)</dt><dd>
Exclude certain users from being fetched from the <tt>sss</tt> NSS database. This is particularly useful for system accounts like root.
</dd><dt><strong>filter_users_in_groups</strong> (bool)</dt><dd>
If you want filtered user still be group members set this option to false.
</dd></dl>
<h2 id="Configuringdomains">Configuring domains</h2>
<p>
A domain is a database containing user information. SSSD can use more domains at the same time, but at least one must be configured or SSSD won't start. Using SSSD domains, it is possible to use several LDAP servers providing several unique namespaces.
</p>
<p>
Add new domains configurations into <tt>[domain/&lt;NAME&gt;]</tt> sections.  Then add
the list of domains (in the order you want them to be queried) in the
'domains' attribute of the domains section. For example, to use only <tt>LOCAL</tt> domain:
</p>
<pre class="wiki">[sssd]
domains = LOCAL
</pre><p>
The following subsections will list examples of configuring different types of domains.
</p>
<h3 id="Domainconfigurationoptions">Domain configuration options</h3>
<p>
These configuration options can be present in a domain configuration section,
that is, in a section called <tt>[domain/&lt;NAME&gt;]</tt>.
</p>
<dl class="wiki"><dt><strong>min_id, max_id</strong> (integer)</dt><dd>
UID limits for the domain. If a domain contains entry that is outside these limits, it is ignored
</dd><dt><strong>enumerate</strong> (bool)</dt><dd>
Determines if a domain can be enumerated. This parameter affects
enumerating of both users and groups.
</dd><dt><strong>timeout</strong> (integer)</dt><dd>
Timeout in seconds for this particular domain. Raising this timeout might prove useful for slower backends like distant LDAP servers. The default is 0 (no timeout).
</dd><dt><strong>cache_credentials</strong> (bool)</dt><dd>
Determines if user credentials are also cached in the local LDB cache
</dd><dt><strong>store_legacy_passwords</strong> (bool)</dt><dd>
Whether to also store passwords in a legacy domain
</dd><dt><strong>id_provider</strong> (string)</dt><dd>
The Data Provider identity backend to use for this domain. Currently supported identity backends are:
<ul><li>proxy: Support a legacy NSS provider (e.g. nss_nis)
</li><li>local: SSSD internal local provider
</li><li>ldap: ldap provider
</li></ul></dd><dt><strong>entry_cache_timeout</strong> (integer)</dt><dd>
How long should the domain's Data Provider cache positive cache hits (that is, queries for valid database entries) before asking the database again
</dd><dt><strong>use_fully_qualified_names</strong> (bool)</dt><dd>
If set to TRUE, all requests to this domain must use fully qualified names. For example, if used in LOCAL domain that contains a "test" user, <tt>getent passwd test</tt> wouldn't find the user while <tt>getent passwd test@LOCAL</tt> would
</dd><dt><strong>auth_provider</strong> (string)</dt><dd>
The authentication provider used for the domain. Supported auth providers are:
<ul><li>ldap for native LDAP authentication. See sssd-ldap(5) for more information on configuring LDAP.
</li><li>krb5 for Kerberos authentication. See sssd-krb5(5) for more information on configuring Kerberos.
</li><li>proxy for relaying authentication to some other PAM target.
</li></ul></dd></dl>
<h3 id="Optionsvalidforproxyidentitydomains">Options valid for proxy identity domains</h3>
<dl class="wiki"><dt><strong>proxy_pam_target</strong> (string)</dt><dd>
The proxy target PAM proxies to. If not set, a default setting of <tt>sssd_pam_proxy_default</tt> is used.
</dd><dt><strong>proxy lib_name</strong> (string)</dt><dd>
The name of NSS library. The NSS functions searched for in the library are in the form of <tt>_nss_$(libName)_$(function)</tt>, for example <tt>_nss_nis_getpwent</tt>.
</dd></dl>
<h3 id="TheLOCALprovider">The LOCAL provider</h3>
<p>
There is a special identity and authentication provider in SSSD named <em>local</em>. Its backend is stored on disk in a format called <em>LDB</em>, an on-disk LDAP-like database.
</p>
<p>
One difference in comparison with the classic files is that groups in the LOCAL backend can be nested. The LOCAL domain is also meant to contain additional user information such as user picture or keyboard settings.
</p>
<p>
Instead of using User Private Groups (where a group is created for every
user), which is usually the default in files-based scheme, the LOCAL
domain uses a concept called Magic Private Groups. By using the Magic
Private Groups option, you are imposing two limitations to the ID space and name space:
</p>
<ol><li>users and groups share a common name space, there can never be a separate group with a same name as a user
</li><li>users and groups share a common ID space, there can never be a group with a same ID as a user
</li></ol><p>
Using Magic Private groups bring the benefit of better Windows
Interoperability (in Windows, the ID and name spaces are unique) and also
avoids creating a group for every user, thus cluttering the group space. Also,
for NSS calls, every user is actually returned a user's private group without
having to explicitly create the group, thus having the same effect as User
Private Groups
</p>
<p>
To manage users in the LOCAL backend, SSSD comes with a set of tools that resemble their
shadow-utils counterparts in names as well as parameters. The tools include <em>sss_useradd</em>, 
<em>sss_groupadd</em> for adding users and groups, <em>sss_userdel</em>, <em>sss_groupdel</em> for removing them and
<em>sss_usermod</em>, <em>sss_groupmod</em> for changing their attributes. You can see details about tools usage by running them with the <tt>--help</tt> argument.
</p>
<h2 id="Domainconfigurationexamples">Domain configuration examples</h2>
<h3 id="Example1:AstandaloneLOCALdomain">Example 1: A standalone LOCAL domain</h3>
<p>
Put the following definition of LOCAL domain into your sssd config file:
</p>
<pre class="wiki"># LOCAL Users domain
[domain/LOCAL]
enumerate = TRUE
min_id = 500
max_id = 999
id_provider = local
auth_provider = local
</pre><p>
Now, add a LOCAL user using sssd management tools:
</p>
<pre class="wiki">sss_useradd testuser1
</pre><p>
A home directory for the new user will be created. Refer to <tt>sss_useradd</tt>
and <tt>sssd.conf</tt> manual pages for more documentation on the subject.
</p>
<p>
If you configured NSS to use the SSS domain, you should be able to request the user information now:
</p>
<pre class="wiki">getent passwd testuser1@LOCAL
</pre><p>
Changing the user's password and logging in should be also possible now:
</p>
<pre class="wiki">passwd testuser1
ssh testuser1@localhost
</pre><h3 id="Example2:AuthenticatingagainstanativeLDAPdomain">Example 2: Authenticating against a native LDAP domain</h3>
<p>
A native LDAP domain requires a
running LDAP server to authenticate against. The client configuration is done
in <tt>/etc/sssd/sssd.conf</tt>.
</p>
<p>
If you want to <strong>authenticate</strong> against an LDAP server <strong>TLS/SSL is required</strong>.
sssd does not support authentication over an unencrypted channel.
If the LDAP server is used only as an identify provider, an encrypted channel
is not needed.
</p>
<p>
The domain configuration in sssd config would look like this:
</p>
<pre class="wiki"># A native LDAP domain
[domain/LDAP]
enumerate = true
cache_credentials = TRUE

id_provider = ldap
auth_provider = ldap
chpass_provider = ldap

ldap_uri = ldap://ldap.mydomain.org
ldap_user_search_base = dc=mydomain,dc=org
tls_reqcert = demand
ldap_tls_cacert = /etc/pki/tls/certs/ca-bundle.crt
</pre><p>
All the parameters for a native LDAP domain are described in the
<tt>sssd-ldap(5)</tt> manual page. 
</p>
<h3 id="Example3:AuthenticatingagainstaKerberosserver">Example 3: Authenticating against a Kerberos server</h3>
<p>
In order to set up Kerberos authentication, you need to know the address of
your KDC and the Kerberos realm. Using these parameters, the configuration is
very simple:
</p>
<pre class="wiki"># A domain with identities provided by LDAP and authentication by Kerberos
[domain/KRBDOMAIN]
enumerate = false
id_provider = ldap
chpass_provider = krb5
ldap_uri = ldap://ldap.mydomain.org
ldap_user_search_base = dc=mydomain,dc=org
tls_reqcert = demand
ldap_tls_cacert = /etc/pki/tls/certs/ca-bundle.crt

auth_provider = krb5
krb5_kdcip = 192.168.1.1
krb5_realm = EXAMPLE.COM
krb5_changepw_principle = kadmin/changepw
krb5_ccachedir = /tmp
krb5_ccname_template = FILE:%d/krb5cc_%U_XXXXXX
krb5_auth_timeout = 15
</pre><p>
All the parameters for a configuring Kerberos authentication are described in
the <tt>sssd-krb5(5)</tt> manual page. 
</p>
</body></html>