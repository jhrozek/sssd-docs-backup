<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1. Introduction &#8212; sssd 1.15.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.15.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="wiki-toc"><ol class="arabic simple">
<li><a class="reference external" href="#a1.Introduction">1. Introduction</a></li>
<li><a class="reference external" href="#a2.ActiveDirectoryUseCase">2. Active Directory Use Case</a></li>
<li><a class="reference external" href="#a3.SystemOverview">3. System Overview</a><ol class="arabic">
<li><a class="reference external" href="#a3.1.ExternalPerspective">3.1. External Perspective</a><ol class="arabic">
<li><a class="reference external" href="#a3.1.1.SSSClientApplications">3.1.1. SSS Client
Applications</a></li>
</ol>
</li>
<li><a class="reference external" href="#a3.2.InternalPerspective">3.2. Internal Perspective</a><ol class="arabic">
<li><a class="reference external" href="#a3.2.1.ControlFlow">3.2.1. Control Flow</a></li>
<li><a class="reference external" href="#a3.2.2.DataFlow">3.2.2. Data Flow</a><ol class="arabic">
<li><ol class="first arabic">
<li><a class="reference external" href="#a3.2.2.1.DataFlowNSSResponder">3.2.2.1. Data Flow (NSS
Responder)</a></li>
<li><a class="reference external" href="#a3.2.2.2.DataFlowPAMResponder">3.2.2.2. Data Flow (PAM
Responder)</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a3.3.SSSDComponents">3.3. SSSD Components</a><ol class="arabic">
<li><a class="reference external" href="#a3.3.1.ProcessesandSharedObjects">3.3.1. Processes and Shared
Objects</a><ol class="arabic">
<li><a class="reference external" href="#a3.3.1.1.SSSClientLibrary">3.3.1.1. SSS Client Library</a></li>
<li><a class="reference external" href="#a3.3.1.2.Monitor">3.3.1.2. Monitor</a></li>
<li><a class="reference external" href="#a3.3.1.3.Responder">3.3.1.3. Responder</a></li>
<li><a class="reference external" href="#a3.3.1.4.BackendakaDataProvider">3.3.1.4. Backend (aka Data
Provider)</a></li>
<li><a class="reference external" href="#a3.3.1.5.ProviderPlugin">3.3.1.5. Provider Plugin</a></li>
<li><a class="reference external" href="#a3.3.1.6.Short-LivedChildProcess">3.3.1.6. Short-Lived Child
Process</a></li>
</ol>
</li>
<li><a class="reference external" href="#a3.3.2.Protocols">3.3.2. Protocols</a></li>
<li><a class="reference external" href="#a3.3.3.UNIXsignals">3.3.3. UNIX signals</a></li>
<li><a class="reference external" href="#a3.3.4.Databases">3.3.4. Databases</a></li>
<li><a class="reference external" href="#a3.3.5.SambaLibraries">3.3.5. Samba Libraries</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a4.AdvancedTopics">4. Advanced Topics</a><ol class="arabic">
<li><a class="reference external" href="#a4.1.OfflineMode">4.1. Offline Mode</a></li>
<li><a class="reference external" href="#a4.2.MultipleDomainsandTrustRelationships">4.2. Multiple Domains and Trust
Relationships</a><ol class="arabic">
<li><a class="reference external" href="#a4.2.1.ADConcepts">4.2.1. AD Concepts</a></li>
<li><a class="reference external" href="#a4.2.2.DomainStanzavs.Domain">4.2.2. Domain Stanza vs.
Domain</a></li>
<li><a class="reference external" href="#a4.2.3.SSSDImplementation">4.2.3. SSSD Implementation</a><ol class="arabic">
<li><a class="reference external" href="#a4.2.3.1.Subdomains">4.2.3.1. Subdomains</a></li>
<li><a class="reference external" href="#a4.2.3.2.GlobalCatalogGC">4.2.3.2. Global Catalog (GC)</a></li>
<li><a class="reference external" href="#a4.2.3.3.PACResponder">4.2.3.3. PAC Responder</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a5.SSSDWrappers">5. SSSD Wrappers</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.SBus">5.1. SBus</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.1.SBusConcepts">5.1.1. SBus Concepts</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.1.1.SBusConnections">5.1.1.1. SBus Connections</a></li>
<li><a class="reference external" href="#a5.1.1.2.CreatingSBusClientsandServers">5.1.1.2. Creating SBus Clients and
Servers</a></li>
<li><a class="reference external" href="#a5.1.1.3.SendingandReceivingSBusMessages">5.1.1.3. Sending and Receiving SBus
Messages</a></li>
<li><a class="reference external" href="#a5.1.1.4.DescribingtheSBUSinterface">5.1.1.4. Describing the SBUS
interface</a></li>
</ol>
</li>
<li><a class="reference external" href="#a5.1.2.Responder-to-BackendAPI">5.1.2. Responder-to-Backend
API</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.2.1.getAccountInfo">5.1.2.1. getAccountInfo</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.2.1.1.RequestNSSPAMResponder-Backend">5.1.2.1.1. Request (NSS/PAM
Responder-&gt;Backend)</a></li>
<li><a class="reference external" href="#a5.1.2.1.2.ResponseBackendNSSPAMResponder">5.1.2.1.2. Response (Backend=&gt;NSS/PAM
Responder)</a></li>
</ol>
</li>
<li><a class="reference external" href="#a5.1.2.2.pamHandler">5.1.2.2. pamHandler</a><ol class="arabic">
<li><a class="reference external" href="#a5.1.2.2.1.RequestPAMResponder-Backend">5.1.2.2.1. Request (PAM Responder -&gt;
Backend)</a></li>
<li><a class="reference external" href="#a5.1.2.2.2.ResponsePAMResponder-Backend">5.1.2.2.2. Response (PAM Responder -&gt;
Backend)</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a5.2.SDAP">5.2. SDAP</a><ol class="arabic">
<li><a class="reference external" href="#a5.2.1.SDAPConcepts">5.2.1. SDAP Concepts</a></li>
<li><a class="reference external" href="#a5.2.2.EstablishinganLDAPConnection">5.2.2. Establishing an LDAP
Connection</a></li>
<li><a class="reference external" href="#a5.2.3.PerformingLDAPOperations">5.2.3. Performing LDAP
Operations</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a6.CommonDataStructures">6. Common Data Structures</a><ol class="arabic">
<li><a class="reference external" href="#a6.1.tevent_context">6.1. tevent_context</a></li>
<li><a class="reference external" href="#a6.2.confdb_ctx">6.2. confdb_ctx</a></li>
<li><a class="reference external" href="#a6.3.sysdb_ctx">6.3. sysdb_ctx</a></li>
<li><a class="reference external" href="#a6.4.main_context">6.4. main_context</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.ComponentDetails">7. Component Details</a><ol class="arabic">
<li><a class="reference external" href="#a7.1.Monitor">7.1. Monitor</a><ol class="arabic">
<li><a class="reference external" href="#a7.1.1.SpawningandRegisteringProcesses">7.1.1. Spawning and Registering
Processes</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.2.SSSClient">7.2. SSS Client</a><ol class="arabic">
<li><a class="reference external" href="#a7.2.1.SSS_CLI">7.2.1. SSS_CLI</a></li>
<li><a class="reference external" href="#a7.2.2.NSSClient">7.2.2. NSS Client</a></li>
<li><a class="reference external" href="#a7.2.3.PAMClient">7.2.3. PAM Client</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.3.Responder">7.3. Responder</a><ol class="arabic">
<li><a class="reference external" href="#a7.3.1.resp_ctx">7.3.1. resp_ctx</a></li>
<li><a class="reference external" href="#a7.3.2.Client-FacingInteractionsGeneric">7.3.2. Client-Facing Interactions
(Generic)</a></li>
<li><a class="reference external" href="#a7.3.3.CommonOptimizationTechniques">7.3.3.Common Optimization
Techniques</a><ol class="arabic">
<li><a class="reference external" href="#a7.3.3.1.DataProviderRequestTable">7.3.3.1. Data Provider Request
Table</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a7.4.NSSResponder">7.4. NSS Responder</a><ol class="arabic">
<li><a class="reference external" href="#a7.4.1.nss_ctx">7.4.1. nss_ctx</a></li>
<li><a class="reference external" href="#a7.4.2.Client-FacingInteractionsNSS">7.4.2. Client-Facing Interactions
(NSS)</a></li>
<li><a class="reference external" href="#a7.4.3.Backend-FacingInteractionsNSS">7.4.3. Backend-Facing Interactions
(NSS)</a></li>
<li><a class="reference external" href="#a7.4.4.CodeFlowNSS">7.4.4. Code Flow (NSS)</a></li>
<li><a class="reference external" href="#a7.4.5.OptimizationTechniquesNSS">7.4.5. Optimization Techniques
(NSS)</a><ol class="arabic">
<li><a class="reference external" href="#a7.4.5.1.NegativeCache">7.4.5.1. Negative Cache</a></li>
<li><a class="reference external" href="#a7.4.5.2.FastCacheakamemcache">7.4.5.2. Fast Cache (aka
memcache)</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a7.5.PAMResponder">7.5. PAM Responder</a><ol class="arabic">
<li><a class="reference external" href="#a7.5.1.pam_ctx">7.5.1. pam_ctx</a></li>
<li><a class="reference external" href="#a7.5.2.Client-FacingInteractionsPAM">7.5.2. Client-Facing Interactions
(PAM)</a></li>
<li><a class="reference external" href="#a7.5.3.Backend-FacingInteractionsPAM">7.5.3. Backend-Facing Interactions
(PAM)</a></li>
<li><a class="reference external" href="#a7.5.4.CodeFlowPAM">7.5.4. Code Flow (PAM)</a></li>
<li><a class="reference external" href="#a7.5.5.OptimizationTechniquesPAM">7.5.5. Optimization Techniques
(PAM)</a><ol class="arabic">
<li><a class="reference external" href="#a7.5.5.1.InitgroupsCache">7.5.5.1. Initgroups Cache</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a7.6.OptimizationsCodeFlow">7.6. Optimizations Code Flow</a></li>
<li><a class="reference external" href="#a7.7.Backend">7.7. Backend</a><ol class="arabic">
<li><a class="reference external" href="#a7.7.1.BackendConcepts">7.7.1. Backend Concepts</a><ol class="arabic">
<li><a class="reference external" href="#a7.7.1.1.ServicesandServers">7.7.1.1. Services and
Servers</a></li>
<li><a class="reference external" href="#a7.7.1.2.NameResolution">7.7.1.2. Name Resolution</a></li>
<li><a class="reference external" href="#a7.7.1.3.ConfigurationLines">7.7.1.3. Configuration
Lines</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.7.2.be_ctx">7.7.2. be_ctx</a></li>
<li><a class="reference external" href="#a7.7.3.Responder-FacingInteractions">7.7.3. Responder-Facing
Interactions</a><ol class="arabic">
<li><a class="reference external" href="#a7.7.3.1.RegisteringResponders">7.7.3.1. Registering
Responders</a></li>
<li><a class="reference external" href="#a7.7.3.2.ReceivingSBusMessages">7.7.3.2. Receiving SBus
Messages</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a7.8.ADProviderPlugin">7.8. AD Provider Plugin</a><ol class="arabic">
<li><a class="reference external" href="#a7.8.1.ADProviderPlugin:id_provider">7.8.1. AD Provider Plugin:
id_provider</a><ol class="arabic">
<li><a class="reference external" href="#a7.8.1.1.ad_id_ctx">7.8.1.1. ad_id_ctx</a></li>
<li><a class="reference external" href="#a7.8.1.2.ad_account_info_handler">7.8.1.2.
ad_account_info_handler</a></li>
<li><a class="reference external" href="#a7.8.1.3.ad_check_online">7.8.1.3. ad_check_online</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.8.2.ADProviderPlugin:auth_providerandchpass_provider">7.8.2. AD Provider Plugin: auth_provider and
chpass_provider</a><ol class="arabic">
<li><a class="reference external" href="#a7.8.2.1.krb5_auth_ctx">7.8.2.1. krb5_auth_ctx</a></li>
<li><a class="reference external" href="#a7.8.2.2.krb5_pam_handler">7.8.2.2. krb5_pam_handler</a><ol class="arabic">
<li><a class="reference external" href="#a7.8.2.2.1.ParentChild">7.8.2.2.1. Parent =&gt; Child</a></li>
<li><a class="reference external" href="#a7.8.2.2.2.ChildParent">7.8.2.2.2. Child=&gt;Parent</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.8.2.3.kdcinfofiles">7.8.2.3. kdcinfo files</a></li>
</ol>
</li>
<li><a class="reference external" href="#a7.8.3.ADProviderPlugin:access_provider">7.8.3. AD Provider Plugin:
access_provider</a><ol class="arabic">
<li><a class="reference external" href="#a7.8.3.1.ad_access_ctx">7.8.3.1. ad_access_ctx</a></li>
<li><a class="reference external" href="#a7.8.3.2.ad_access_handler">7.8.3.2.
ad_access_handler</a></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a8.TeventBasics">8. Tevent Basics</a><ol class="arabic">
<li><a class="reference external" href="#a8.1.Events">8.1. Events</a></li>
<li><a class="reference external" href="#a8.2.Requests">8.2. Requests</a></li>
<li><a class="reference external" href="#a8.3.Subrequests">8.3. Subrequests</a></li>
</ol>
</li>
<li><a class="reference external" href="#a9.Functions">9. Functions</a><ol class="arabic">
<li><a class="reference external" href="#a9.1.SDAPConnectionFunctions">9.1. SDAP Connection Functions</a><ol class="arabic">
<li><a class="reference external" href="#a9.1.1.sdap_id_op_connect_sendrecv">9.1.1.
sdap_id_op_connect_send/recv</a></li>
<li><a class="reference external" href="#a9.1.2.sdap_cli_connect_sendrecv">9.1.2.
sdap_cli_connect_send/recv</a></li>
<li><a class="reference external" href="#a9.1.3.be_resolve_server_sendrecv">9.1.3.
be_resolve_server_send/recv</a></li>
<li><a class="reference external" href="#a9.1.4.fo_resolve_service_sendrecv">9.1.4.
fo_resolve_service_send/recv</a></li>
<li><a class="reference external" href="#a9.1.5.resolv_gethostbyname_sendrecv">9.1.5.
resolv_gethostbyname_send/recv</a></li>
<li><a class="reference external" href="#a9.1.6.resolv_gethostbyname_dns_sendrecv">9.1.6.
resolv_gethostbyname_dns_send/recv</a></li>
<li><a class="reference external" href="#a9.1.7.sdap_connect_sendrecv">9.1.7.
sdap_connect_send/recv</a></li>
<li><a class="reference external" href="#a9.1.8.sss_ldap_init_sendrecv">9.1.8.
sss_ldap_init_send/recv</a></li>
<li><a class="reference external" href="#a9.1.9.sdap_get_rootdse_sendrecv">9.1.9.
sdap_get_rootdse_send/recv</a></li>
<li><a class="reference external" href="#a9.1.10.sdap_kinit_sendrecv">9.1.10.
sdap_kinit_send/recv</a></li>
<li><a class="reference external" href="#a9.1.11.sdap_get_tgt_sendrecv">9.1.11.
sdap_get_tgt_send/recv</a></li>
<li><a class="reference external" href="#a9.1.12.sdap_auth_sendrecv">9.1.12. sdap_auth_send/recv</a></li>
</ol>
</li>
<li><a class="reference external" href="#a9.2.SDAPOperationRequestFunctions">9.2. SDAP Operation Request
Functions</a><ol class="arabic">
<li><a class="reference external" href="#a9.2.1.users_get_sendrecv">9.2.1. users_get_send/recv</a></li>
<li><a class="reference external" href="#a9.2.2.sdap_get_generic_sendrecv">9.2.2.
sdap_get_generic_send/recv</a></li>
<li><a class="reference external" href="#a9.2.3.sdap_get_generic_ext_sendrecv">9.2.3.
sdap_get_generic_ext_send/recv</a></li>
</ol>
</li>
</ol>
</li>
<li><a class="reference external" href="#a10.FilesystemLocations">10. Filesystem Locations</a></li>
<li><a class="reference external" href="#a11.HelpfulLinks">11. Helpful Links</a></li>
</ol>
</div><p><strong>SSSD Internals (October, 2013)
Author: Yassir Elley</strong></p>
<div class="section" id="introduction">
<h1>1. Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this document is to give a basic description of the
internals of the SSSD implementation. The material in this document is
accurate as of SSSD 1.10. It is assumed that the reader is already
familiar with the external usage of SSSD. The intended audience of this
document are new contributors to the SSSD project. This document is not
intended to be comprehensive. For additional details on specific
features, please refer to the various <a class="reference external" href="https://docs.pagure.org/sssd-test2/DesignDocs.html">​Design
Documents</a>. This
document does not discuss the details of building, installing, and
debugging SSSD. More information on these topics can be found in the
<a class="reference external" href="https://docs.pagure.org/sssd-test2/DevRes.html">​Developer Pages</a>,
and the
<a class="reference external" href="https://docs.pagure.org/sssd-test2/Documentation.html">​Documentation</a>.
To be most useful, this document should be updated as appropriate, and
reviewed at regular intervals.</p>
<p>In order to better understand the material and make things more
concrete, this document starts by describing a specific use case (and
configuration) that will be discussed throughout the document. The
document starts with a high level end-to-end overview, and then
deep-dives into detailed descriptions. The document is organized into
the following sections:</p>
<ul class="simple">
<li>Active Directory Use Case: specifies use case used throughout the
document</li>
<li>System Overview: end-to-end SSSD overview, including short
descriptions of components</li>
<li>Advanced Topics: offline operation, multiple domains, trust
relationships</li>
<li>SSSD Wrappers: SBus, SDAP</li>
<li>Common Data Structures: data structures used by each SSSD process</li>
<li>Component Details: gory details of each component</li>
<li>Appendix: tevent, function descriptions, filesystem locations,
helpful links</li>
</ul>
</div>
<div class="section" id="active-directory-use-case">
<h1>2. Active Directory Use Case<a class="headerlink" href="#active-directory-use-case" title="Permalink to this headline">¶</a></h1>
<p>From an SSSD perspective, there are two main Active Directory (AD) use
cases, depending on whether we are directly integrated with AD, or
whether we are indirectly integrated with AD through IPA. For now, this
document only covers the direct AD integration use case.</p>
<p>SSSD consumes DNS, LDAP, and Kerberos services in order to resolve
server names, perform identity lookups, and perform security-related
tasks. In an AD environment, all three services are typically provided
by a single AD server.</p>
<p>In the direct AD integration use case, a host directly joins an AD
domain. At this point, the AD&#8217;s LDAP service creates a computer account
for the host, and the AD&#8217;s Kerberos service creates a service principal
and shared secret credentials for the host. After these host credentials
are installed in the host&#8217;s keytab, the host looks to AD as any other
Windows client, allowing us to leverage existing AD technology. The
preceding steps to join a domain, as well as additional steps that
generate appropriate configuration files, and kick off the master SSSD
process (/usr/sbin/sssd), can all be performed by simply running “realm
join foo.com” as root. For more information on realmd, see <a class="reference external" href="http://www.freedesktop.org/software/realmd/">​Realmd
Page</a>.</p>
<p>For our use case, the SSSD configuration file (<em>/etc/sssd/sssd.conf</em>)
simply specifies an NSS Responder, a PAM Responder, and a single Backend
that uses an AD Provider Plugin to communicate with an AD server. We
will use the following values for our use case. Throughout the document,
we will mark these values (and derived values) in red, to indicate that
other values could have been used.</p>
<ul class="simple">
<li>the AD domain is named “foo.com”</li>
<li>the AD server is named “adserver.foo.com”</li>
<li>the AD username and password we will use in our examples is
&#8220;<a class="reference external" href="mailto:aduser&#37;&#52;&#48;foo&#46;com">aduser<span>&#64;</span>foo<span>&#46;</span>com</a>&#8221; and ”adpass”</li>
</ul>
<p>Using those values, our use case can be represented by the following
SSSD configuration file:</p>
<p>Note that one of SSSD&#8217;s design goals is to allow its configuration file
(<em>sssd.conf</em>) to be very short, where configuration values that are
needed (but not provided) are populated by either using default values,
or by using DNS to auto-discover the values.</p>
<ul class="simple">
<li>if <em>ad_domain</em> is not specified, it defaults to the value of the
domain stanza&#8217;s name (e.g. <em>foo.com</em>)</li>
<li>if <em>ad_server</em> is not specified, DNS service discovery is used to
find an appropriate server</li>
<li>if <em>auth_provider</em>, <em>chpass_provider</em>, or <em>access_provider</em> are
not specified, they default to the value of the <em>id_provider</em> (e.g.
<em>ad</em>).</li>
</ul>
<p>For example, if DNS service discovery were available, the domain
configuration above could have equivalently been written as:</p>
</div>
<div class="section" id="system-overview">
<h1>3. System Overview<a class="headerlink" href="#system-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="external-perspective">
<h2>3.1. External Perspective<a class="headerlink" href="#external-perspective" title="Permalink to this headline">¶</a></h2>
<p>Fundamentally, SSSD provides identity (NSS) and authentication (PAM)
services to its SSS Client Applications using information stored in
remote servers (e.g. AD Server, IPA Server). SSSD serves as a central
point of enforcement and management for the local machine on which it is
running. SSSD components are able to share consistent state because
multiple technologies are configured in a single configuration file.
SSSD also improves performance by maintaining a local SSSD Cache, and by
the fact that SSSD only needs to maintain a single connection to each of
the remote servers (while servicing multiple SSS Client Applications).
SSSD can optionally use the local SSSD Cache to continue to provide
identity and authentication services to users when they go offline.</p>
<p><em>This diagram shows two different SSS Client Applications making NSS/PAM
calls to SSSD. In order to fulfill the request, SSSD either uses a
cached result (by consulting the Cache), or an up-to-date result (by
contacting the AD Server using LDAP/KRB). As such, SSSD is acting in a
server role for the SSS Client Applications, and in a client role with
respect to AD.</em></p>
<div class="section" id="sss-client-applications">
<h3>3.1.1. SSS Client Applications<a class="headerlink" href="#sss-client-applications" title="Permalink to this headline">¶</a></h3>
<p>Through the beauty of the pluggable NSS and PAM frameworks, an SSS
Client Application (e.g. <em>ls</em>) is unaware that it is communicating with
an SSS Client Library. An SSS Client Application simply calls a standard
NSS or PAM function, which is mapped by the NSS/PAM runtime to a
module-specific function name, and which is then delivered to an SSS
Client Library (assuming that SSSD configuration has taken place). Note
that we can either refer to a Client Library generically (e.g. “SSS
Client Library”), or we can refer to it specifically (e.g. “NSS Client
Library”).</p>
<p>Examples of NSS-using SSS Client Applications include <em>ls</em>, <em>id</em>, and
<em>getent</em>. These commands call standard NSS functions, which include
settors/gettors for several name databases (e.g. passwd, group, service,
netgroup, etc). An entry in a name database can be retrieved by using an
appropriate key (e.g. name, id, port, etc). Alternatively, the entries
in a name database can be enumerated, although this can be quite
inefficient for large databases. The full API supported by the NSS
Client Library is defined in sss_nss.exports.</p>
<p>Examples of PAM-using SSS Client Applications include <em>login</em>, <em>su</em>, and
<em>ssh</em>. These commands call standard PAM functions. However, unlike NSS
functions, PAM functions are called within the context of a PAM
transaction, which maintains the state for the entire transaction
(including any input values set by the caller, such as username, etc). A
typical PAM transaction looks like:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">pam_start</span><span class="p">(</span><span class="s2">&quot;login&quot;</span><span class="p">,</span> <span class="s2">&quot;aduser&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pam_conv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pamh</span><span class="p">);</span> <span class="o">//</span> <span class="n">initiate</span> <span class="n">pam</span> <span class="n">transaction</span>
<span class="n">pam_authenticate</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                      <span class="o">//</span> <span class="n">verify</span> <span class="n">identity</span> <span class="n">of</span> <span class="n">user</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">pam_acct_mgmt</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                   <span class="o">//</span> <span class="n">determine</span> <span class="k">if</span> <span class="n">user</span> <span class="n">account</span> <span class="ow">is</span> <span class="n">valid</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">PAM_NEW_AUTHTOK_REQD</span><span class="p">)</span>                <span class="o">//</span> <span class="k">if</span> <span class="n">user</span> <span class="n">password</span> <span class="n">has</span> <span class="n">expired</span>
   <span class="n">pam_chauthtok</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                      <span class="o">//</span> <span class="n">change</span> <span class="n">user</span> <span class="n">password</span>
<span class="n">pam_setcred</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="n">PAM_ESTABLISH_CRED</span><span class="p">);</span>          <span class="o">//</span> <span class="nb">set</span> <span class="n">user</span><span class="s1">&#39;s credentials</span>
<span class="n">pam_open_session</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                       <span class="o">//</span> <span class="n">initiate</span> <span class="n">session</span> <span class="n">management</span>
<span class="o">...</span>                                             <span class="o">//</span> <span class="n">non</span><span class="o">-</span><span class="n">pam</span> <span class="n">code</span>
<span class="n">pam_close_session</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                      <span class="o">//</span> <span class="n">terminate</span> <span class="n">session</span> <span class="n">management</span>
<span class="n">pam_end</span><span class="p">(</span><span class="n">pamh</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>                             <span class="o">//</span> <span class="n">terminate</span> <span class="n">pam</span> <span class="n">transaction</span>
</pre></div>
</div>
</div><p>The PAM conversation function (pam_conv), set by the caller, allows the
implementation to communicate directly with the application. For
example, the implementation of PAM functions that use passwords (i.e.
pam_authenticate, pam_chauthtok) would use the registered PAM
conversation function to prompt the user for a password.</p>
<p>The full API supported by the PAM Client Library is defined in
pam_sss.c. Note that the PAM Client Library does not handle the
pam_start() and pam_end() calls that surround a pam transaction, but
it handles all of the PAM functions in between.</p>
</div>
</div>
<div class="section" id="internal-perspective">
<h2>3.2. Internal Perspective<a class="headerlink" href="#internal-perspective" title="Permalink to this headline">¶</a></h2>
<p>This section gives an internal system overview of SSSD&#8217;s control flow
(i.e. messages used for control, configuration, initialization) and
SSSD&#8217;s data flow (i.e. messages related to data traffic resulting from
client requests).</p>
<div class="section" id="control-flow">
<h3>3.2.1. Control Flow<a class="headerlink" href="#control-flow" title="Permalink to this headline">¶</a></h3>
<p><em>This diagram shows SSSD&#8217;s start-up procedure. The diagram only shows a
single NSS Responder for clarity, but keep in mind that our use case
requires two Responders (NSS and PAM).</em></p>
<ol class="arabic simple">
<li>Monitor process initializes itself, which includes parsing
configuration file (sssd.conf) and loading it into confdb. After it
is loaded, the Monitor retrieves and applies Monitor-specific config
from the confdb.</li>
<li>Monitor spawns (i.e. fork/exec) a Backend process for the single
domain specified in config.</li>
<li>Backend process initializes itself, which includes sending <em>Register</em>
message to Monitor, as well as dynamically loading AD Provider
Plugin.</li>
<li>Backend contacts confdb in order to retrieve and apply
Backend-specific config.</li>
<li>Monitor spawns an NSS Responder process (shown), as well as a PAM
Responder (not shown).</li>
<li>Responder process initializes itself, which includes sending
<em>Register</em> message to Monitor, and sending separate <em>Register</em>
message to Backend.</li>
<li>Responder contacts confdb in order to retrieve and apply
Responder-specific config.</li>
<li>Monitor periodically sends <em>Ping</em> messages to registered processes,
and restarts them as needed.</li>
</ol>
</div>
<div class="section" id="data-flow">
<h3>3.2.2. Data Flow<a class="headerlink" href="#data-flow" title="Permalink to this headline">¶</a></h3>
<p>In this section, we will separately examine the internal data flow for
the NSS Responder and the PAM Responder, since the data flow for the PAM
Responder is more complicated. Note that all of the components in the
Data Flow diagrams are under the SSSD team&#8217;s control, except for the SSS
Client Application and remote AD Server. Also note that this section
assumes that we are in “online mode”, meaning that SSSD is able to
communicate with the AD Server. In the “offline mode” case, we are only
able to consult the Cache (since the AD Server is not reachable).</p>
<div class="section" id="data-flow-nss-responder">
<h4>3.2.2.1. Data Flow (NSS Responder)<a class="headerlink" href="#data-flow-nss-responder" title="Permalink to this headline">¶</a></h4>
<p><em>This diagram shows the data flow generated by an SSS Client Application
making an NSS request to SSSD.</em></p>
<ol class="arabic simple">
<li>SSS Client Application&#8217;s request is handled by our dynamically loaded
NSS Client Library, which consults the fast cache (aka memcache). If
valid cache entry exists (unexpired), NSS Client Library immediately
returns cached result to SSS Client Application.</li>
<li>If no valid cache entry exists in fast cache, NSS Client Library
sends client&#8217;s NSS request to matching NSS Responder.</li>
<li>NSS Responder consults Cache. If valid cache entry exists
(unexpired), NSS Responder immediately returns cached result to SSS
Client Application (this step not shown above)</li>
<li>If no valid cache entry exists, NSS Responder sends <em>getAccountInfo</em>
request message to Backend, asking Backend to update Cache with data
corresponding to client&#8217;s NSS request.</li>
<li>Backend uses AD Provider Plugin to make LDAP call to remote AD Server
and to retrieve response from AD Server.</li>
<li>Backend updates Cache, and also sends <em>getAccountInfo</em> response
message (containing status) to NSS Responder; this also serves as
indication that Cache has been updated.</li>
<li>NSS Responder reads updated result from Cache.</li>
<li>NSS Responder returns updated result to NSS Client Library, which
passes it to SSS Client Application.</li>
</ol>
</div>
<div class="section" id="data-flow-pam-responder">
<h4>3.2.2.2. Data Flow (PAM Responder)<a class="headerlink" href="#data-flow-pam-responder" title="Permalink to this headline">¶</a></h4>
<p><em>This diagram shows the data flow generated by an SSS Client Application
making a PAM request to SSSD</em></p>
<ol class="arabic simple">
<li>SSS Client Application&#8217;s request is handled by our dynamically loaded
PAM Client Library, which sends request to matching PAM Responder.</li>
<li>Like the NSS Responder, the PAM Responder sends <em>getAccountInfo</em>
request message to Backend, but only to ask it to update Cache with
client&#8217;s group memberships (i.e. initgroups)</li>
<li>Backend uses AD Provider Plugin to make LDAP call to remote AD Server
and to retrieve response.</li>
<li>Backend updates Cache, and also sends <em>getAccountInfo</em> response
message (containing status) to PAM Responder; this also serves as
indication that Cache has been updated.</li>
<li>PAM Responder reads updated initgroups information from Cache.</li>
<li>PAM Responder sends <em>pamHandler</em> request message to Backend</li>
<li>Backend uses AD Provider Plugin to retrieve response from Child
Process, which makes the actual KRB calls; note that the Child
Process (not shown) will be discussed later in the document</li>
<li>Backend sends <em>pamHandler</em> response message (containing status) to
PAM Responder</li>
<li>PAM Responder returns updated result to PAM Client Library, which
passes it to SSS Client Application.</li>
</ol>
<p>Clearly, the PAM Responder&#8217;s data flow is different from the NSS
Responder&#8217;s data flow. The primary difference is that the result of a
<em>pamHandler</em> request is not stored in the Cache. The <em>pamHandler</em>
response message contains status information, most of which is passed
back to the PAM Client Library. Another difference is that the NSS
Responder sends the Backend only a single request message, corresponding
to the SSS Client&#8217;s request. In contrast, the PAM Responder sends two
request messages: the first one to find the client&#8217;s group memberships,
and the second one corresponding to the SSS Client&#8217;s request. There are
a couple of reasons for this. First, the PAM Responder wants to ensure
that the identity returned by LDAP is the same identity that should be
used for authentication. Second, in the case where multiple domains are
configured, the given identity is tried against each domain, in the same
order as it appears in the <em>domains</em> line in sssd.conf. As soon as the
requested identity has group memberships in a particular domain, that
domain is used as <strong>the</strong> authoritative domain for that client request.
Note that complications arising from the use of subdomains will be
discussed later. Additional difference is that while the PAM responder
always downloads the group memberships from the server (if reachable)
even if the cache is up to date. This is to ensure correct authorization
data on login, because group memberships are set on login on a Linux
system.</p>
</div>
</div>
</div>
<div class="section" id="sssd-components">
<h2>3.3. SSSD Components<a class="headerlink" href="#sssd-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="processes-and-shared-objects">
<h3>3.3.1. Processes and Shared Objects<a class="headerlink" href="#processes-and-shared-objects" title="Permalink to this headline">¶</a></h3>
<p>Despite the fact that its name suggests there is only a <strong>single</strong>
daemon, the term “SSSD” usually refers to a <strong>set</strong> of daemons and
shared objects that work together to provide identity and authentication
services to SSS Client Applications. The following table summarizes the
SSSD-related processes and shared objects needed for our AD use case
(along with their configuration files). Note that default values are
used for configuration fields that are not specified. A brief
description of these components follows.</p>
<table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>Component Name</em></td>
<td><em>Component Configuration</em></td>
</tr>
<tr class="row-even"><td>Shared Object: NSS Client Library</td>
<td>/etc/nsswitch.conf; using nss_sss.so module</td>
</tr>
<tr class="row-odd"><td>Shared Object: PAM Client Library</td>
<td>/etc/pam.d/system-auth; using pam_sss.so module</td>
</tr>
<tr class="row-even"><td>Process: Monitor</td>
<td>/etc/sssd/sssd.conf: [sssd] stanza</td>
</tr>
<tr class="row-odd"><td>Process: NSS Responder</td>
<td>/etc/sssd/sssd.conf: [nss] stanza</td>
</tr>
<tr class="row-even"><td>Process: PAM Responder</td>
<td>/etc/sssd/sssd.conf: [pam] stanza</td>
</tr>
<tr class="row-odd"><td>Process: Backend</td>
<td>/etc/sssd/sssd.conf: [domain/foo.com] stanza</td>
</tr>
<tr class="row-even"><td>Shared Object: AD Provider Plugin</td>
<td>/etc/sssd/sssd.conf: [domain/foo.com] provider lines</td>
</tr>
<tr class="row-odd"><td>Process: Short-Lived Child Process</td>
<td>no config; used to perform blocking operations</td>
</tr>
</tbody>
</table>
<p>An SSS Client Library is a shared object that is dynamically loaded by
an SSS Client Application in order to communicate with SSSD. While we
have so far been careful to distinguish between the SSS Client
Application and SSS Client Library, from now on, we shall drop the
“Library” and refer to the SSS Client Library as simply SSS Client (or
NSS Client or PAM Client). Indeed, when the code refers to “SSS Client”
(or to identifiers prefixed with “sss_cli”), it is referring an SSS
Client Library.</p>
<p>The monitor is <strong>the</strong> master SSSD process that spawns other SSSD
processes and ensures they stay alive. It also sends SBus messages to
other SSSD processes if it detects networking status changes. For
example, if SSSD is in offline mode, and the Monitor detects that a
cable has been plugged in, the Monitor sends SBus messages to the other
SSSD processes to go online immediately.</p>
<p>A Responder is a process that receives requests from an SSS Client
Library, and that returns responses to it. In order to ensure that the
Responder and Cache have a consistent view of user data, most Responders
(e.g. NSS Responder) fulfill the client’s request by retrieving data
from the Cache (although the Cache may need to be updated first). The
PAM Responder is an exception, in that the Backend returns
authentication results directly to the PAM Responder (as opposed to
storing them in the Cache). Having said that, the PAM Responder <strong>does</strong>
store authentication-related data in the Cache, but this is only used
for offline authentication, which will be discussed later in the
document. Note that each Responder (NSS, PAM) runs in its own process.</p>
<p>A Backend is a process that represents a domain stanza (e.g.
[domain/foo.com]) and that uses Provider Plugins to talk to remote
servers (e.g. AD) in order to perform the necessary identity lookups
and/or pam-related tasks. The term “Backend” is synonymous with the term
“Data Provider”. In fact, while some parts of the code use the term
“Backend” (or use “<em>be_</em>” prefixes), other parts of the code use
the term “Data Provider” (or use “<em>dp_</em>” prefixes) to refer to a
Backend. However, to prevent confusion between a Data Provider and
Provider Plugin, this document uses the term “Backend” for this
component.</p>
<p>A Backend receives a request message from a Responder, processes the
request message by communicating with a remote server, updates the
Cache, and sends a response message to the Responder, which also serves
as an indication that the Cache has been updated. Each domain stanza has
its own Backend process, which dynamically loads one or more Provider
Plugins (aka “Backend Modules”), which do the heavy lifting of
communicating with the remote server. A Backend&#8217;s configuration
specifies the individual Provider Plugins to be used for each provider
type, as information needed to access the remote server. Think of a
Backend as a container, consisting of several individual provider types,
each of which could potentially be using a different Provider Plugin.</p>
<p>A Provider Plugin is a shared object that is dynamically loaded by a
Backend to communicate with remote servers. The role of a provider
plugin is to provide plugin-specific implementations of generic
functions used to handle requests and to determine whether or not we are
in online mode.</p>
<p>Each Provider Plugin has a name (e.g. AD), along with a set of provider
types that it supports (id_provider, auth_provider, access_provider,
chpass_provider, etc). Each individual provider type could use a
different Provider Plugin (e.g. id_provider=ldap, auth_provider=krb5)
or all of the individual provider types could use the same Provider
Plugin (e.g. id_provider=ad, auth_provider=ad). You can tell which
Provider Plugins are supported in the code by looking at the names of
the subdirectories of the providers directory (i.e. ad, ipa, krb5, ldap,
proxy, simple). Each provider plugin will require certain additional
configuration information to be specified in sssd.conf (e.g.
“<em>id_provider=ad</em>” will require the <em>ad_domain</em> field, which will
be used to locate the actual AD server).</p>
<p>SSSD tries very hard not to make blocking function calls. The main
exception is that we make blocking calls to access our various
databases. However, those calls are expected to return very quickly, so
they do not negatively affect our performance much. However, there are
times when we have no choice but to call external libraries or commands
that only support blocking semantics. For example, all calls to the MIT
Kerberos library are blocking function calls. Similarly, in order to
perform dynamic DNS (DDNS) updates, we call the <em>nsupdate</em> command,
which will not necessarily return very quickly. In such scenarios,
rather than having an SSSD process (which is running a tevent main loop)
perform a blocking operation, the SSSD process spawns a short-lived
Child Process, which performs the blocking operation on the parent&#8217;s
behalf. As soon as the child process is spawned, the parent process
asynchronously sends it a request (using UNIX pipes), and then returns
control to its tevent main loop, thereby maintaining aysnchronous
semantics. The child process then performs the blocking operation.
Later, when the operation is finally complete, the child process sends
the parent process the result (which it asynchronously reads), and then
exits. It may seem inefficient to spawn a new child process each time a
blocking operation needs to performed. However, these blocking
operations are called relatively infrequently. If this were to present a
problem in the future, a dedicated pool of child processes could be
used. Instances in which Child Processes are currently used in the code
include:</p>
<ul class="simple">
<li>during gssapi-bind authentication for ldap searches (kerberos
function calls)</li>
<li>during kinit of behalf of user (kerberos function calls)</li>
<li>during the update of client records using dynamic dns (<em>nsupdate</em>)</li>
</ul>
</div>
<div class="section" id="protocols">
<h3>3.3.2. Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h3>
<p><em>This diagram shows the protocols used between various SSSD components.</em></p>
<ul class="simple">
<li><strong>DBus</strong>: used for local IPC between Responders, Backends, and
Monitor. Note that SSSD uses SBus (“SSSD DBus”) as a wrapper around
the DBus library (libdbus), in order to integrate the DBus API with
the tevent main loop.</li>
<li><strong>LDAP</strong>: used by a Provider Plugin to send LDAP operation requests
to a remote LDAP server. Note that SSSD uses SDAP (“SSSD LDAP”) as a
wrapper around the OpenLDAP library (libldap), in order to integrate
the OpenLDAP API with the tevent main loop.</li>
<li><strong>Kerberos</strong>: used by a Provider Plugin or short-lived Child Process
to perform Kerberos operations. Since the MIT Kerberos library
(libkrb5) does not support non-blocking calls, any Kerberos function
call that requires communicating with a remote Kerberos server (KDC)
will result in the spawning of a short-lived Child Process. A
Kerberos function call that operates locally (reading a keytab,
writing a ccache, parsing names, etc) can be handled directly in the
Provider Plugin, and does not require a short-lived Child Process to
be spawned.</li>
<li><strong>DNS</strong>: used by a Provider Plugin to interact with a remote DNS
server in order to resolve server names (using standard A/AAAA
address records) or to resolve service names (using domain-specific
SRV records). While SSSD doesn&#8217;t use a wrapper around the C-Ares DNS
library (libcares), it does perform the necessary tasks to integrate
the library with the tevent main loop.</li>
<li><strong>SSS_CLI</strong>: an SSSD-specific custom protocol that is used by an SSS
Client to communicate with its matching Responder. SSS_CLI is a
request/response protocol that communicates over raw Unix Domain
Sockets, using its own TLV-encoding.</li>
</ul>
</div>
<div class="section" id="unix-signals">
<h3>3.3.3. UNIX signals<a class="headerlink" href="#unix-signals" title="Permalink to this headline">¶</a></h3>
<p>Apart from the internal SBUS communication, SSSD also uses UNIX signals
for certain functionality - either for communication with external
utilities or for cases where the SBUS communication might not work, such
as an unresponsive worker process. Below is an overview of the supported
signals and their use. The singal handlers are typically integrated with
the tevent event loop using its <code class="docutils literal"><span class="pre">tevent_add_signal</span></code> call.</p>
<dl class="docutils">
<dt>SIGTERM</dt>
<dd>If a responder or a provider process fails to send a <code class="docutils literal"><span class="pre">pong</span></code>
message to the monitor process after receiving the <code class="docutils literal"><span class="pre">ping</span></code> message,
the monitor terminates the unresponsive process with a SIGTERM. Also
used to terminate helper processes (such as the krb5_child process)
in case of a timeout.</dd>
<dt>SIGKILL</dt>
<dd>In cases where an unresponsive worker process does not terminate
after receiving SIGTERM, the monitor forcibly kills it with SIGKILL</dd>
<dt>SIGUSR1</dt>
<dd>Can be handled a sssd_be process individually or the monitor
process (in that case, the monitor re-sends the signal to all
sssd_be processes it handles). Upon receiving this signal, the
sssd_be process transitions into the &#8216;offline&#8217; state. This signal
is mostly useful for testing.</dd>
<dt>SIGUSR2</dt>
<dd>Similar to the SIGUSR1 signal, the SIGUSR2 would cause an sssd_be
process to reset the offline status and retry the next request it
receives against a remote server.</dd>
<dt>SIGHUP</dt>
<dd>Can be delivered to the sssd process. After receiving SIGHUP, the
monitor rotates its logfile and sends a <code class="docutils literal"><span class="pre">reset</span></code> method to the
managed processes. The managed processes also rotate logfiles. In
addition, the sssd_be processes re-read resolv.conf and the
sssd_nss process clears the fast in-memory cache.</dd>
</dl>
</div>
<div class="section" id="databases">
<h3>3.3.4. Databases<a class="headerlink" href="#databases" title="Permalink to this headline">¶</a></h3>
<p><em>This diagram shows which SSSD components access which SSSD databases.</em></p>
<ul class="simple">
<li><strong>Configuration DB (confdb)</strong>: a single memory-mapped LDB database in
which the parsed contents of the SSSD configuration file are stored
by the Monitor process, upon initialization. Any SSSD process can
read from the Configuration DB, while only a few (e.g. Monitor) can
write to it. The configuration DB is typically found at
/var/lib/sss/db/config.ldb</li>
<li><strong>System DB (sysdb)</strong>: a per-domain memory-mapped LDB database, which
caches responses of recently sent requests. The sysdb is written to
by the Backend, and read by the Responders. Even though this is a
per-domain database, it is sometimes referred to generally as the
System Cache. Since our use case only has a single domain, the System
Cache and System DB refer precisely to the same LDB database. The
System DB for a domain named &#8220;foo.com” is typically found at
/var/lib/sss/db/cache_foo.com.ldb</li>
<li><strong>Fast Cache (memcache)</strong>: a single set of memory-mapped cache files,
from which an SSS Client can retrieve identity (NSS) information
without having to contact the NSS Responder. The NSS Responder
populates the memcache files, while the SSS Client reads the memcache
files. Currently, only two maps that are supported: the password map
(/var/lib/sss/mc/passwd) and the group map (/var/lib/sss/mc/group).
If the memcache does not have the necessary information, then the SSS
Client falls back to using the NSS Responder. Note that this
mechanism is not used by the PAM Responder. Note also that this Fast
Cache (memcache) is not considered part of the System Cache (sysdb).</li>
</ul>
</div>
<div class="section" id="samba-libraries">
<h3>3.3.5. Samba Libraries<a class="headerlink" href="#samba-libraries" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><strong>LDB</strong>: database library that uses an ldap-like data model (although
schema-less). While using a TDB backend to provide the actual
storage, LDB manipulates the TDB data into an LDAP-like structure;
TDB is a very simple in-memory key/value database that stores data in
binary format and supports transactions. For more information, refer
to <a class="reference external" href="http://wiki.samba.org/index.php/Samba4/LDBIntro">​LDB
Tutorial</a>.</li>
<li><strong>Talloc</strong>: a hierarchical memory allocator in which each dynamically
allocated memory chunk can have a parent, as well as children. When a
data structure is freed (using talloc_free), it frees not only
itself but all of its children as well. Additionally, talloc
maintains a reference to the allocated data structure&#8217;s type,
providing type checking when casting from a void pointer to a typed
pointer (assuming you perform the cast by calling talloc_get_type).
For more information, refer to <a class="reference external" href="http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html">​Talloc
Tutorial</a></li>
<li><strong>Tevent</strong>: a talloc-based event system that provides a main loop
that supports the asynchronous processing of several event types
(e.g. timers, file descriptors). Each SSSD process (Monitor,
Responder, Backend) is single-threaded, and each process runs its own
tevent main loop, which dispatches events using registered event
handlers (and contexts). Tevent also facilitates the writing of
asynchronous code by introducing the concept of tevent requests,
where one request can call sub-requests, allowing for better
modularization of the codebase. Using tevent on top of talloc gives
us the ability to trivially cancel tevent requests (by simply freeing
the tevent_req pointer), which will also automatically free
resources of all descendant subrequests (e.g. children,
grandchildren, etc). It is common to cancel a tevent request when an
associated timer event expires, since this prevents us from waiting
indefinitely for results. For more information, refer to <a class="reference external" href="http://tevent.samba.org/tevent_tutorial.html">​Tevent
Tutorial</a>.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="advanced-topics">
<h1>4. Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h1>
<div class="section" id="offline-mode">
<h2>4.1. Offline Mode<a class="headerlink" href="#offline-mode" title="Permalink to this headline">¶</a></h2>
<p>So far, we have been assuming that SSSD is in online mode, but SSSD can
transition from online mode to offline mode and back again, depending on
whether its AD server is reachable on the network. When reachable, SSSD
is in online mode and remains in online mode, unless the AD server
becomes unreachable (e.g. perhaps because of a temporary failure).
Similarly, once in offline mode, SSSD remains in offline mode, unless
the AD server becomes reachable (more on that in a bit).</p>
<p>When SSSD is in online mode, it receives various requests from the SSS
Client, which it initially fulfills by contacting the AD server and
storing the identity lookup result or authentication artifacts in the
Cache. Authentication artifacts refer to data needed to reproduce an
authentication result when SSSD is offline. Specifically, when a
presented username and password are able to authenticate successfully
(i.e. when we receive PAM_SUCCESS from an authenticate operation), we
perform a one-way hash on that password and store it in the user&#8217;s Cache
entry. If we go offline, and we need to re-authenticate the user, the
user again enters the username and password, and we are able to perform
the offline authentication, by hashing the presented password and
comparing it to the authentication artifact in the user&#8217;s entry. Of
course, while SSSD is in online mode, we never use these authentication
artifacts.</p>
<p>Once a TGT has been acquired (which requires a valid password), SSSD can
automatically renew the TGT at a configurable interval. If the AD server
becomes unreachable, then SSSD enters offline mode, at which time any
registered offline callback functions are called. For example, one
offline callback function disables the regularly scheduled renewal of
TGTs (since contacting the AD server is not possible). While offline,
SSSD can only fulfill requests directly from the Cache. However, if a
cache entry expires while offline, SSSD continues to honor the cache
entry, until SSSD returns to online mode. If the AD server becomes
reachable again, SSSD enters online mode, at which time any registered
online callback functions are called. For example, one online callback
uses the user&#8217;s plaintext password stored in the kernel&#8217;s keyring (only
if explicitly enabled by config) to automatically request a TGT upon
entering online mode, without prompting the user for the password.</p>
<p>Since multiple AD servers can be configured (i.e. for failover
purposes), SSSD only goes offline if <strong>none</strong> of the configured AD
servers are reachable. The circumstances under which a server is
considered unreachable include the following:</p>
<ul class="simple">
<li>SSSD is unable to resolve server&#8217;s name</li>
<li>SSSD is able to resolve server&#8217;s name, but is unable to connect to
service on server</li>
<li>SSSD is not connected to the network</li>
</ul>
<p>Once offline, SSSD attempts to transition back to online mode by
attempting to reconnect every 30 seconds. In addition to this polling,
there are two notification mechanisms used (by the Monitor) that may
result in an earlier transition to online mode. The Monitor uses netlink
to receive notifications from the kernel when networking state has
changed (e.g. cable is plugged in, routing table is changed, etc). If
notified of a change, the Monitor sends SBus messages to all Backends to
<em>resetOffline</em> (i.e. before the hard-coded 30 seconds), which means that
they should attempt to retry the next network operation. If successful,
SSSD transitions to online mode; it not successful (e.g. if the remote
server is down), SSSD remains offline. Separately, the Monitor uses
inotify to receive notifications when the DNS configuration in
/etc/resolv.conf has changed. If notified of a change, the Monitor sends
SBus messages to all Responders and Backends to immediately reload
/etc/resolv.conf, which may result in a transition to online mode (i.e.
if failed name resolution had earlier caused the transition to offline
mode). Finally, during initialization, the Monitor registers
tevent_signal events that are triggered by receiving the SIGUSR1 (go
offline) and SIGUSR2 (go online) signals. If the Monitor receives either
of those signals, it sends SBus messages to all Backends to go offline
or to go online (and reload /etc/resolv.conf), at which time the
appropriate offline or online callbacks are called, respectively. For
the remainder of the document, unless otherwise stated, we assume that
SSSD is in online mode.</p>
</div>
<div class="section" id="multiple-domains-and-trust-relationships">
<h2>4.2. Multiple Domains and Trust Relationships<a class="headerlink" href="#multiple-domains-and-trust-relationships" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ad-concepts">
<h3>4.2.1. AD Concepts<a class="headerlink" href="#ad-concepts" title="Permalink to this headline">¶</a></h3>
<p>Things are relatively straightforward if we restrict ourselves to a
single domain. In an AD context, this restriction means that only
objects (e.g. users, computers, etc) managed by the domain controller
(DC) for that single domain are able to interact with each other. For
example, a user in Domain A (i.e. User A) can authenticate with DC A,
and attempt to access Service A, after receiving the appropriate
Kerberos service ticket for that service from DC A. Service A&#8217;s ACL is
then evaluated to see if User A has permission to use Service A. If not,
a query can be made to DC A to obtain User A&#8217;s group memberships, after
which the ACL could be re-evaluated and a final authorization decision
could be made. However, this only works because DC A has all the
necessary information (keys, group memberships, etc) for each of the
managed objects in its domain (i.e. users, groups, computers, resources,
etc).</p>
<p>An attempt by User A to access Service B (which is not managed by DC A)
would be unsuccessful. DC A would have no way of generating a Kerberos
service ticket for Service B, since there is no shared secret for
Service B in its security principal database. For the same reason,
Service B would be unable to obtain User A&#8217;s group memberships from DC A
(since AD typically requires authenticated LDAP searches). And why would
Service B even trust the information it received from DC A?</p>
<p>All of these issues are resolved by the introduction of Kerberos trust
relationships, which are used extensively in an AD environment. In fact,
AD is usually deployed in a multi-domain forest topology, with two-way
transitive trust relationships automatically created between each domain
(by default). Creating a trust relationship between two domains involves
setting up a shared secret between the two domains, so that they can
issue cross-domain referrals for each other&#8217;s users. With regard to the
group membership issue, there are two components to the solution: a
Global Catalog (GC) server, and Privilege Attribute Certificate (PAC)
information. With regard to the GC Server, while each domain maintains
all attributes for each of the managed objects in its domain, the GC
server maintains a partial set of attributes for each object in the
forest (i.e. in any domain in the forest). Also, while a domain&#8217;s DC
stores and manages its own domain groups (which can only consist of
users from the same domain), the GC stores and manages universal groups
(which can contain accounts from any domain in the forest). Finally, it
would be nice if we just collected the user&#8217;s group memberships when the
user was authenticated, and then passed that information along in the
Kerberos service tickets. In fact, this is exactly what is done. As part
of user authentication, AD collects the user&#8217;s group memberships (and
other security-related information) into a PAC, which it then places in
the TGT&#8217;s AuthorizationData field. Later, when User A requests a service
ticket for Service B, AD copies the PAC from the TGT to the service
ticket. Service B can then extract the PAC when it receives the Service
Ticket, making it easier and faster to come to an authorization
decision.</p>
</div>
<div class="section" id="domain-stanza-vs-domain">
<h3>4.2.2. Domain Stanza vs. Domain<a class="headerlink" href="#domain-stanza-vs-domain" title="Permalink to this headline">¶</a></h3>
<p>Before moving on, we need to understand the difference between a domain
stanza and an ad_domain. A domain stanza identifies a stanza in the
sssd.conf file (e.g. [domain/foo.com]), which specifies the ad_domain
and other parameters needed by the Backend process that represents this
domain stanza. As such, while the domain stanza and the ad_domain might
both have the same name, the domain stanza is simply an arbitrary
configuration label. The primary purpose of naming the domain stanza is
so that it can be referenced by the domains line in the [sssd] stanza,
which lists the active domain stanzas for which the Monitor should spawn
Backend processes. While AD has full knowledge of the ad_domain named
“foo.com”, it knows nothing about the domain stanza named “foo.com”.</p>
</div>
<div class="section" id="sssd-implementation">
<h3>4.2.3. SSSD Implementation<a class="headerlink" href="#sssd-implementation" title="Permalink to this headline">¶</a></h3>
<p>Even without trust relationships, we can have multiple domain stanzas in
the configuration, each corresponding to a single Backend (and a single
ad_domain). In this simpler case, a Responder still needs some way of
determining to which Backend it should forward a particular client
request. If the client request includes a fully-qualified username (i.e.
including a domain name), then the Responder simply selects the Backend
with a matching domain stanza name. If a fully-qualified username is not
used (which is common), the Responder uses each Backend (in the same
order as specified in the [sssd] stanza) to find the username&#8217;s entry,
stopping as soon as one is found.</p>
<p>Now, let&#8217;s see what happens when trust relationships are introduced. In
order to deal with multiple domains that have trust relationships
between them, SSSD implements support for three separate, but related,
features:</p>
<ul class="simple">
<li>Subdomains</li>
<li>Global Catalog</li>
<li>PAC Responder</li>
</ul>
<p>In the presence of trust relationships between ad_domains, things get
complicated. Now, a single domain stanza, while still corresponding to a
single Backend, may correspond to multiple ad_domains (the primary one,
as well as several other ad_domains with which the primary ad_domain
has direct or transitive trust relationships). As such, a single domain
stanza (and Backend) can support multiple trusted ad_domains, which
SSSD refers to as “subdomains” (not to be confused with DNS subdomains,
which require a parent/child relationship). As such, regardless of
whether or not a fully-qualified username is included in the client
request, the Responder sends an SBus message to each Backend (in the
same order as it is specified in the config), asking it to send back the
list of subdomains it supports, and then attempts to find an entry for
the username in each subdomain, stopping as soon as one is found, and
moving on to the next Backend (and its subdomains) if not found. The
concept of subdomains also applies to groups.</p>
<p>In a single ad_domain scenario, the Backend can use the standard LDAP
interface of AD to lookup users and groups. However, the LDAP interface
only returns information about the users and groups in that single
ad_domain. In order to obtain forest-wide information, including
universal group memberships, the Backend uses the GC interface of AD to
lookup users and groups. Note that the GC is essentially an LDAP server
running on a non-standard port.</p>
<p>Similar to other Responders, the PAC Responder is an SSSD Process which
is spawned and managed by the Monitor. It registers itself with the
Monitor and the Backend. Unlike other Responders, the PAC Responder is
not called by an SSS Client Library. Rather, it is called by a
short-lived Kerberos Child Process during Kerberos authentication. If a
PAC exists in the Kerberos ticket, the Child Process sends the PAC,
along with the user principal, to the PAC Responder. The PAC Responder
decodes the information in the PAC, such as group membership from
trusted domains, and updates the System Cache accordingly.</p>
<p>Having discussed the subdomains, global catalog, and pac responder
concepts in this section, we will now return to our simplifying
assumption for the remainder of the document: that only a single
ad_domain (without any trust relationships) is being used.</p>
</div>
</div>
</div>
<div class="section" id="sssd-wrappers">
<h1>5. SSSD Wrappers<a class="headerlink" href="#sssd-wrappers" title="Permalink to this headline">¶</a></h1>
<p>When SSSD calls an external library, it needs to maintain its
tevent-based asynchronous semantics. We have already discussed the case
in which the external library only supports blocking function calls
(e.g. krb5). SSSD simply spawns a Child Process, which will make the
blocking calls and will return the response to SSSD when its done (which
may take some time). In this section, we discuss the case in which the
external library does support non-blocking function calls (e.g. dbus,
openldap). Since such external libraries were likely not written with
the tevent main loop in mind, SSSD uses a wrapper around each external
library in order to integrate it with the tevent main loop. This section
examines the SBus wrapper (for the DBus library) and the SDAP wrapper
(for the OpenLDAP library).</p>
<div class="section" id="sbus">
<h2>5.1. SBus<a class="headerlink" href="#sbus" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sbus-concepts">
<h3>5.1.1. SBus Concepts<a class="headerlink" href="#sbus-concepts" title="Permalink to this headline">¶</a></h3>
<p>SBus is a wrapper library used to integrate the D-Bus library with the
tevent main loop. SBus uses UNIX Domain Sockets to send messages between
SBus Clients (which initiate new connections) and SBus Servers (which
accept new connections). Note that SBus does not make use of the D-Bus
message bus, but rather uses the D-Bus protocol in a point-to-point
manner (mostly for data marshalling). Once an SBus connection has been
established between an SBus Client and SBus Server, it becomes a
peer-to-peer situation, in which either end can send and receive SBus
messages. An SBus message is made up of a header and a body.
Essentially, the header contains the method-name and its typed
arguments, while the body contains specific values for each argument. In
addition to this section, more information can be found at [SBus].</p>
<p>The fundamental data structure used by SBus (for both SBus Clients and
SBus Servers) is the sbus_connection object, which represents a
peer-to-peer connection over which messages can be sent and received.
Each peer&#8217;s sbus_connection is created with one or more (in the case of
the public DBus API) sbus intefaces, which specify the sbus_methods
that the peer implements (essentially method/function pairs). These
sbus_method name/function pairs are extremely useful when examining the
code base, since they specify each process&#8217;s message processing entry
points. When a peer&#8217;s socket receives an SBus message that targets one
of its sbus_method names, the peer executes the corresponding
sbus_method function.</p>
<p>SSSD has several peer-to-peer connections, where each peer can call
sbus_methods specified in the other peer&#8217;s sbus_interface. If we
examine each sender/receiver pair, the sbus_methods called by the
sender and implemented by the receiver are as follows (ones in bold are
particularly important):</p>
<ul class="simple">
<li>Control Traffic<ul>
<li>Monitor =&gt; Backend or Responder<ul>
<li><em>ping</em>: send messages to registered child processes to
determine if they are alive</li>
<li><em>resInit</em>: reload /etc/resolv.conf to get address of DNS server</li>
<li><em>rotateLogs</em>: close current debug file; open new debug file</li>
<li><em>clearMemcache</em> (NSS Responder only): reinitialize Fast Cache
(memcache) maps</li>
</ul>
</li>
<li>Monitor =&gt; Backend<ul>
<li><em>goOffline</em>: mark process as offline; run any offline callbacks</li>
<li><em>resetOffline</em>: attempt to go online; if successful, run any
online callbacks</li>
</ul>
</li>
<li>Backend or Responder =&gt; Monitor<ul>
<li><em>getVersion</em>: called by process to retrieve monitor&#8217;s version
number</li>
<li><em>RegisterService</em>: called by process to register itself with
Monitor</li>
</ul>
</li>
<li>Responder =&gt; Backend<ul>
<li><em>RegisterService</em>: called by Responder to register itself with
Backend</li>
</ul>
</li>
</ul>
</li>
<li>Data Traffic<ul>
<li><strong>Responder</strong> =&gt; <strong>Backend</strong><ul>
<li><strong>*getAccountInfo*: initiate identity lookup (e.g. getpwnam,
initgroups, etc)</strong></li>
<li><strong>*pamHandler*: initiate pam-related functionality (e.g.
authentication, acct mgmt, etc)</strong></li>
</ul>
</li>
<li>Backend =&gt; NSS Responder<ul>
<li>initgrCheck: send user&#8217;s group memberships (pre-refresh) to NSS
Responder, so that it can determine if memberships have changed
(between pre-refresh and post-refresh), in which case it can
clean up the memcache accordingly. Note that this is not
related to the Initgroups Cache (id_table) maintained by the
PAM Responder.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>In SSSD, SBus servers are run as part of the Monitor and Backend
processes (but not the Responder processes). Each SBus server can be
characterized by the following:</p>
<ul class="simple">
<li>server_address: well-known socket address on which server listens
for connections</li>
<li><em>srv_init_fn</em>: connection initialization function</li>
<li>srv_init_data: connection initialization private data</li>
</ul>
<p>An SBus Server creates an sbus_connection object by calling
<em>sbus_new_server</em> with the three parameters given above. Once created,
an SBus Server begins listening for new connections at its well-known
server_address. When it receives a new connection request from a
Process, the SBus Server calls <em>sbus_server_init_new_connection</em>,
which does the following:</p>
<ul class="simple">
<li>creates a new per-connection sbus_connection object</li>
<li>uses the previously specified <em>init_fn</em> and init_pvt_data to call
<em>init_fn(conn, init_pvt_data)</em></li>
<li>registers the per-server interface (an instance of sbus_vtable) and
the initialization private data with a call to <code class="docutils literal"><span class="pre">sbus_new_interface</span></code>
at an object path. This vtable and private data would be used by the
<code class="docutils literal"><span class="pre">sbus_message_handler</span></code> when a message targeted at the registered
object path arrives.</li>
</ul>
<p>An SBus Client creates an sbus_connection object by calling
<em>sbus_client_init</em> with the following parameters: server_address,
intf, conn_pvt_data. Once created, an SBus Client can request a
connection to the SBus Server listening at server_address, after which
it can send messages supported by the SBus Server&#8217;s sbus_interface.
Once connected to an SBus Server, that SBus Server can send messages
supported by the SBus Client&#8217;s sbus_interface (intf). The
conn_pvt_data is opaque data stored with the sbus_connection object,
that can later be retrieved from the SBus Client. Each SBus Client in
SSSD is associated with its SBus Server&#8217;s server_address, its SBus
Client intf, and SBus Client conn_pvt_data.</p>
<p>A sender calls <em>sbus_conn_send</em>(msg, <strong>reply_handler</strong>, pvt) in
order to send a message, and to register a <strong>reply handler</strong>, which will
handle the reply message. When the message arrives at the receiver, it
calls <em>sbus_message_handler</em>, which extracts the sbus_interface and
sbus_connection registered for that object path, and calls the function
corresponding to the method name, with the request message and
sbus_connection as inputs. The entry-point function does the following:</p>
<ul class="simple">
<li>extracts its private data from the sbus_connection input</li>
<li>extracts request arguments from the request message input</li>
<li>performs method-specific processing using inputs to generate outputs</li>
<li>creates a reply message that matches the request message (i.e. same
serial number)</li>
<li>appends output arguments to reply message</li>
<li>sends back reply message on same sbus_connection on which it
received the request</li>
</ul>
<p><em>This figure shows the functions used in the sending and receiving of an
SBus message</em></p>
<p>Starting with upstream version 1.12, when the SSSD implemented its
public DBus interface, the SSSD switched from hardcoding interface
names, methods etc in the source files directly to only describing the
interfaces in XML files using the <a class="reference external" href="http://dbus.freedesktop.org/doc/dbus-specification.html#introspection-format">​introspection
format</a>,
which are then used to autogenerate message handlers, property getters
and similar. While using generated code might sound odd at first, using
a code generator removes a large amount of code duplication, packing and
unpacking from DBus types to C types or vice versa, or unpacking DBus
message properties (if needed).</p>
<p>The code generator and the generated code are currently used for both
the DBus public interface (which is outside the scope of this page) and
the internal SBUS communication. The internal SBUS code, however, uses
the generated code in a &#8216;raw&#8217; mode mostly and still does
packing/unpacking of the parameters on its own. The reason is that the
&#8216;raw&#8217; code in SSSD predates the code generator, is quite stable and
tested and converting it to the easier handlers with unpacked parameters
might cause functional regressions.</p>
<p>One example of the canonical XML code might be found in the <a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/tests/sbus_codegen_tests.xml">​unit
tests</a>,
along with the <a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/tests/sbus_codegen_tests_generated.c">​corresponding autogenerated
code</a>.
The XML files for the internal interfaces, such as the <a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_iface.xml">​Data
Provider</a>
can also be inspected. Since all the internal interfaces use the raw
approach, the autogenerated code is <a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_iface_generated.c">​quite
terse</a>
and the <a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_be.c">​interface
handlers</a>
do the packing and unpacking on their own.</p>
</div>
<div class="section" id="responder-to-backend-api">
<h3>5.1.2. Responder-to-Backend API<a class="headerlink" href="#responder-to-backend-api" title="Permalink to this headline">¶</a></h3>
<p>This section examines those sbus_methods exported in the Backend&#8217;s SBus
Interface that are called by the NSS/PAM Responders. For NSS requests, a
Responder sends a <em>getAccountInfo</em> message to the Backend, which handles
it by calling be_get_account_info. For PAM requests, a Responder
sends a <em>pamHandler</em> message to the Backend, which handles it by calling
be_pam_handler. The be_methods array of sbus_method objects specify
the name/function pairs supported by the Backend.</p>
<p>Note that when the Backend receives an incoming SBus message, it creates
a be_req object, and includes in that object a backend response
callback. Once the Backend has completed processing the request (after
contacting the AD Server, etc) and is ready to return a response to the
Responder, the registered backend response callback is called. More on
this below.</p>
<div class="section" id="request-nss-pam-responder-backend">
<h4>5.1.2.1.1. Request (NSS/PAM Responder-&gt;Backend)<a class="headerlink" href="#request-nss-pam-responder-backend" title="Permalink to this headline">¶</a></h4>
<p>The <em>sbus_method</em> named <em>getAccountInfo</em> is sent by the NSS Responder
and PAM Responder to the Backend for identity lookups. Note that while
the NSS Responder is sending the message in response to an SSS Client
request (e.g. getpwnam, getgrgid, etc), the PAM Responder only sends the
message for group membership retrieval (regardless of the SSS Client
request it is handling). As such, the INITGROUPS operation is handled
differently by the Backend, as noted below.</p>
<p>The <em>getAccountInfo</em> request message takes the following four arguments:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">be_type</span><span class="p">:</span>    <span class="n">the</span> <span class="n">operation</span> <span class="n">to</span> <span class="n">perform</span>         <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">USER</span><span class="p">,</span> <span class="n">GROUP</span><span class="p">,</span> <span class="n">INITGROUPS</span><span class="p">,</span> <span class="n">etc</span>
<span class="nb">int</span> <span class="n">attrs</span><span class="p">:</span>      <span class="n">attributes</span> <span class="n">to</span> <span class="n">be</span> <span class="n">returned</span>        <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">CORE</span><span class="p">,</span> <span class="n">MEM</span><span class="p">,</span> <span class="n">ALL</span>
<span class="n">char</span> <span class="o">*</span><span class="nb">filter</span><span class="p">:</span>   <span class="n">the</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">select</span>           <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="s2">&quot;name=aduser&quot;</span><span class="p">,</span> <span class="s2">&quot;idnumber=73&quot;</span><span class="p">,</span> <span class="n">etc</span>
<span class="n">char</span> <span class="o">*</span><span class="n">dom_name</span><span class="p">:</span> <span class="n">the</span> <span class="n">domain</span> <span class="n">name</span>                  <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="s2">&quot;foo.com&quot;</span><span class="p">,</span> <span class="n">etc</span>
</pre></div>
</div>
</div><p>For example, an SBus request message representing
getpwnam(&#8220;<a class="reference external" href="mailto:aduser&#37;&#52;&#48;foo&#46;com">aduser<span>&#64;</span>foo<span>&#46;</span>com</a>&#8221;) includes the following input values:</p>
<ul class="simple">
<li>be_type: BE_REQ_USER</li>
<li>attrs: BE_ATTR_CORE</li>
<li>filter: &#8220;name=aduser&#8221;</li>
<li>domain: &#8220;foo.com&#8221;</li>
</ul>
<p>As specified in be_methods, the function on the Backend corresponding
to this sbus_method name is <em>be_get_account_info</em>. For all
operations other than INITGROUPS, <em>be_get_account_info</em> specifies
acctinfo_callback as the backend response callback, after which it
calls <em>ad_account_info_handler</em> to do the actual processing (for our
AD use case). Once processing is complete, <em>acctinfo_callback</em> is
called, which prepares the response message and sends it back to the
Responder.</p>
<p>For the INITGROUPS operation, <em>be_get_account_info</em> specifies
<em>acctinfo_initgroups_callback</em> as the backend response callback. In
this case, once processing is complete, <em>acctinfo_initgroups_callback</em>
is called, which sends an <em>initgrCheck</em> SBus message to the NSS
Responder. As mentioned earlier, this allows the NSS Responder to
compare the user&#8217;s pre-refresh and post-refresh group memberships, so
that it can clean up the memcache accordingly. Once the <em>initgrCheck</em>
SBus message has been sent, then <em>acctinfo_callback</em> is called, which
prepares the actual initgroups response message, and sends it back to
the Responder.</p>
</div>
<div class="section" id="response-backend-nss-pam-responder">
<h4>5.1.2.1.2. Response (Backend=&gt;NSS/PAM Responder)<a class="headerlink" href="#response-backend-nss-pam-responder" title="Permalink to this headline">¶</a></h4>
<p>The SBus reply message for the <em>getAccountInfo</em> sbus_method contains
the following three arguments:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span>int dp_err:     error code                      // e.g..DP_ERR_OK, DP_ERR_TIMEOUT, DP_ERR_OFFLINE
int dp_ret:     errno                           // e.g. EOK, EINVAL
char *err_msg:  error message for logging       // e.g. “Success”, “Out of memory”
</pre></div>
</div>
</div><p>For example, a successful SBus reply message would include the following
output values:</p>
<p>An unsuccessful SBus reply message might include the following output
values:</p>
<p>Note that the actual result of the request is written to the sysdb Cache
by the Backend. The SBus response message is used not only to convey
error/success information, but also to indicate to the Responder that it
can retrieve the up-to-date result from the sysdb Cache. Initially, if
an entry didn&#8217;t exist in the Cache, it was considered a cache miss, and
it resulted in an update cache request to the Backend. Now that the
Backend has updated the cache, if an entry still doesn&#8217;t exist in the
Cache, it means that the entry really just doesn&#8217;t exist.</p>
<div class="section" id="pamhandler">
<h5>5.1.2.2. pamHandler<a class="headerlink" href="#pamhandler" title="Permalink to this headline">¶</a></h5>
</div>
</div>
<div class="section" id="request-pam-responder-backend">
<h4>5.1.2.2.1. Request (PAM Responder -&gt; Backend)<a class="headerlink" href="#request-pam-responder-backend" title="Permalink to this headline">¶</a></h4>
<p>The sbus_method named <em>pamHandler</em> is sent by the PAM Responder to the
Backend for PAM-related functionality, corresponding to PAM-supported
library calls (e.g. pam_authenticate, pam_acct_mgmt, etc). When a
caller (i.e. an SSS Client Application) calls a PAM function (e.g.
pam_authenticate) with various inputs, the PAM Client includes a
pam_items object in its client request to the PAM Responder, which
stores the caller-specified inputs, as well as some additional
information. In turn, when the PAM Responder receives the client request
message, it extracts the many arguments and stores them in a pam_data
object. Finally, the PAM Responder includes the pam_data object&#8217;s many
fields as arguments for the <em>pamHandler</em> message. These arguments
include:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">cmd</span><span class="p">:</span>                <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">SSS_PAM_AUTHENTICATE</span><span class="p">,</span> <span class="n">etc</span>
<span class="n">char</span> <span class="o">*</span><span class="n">domain</span><span class="p">:</span>           <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="s2">&quot;foo.com&quot;</span><span class="p">,</span> <span class="n">etc</span>
<span class="n">char</span> <span class="o">*</span><span class="n">user</span><span class="p">:</span>             <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="s2">&quot;aduser&quot;</span><span class="p">,</span> <span class="n">etc</span>
<span class="nb">int</span> <span class="n">authtok_type</span><span class="p">:</span>       <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">PASSWORD</span><span class="p">,</span> <span class="n">CCFILE</span><span class="p">,</span> <span class="n">etc</span>
<span class="nb">int</span> <span class="o">*</span><span class="n">authtok_data</span><span class="p">:</span>      <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="s2">&quot;adpass&quot;</span><span class="p">,</span> <span class="n">etc</span>
</pre></div>
</div>
</div><p>For example, an SBus request message representing
pam_authenticate(&#8220;<a class="reference external" href="mailto:aduser&#37;&#52;&#48;foo&#46;com">aduser<span>&#64;</span>foo<span>&#46;</span>com</a>&#8221;, &#8220;adpass&#8221;) includes the following
input values:</p>
<p>As specified in be_methods, the function on the Backend corresponding
to this sbus_method name is <em>be_pam_handler</em>, which specifies
<em>be_pam_handler_callback</em> as its backend response callback, after
which it calls <em>krb5_pam_handler</em>(for the SSS_PAM_AUTHENTICATE or
SSS_PAM_CHAUTHTOK commands) or <em>ad_access_handler</em> (for the
SSS_PAM_ACCT_MGMT command). Once processing is complete,
<em>be_pam_handler_callback</em> is called, which prepares the response
message and sends it back to the Responder.</p>
</div>
<div class="section" id="response-pam-responder-backend">
<h4>5.1.2.2.2. Response (PAM Responder -&gt; Backend)<a class="headerlink" href="#response-pam-responder-backend" title="Permalink to this headline">¶</a></h4>
<p>The SBus reply message for the <em>pamHandler</em> sbus_method contains the
pam status, followed by an array of responses, with each response
consisting of a response type and response message. Note that after the
Responder receives the responses, it includes them in its reply to the
SSS Client (after filtering out certain response types).</p>
<p>The pam_status argument (defined by the PAM library) can take one of
many values, including the following (I have omitted the “PAM_”
prefixes): SUCCESS, PERM_DENIED, ACCT_EXPIRED, AUTHINFO_UNAVAIL,
NEW_AUTHTOK_REQD, CRED_ERROR, CRED_UNAVAIL, SYSTEM_ERR, AUTH_ERR</p>
<p>Let us examine some responses, each consisting of a {type, message}
tuple. Some responses are intended for consumption by the SSS Client.
These response types are documented in sss_cli.h. Examples include:</p>
<ul class="simple">
<li>{SSS_PAM_USER_INFO, SSS_PAM_USER_INFO_OFFLINE_CHPASS}</li>
<li>{SSS_PAM_SYSTEM_INFO, “The user account is expired on the AD
server&#8221;}</li>
<li>{SSS_PAM_ENV_ITEM, “KRB5CCNAME=/run/user/...”}</li>
<li>{SSS_PAM_DOMAIN_NAME, &lt;domain&gt;}</li>
<li>{SSS_OTP, NULL}</li>
</ul>
<p>Other responses are filtered out by the PAM Responder, as they are not
intended for the SSS Client. Examples include:</p>
<ul class="simple">
<li>{SSS_KRB_INFO_TGT_LIFETIME, &lt;time&gt;}</li>
<li>{SSS_KRB5_INFO_UPN, &lt;upn&gt;}</li>
</ul>
</div>
</div>
</div>
<div class="section" id="sdap">
<h2>5.2. SDAP<a class="headerlink" href="#sdap" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sdap-concepts">
<h3>5.2.1. SDAP Concepts<a class="headerlink" href="#sdap-concepts" title="Permalink to this headline">¶</a></h3>
<p>SDAP (“SSSD LDAP”) is a wrapper around the OpenLDAP library. It is used
to integrate the OpenLDAP API with the tevent main loop. It is also used
to provide additional support for failover (among other things).
Specifically, when an OpenLDAP connection is made to a particular LDAP
server&#8217;s IP address, OpenLDAP maintains only the server&#8217;s hostname as
part of its connection state. OpenLDAP periodically resolves the host
name using DNS, which could result in the connection being transparently
switched to another server with the same hostname, but different IP
address (i.e. no server affinity).</p>
<p>On the other hand, once an SDAP connection is made to a particular LDAP
server&#8217;s IP address, SDAP maintains the server&#8217;s IP address as part of
its connection state, meaning that the connection remains with that
server (until it expires or goes offline). This allows us to have
semantics where we failover only when that particular server fails
(rather than having to deal with intermittent failures). Note that SDAP
also maintains an LDAP URI as part of its connection state, in order to
make certificate comparisons when TLS is used.</p>
<p>All of this is possible because SDAP connects to the LDAP server itself
(rather than relying on OpenLDAP to make the connection) and simply
passing the resulting file descriptor to OpenLDAP using ldap_init_fd
(when available). By owning the connection, SDAP has full control over
how it wants to deal with failover, DNS resolution, etc.</p>
<p>SDAP represents a connection to the LDAP server using the
sdap_id_conn_data object. Once a connection is established (typically
on the first operation request), it can be used multiple times to
transfer LDAP operation requests and responses until the connection
expires (or we go offline). For each LDAP operation request (e.g. bind,
search, etc) , two objects are created: one for the operation request
itself (sdap_op) and one for keeping track of retrying the operation
request (sdap_id_op).</p>
</div>
<div class="section" id="establishing-an-ldap-connection">
<h3>5.2.2. Establishing an LDAP Connection<a class="headerlink" href="#establishing-an-ldap-connection" title="Permalink to this headline">¶</a></h3>
<p>Establishing an LDAP connection (<em>sdap_cli_connect_send</em>) is a
multi-step process that involves the DNS server, the LDAP server, and
the KDC. The steps involved are as follows:</p>
<ul class="simple">
<li><em>be_resolve_server_send</em>: retrieve addressing information
(ip/port) for AD&#8217;s LDAP service</li>
<li><em>sdap_connect_send</em>: connect to server; register incoming message
handler (<em>sdap_ldap_result</em>)</li>
<li><em>sdap_cli_rootdse_step</em>: attempt to anonymously retrieve the LDAP
server&#8217;s rootDSE</li>
<li><em>sdap_cli_kinit_step</em>: obtain a TGT from a KDC (after retrieving
its addressing information)</li>
<li><em>sdap_cli_auth_step</em>: perform an LDAP bind (either sasl or
simple); if we were unable to retrieve rootDSE info earlier
(anonymously), we try to retrieve it again now that we&#8217;re
authenticated</li>
</ul>
</div>
<div class="section" id="performing-ldap-operations">
<h3>5.2.3. Performing LDAP Operations<a class="headerlink" href="#performing-ldap-operations" title="Permalink to this headline">¶</a></h3>
<p>Once an authenticated connection has been established, including
registering the <em>sdap_ldap_result</em> handler for incoming messages, we
can start sending LDAP operations over the connection. The OpenLDAP API
allows most operations to be performed with either synchronous or
asynchronous funcions. In order to perform a synchronous LDAP operation,
the appropriate synchronous API call is made (e.g.
ldap_search_ext_s), and we block on that call until it completes (or
times out).</p>
<p>In order to perform an asynchronous LDAP operation, the appropriate
asynchronous API call is made (e.g. ldap_search_ext), which returns a
message id. We then call sdap_op_add, which creates an sdap_op object
representing the operation (msgid,
callback=<em>sdap_get_generic_ext_done</em>, and callback arg=req w/
sdap_get_generic_ext_state), and which adds the sdap_op object to
the sdap handle&#8217;s list of sdap_op objects.</p>
<p>Later, when a response is received on the fd, the tevent main loop calls
the handler we registered when establishing the connection (i.e.
<em>sdap_ldap_result</em>), which calls <em>ldap_result</em> with that message id
in order to poll the library to check whether results have been
received. If results have not been received, <em>ldap_result</em> returns 0,
in which case we try polling for results again later on. If results have
been received, <em>ldap_result</em> returns an LDAPMessage, which we proceed
to process by calling <em>sdap_process_message</em>. We extract the msgid
from the message, and iterate through our sdap_handle&#8217;s list of
sdap_op objects until we find an sdap_op with a matching msgid, at
which point we add the message to the op&#8217;s list and call the sdap_op&#8217;s
callback, passing it the LDAP message and the callback&#8217;s arg. This
callback switches on the msgtype of the message. If the reply message is
a SEARCH_ENTRY, then we call the parse_cb registered earlier (as part
of sdap_get_generic_ext_send). For sdap_get_generic_send, the
parse_cb is <em>sdap_get_generic_parse_entry</em>. We then add a timer
event to process the next reply after the timer expires. If the reply
message is a SEARCH_RESULT, then we simply call <em>ldap_parse_result</em>.</p>
</div>
</div>
</div>
<div class="section" id="common-data-structures">
<h1>6. Common Data Structures<a class="headerlink" href="#common-data-structures" title="Permalink to this headline">¶</a></h1>
<p>This section describes some important data structures that are used by
each of the SSSD Processes. In order to have a more readable
description, the text below uses the term “Process” with a capital &#8216;P&#8217;
to interchangeably mean either the Monitor process, the Responder
processes, or the Backend process. Exceptions to this rule are noted.</p>
<p>When it first starts, a Process calls the following functions:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">server_setup</span><span class="p">()</span>                  <span class="o">//</span> <span class="n">creates</span> <span class="n">main_context</span> <span class="p">(</span><span class="n">includes</span> <span class="n">tevent_ctx</span> <span class="ow">and</span> <span class="n">confdb_ctx</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">process</span><span class="o">-</span><span class="n">specific</span><span class="o">&gt;</span><span class="n">_init</span><span class="p">()</span>       <span class="o">//</span> <span class="n">creates</span> <span class="n">process</span><span class="o">-</span><span class="n">specific</span> <span class="n">context</span>
<span class="n">server_loop</span><span class="p">()</span>                   <span class="o">//</span> <span class="n">calls</span> <span class="n">tevent_loop_wait</span> <span class="n">on</span> <span class="n">tevent_ctx</span> <span class="p">(</span><span class="n">to</span> <span class="n">start</span> <span class="n">the</span> <span class="n">main</span> <span class="n">loop</span><span class="p">)</span>
</pre></div>
</div>
</div><div class="section" id="tevent-context">
<h2>6.1. tevent_context<a class="headerlink" href="#tevent-context" title="Permalink to this headline">¶</a></h2>
<p>The purpose of a Process&#8217;s tevent_context is to contain the events that
are to be monitored by that Process&#8217;s main loop. As such, the primary
interaction that a Process has with its tevent_context is to add/remove
events. During startup, a Process calls the following tevent-related
functions:</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">server_setup</span>
        <span class="n">tevent_context_init</span>     <span class="o">//</span> <span class="n">creates</span> <span class="n">singleton</span> <span class="n">tevent_context</span>
<span class="o">&lt;</span><span class="n">process</span><span class="o">-</span><span class="n">specific</span><span class="o">&gt;</span> <span class="n">init</span>
        <span class="n">tevent_add_</span><span class="o">*</span>            <span class="o">//</span> <span class="n">adds</span> <span class="n">some</span> <span class="n">events</span> <span class="n">to</span> <span class="n">tevent_context</span>
<span class="n">server_loop</span>
        <span class="n">tevent_loop_wait</span>        <span class="o">//</span> <span class="n">starts</span> <span class="n">main</span> <span class="n">loop</span> <span class="n">using</span> <span class="n">tevent_context</span>
</pre></div>
</div>
</div><p>Note that tevent_loop_wait initially monitors only the events in its
just-populated tevent_context input argument. Once a Process&#8217;s main
loop has started, it adds additional events to its tevent_context as
needed. Of the four types of events, the SSSD code primarily adds
tevent_fd and tevent_timer events, using the <em>tevent_add_fd</em> and
<em>tevent_add_timer</em> functions.</p>
</div>
<div class="section" id="confdb-ctx">
<h2>6.2. confdb_ctx<a class="headerlink" href="#confdb-ctx" title="Permalink to this headline">¶</a></h2>
<p>The purpose of a Process&#8217;s confdb_ctx is to allow the Process to
interact with the Config DB (config.ldb). As such, the primary
interaction that a Process has with the Config DB is to get or set
configuration information, using functions such as <em>confdb_get_int</em>
and <em>confdb_set_bool</em>.</p>
<p>There is a single system-wide Config DB, which is initialized by the
Monitor before it spawns the other processes. As part of its
initialization, the Monitor calls load_configuration, which contains
the confdb initialization code (specifically <em>confdb_init_db</em>). The
load_configuration function reads the configuration text file
(sssd.conf), parses it, and uses <em>ldb_add</em> to store the parsed values
into the Config DB. As such, any changes made to sssd.conf after the
Monitor has started will require the Monitor to be restarted. The
Monitor parses sssd.conf using libiniconfig, resulting in minimal
validation of configuration values; any additional validation is left to
the SSSD code. However, once dinglibs adds support for schema
validation, SSSD should be able to take advantage of it (since
libiniconfig is based on dinglibs).</p>
<p>Once the Config DB has been initially populated, a Process&#8217;s
initialization code calls <em>confdb_init()</em>, which internally calls
<em>ldb_connect()</em> to connect to the Config DB, and which returns a new
confdb_ctx that is needed for subsequent confdb calls. All of the
gettor functions that interact with the confdb take the confdb_ctx as
one of their input arguments. Generic accessor functions are provided in
confdb.h, while plugin-specific accessor functions are also provided
(e.g. ad_opts.h).</p>
<p>In summary, the following confdb-related functions are called during
startup:</p>
<ul class="simple">
<li><strong>load_configuration (only called by Monitor)</strong> <em>initializes Config
DB</em></li>
<li>server_setup (called by all Processes)<ul>
<li><strong>confdb_init</strong> <em>creates singleton confdb_ctx</em></li>
</ul>
</li>
<li>&lt;process-specific&gt; init<ul>
<li><strong>confdb_get_*</strong> <em>retrieves config info from Config DB</em></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="sysdb-ctx">
<h2>6.3. sysdb_ctx<a class="headerlink" href="#sysdb-ctx" title="Permalink to this headline">¶</a></h2>
<p>The purpose of a Process&#8217;s sysdb_ctx is to allow the Process to
interact with a domain&#8217;s system cache (i.e. to get/set cached
information for a domain). The exception to this is the Monitor process,
which only initializes a sysdb_ctx in order to allow the sysdb to be
upgraded at startup, which is typically needed when an upgrade to a new
SSSD version results in changes to the internal db schema). As such,
only a Responder/Backend process maintains a reference to its
sysdb_ctx.</p>
<p>The sysdb_ctx field is primarily accessed through the sss_domain_info
structure that encapsulates it. As such, a Process first calls
confdb_get_domains, and then passes all of the configured
sss_domain_info structures to sysdb_init, which creates a separate
sysdb (i.e. ldb database) for each domain. Since our use case has only a
single domain, there is only a single system-wide sysdb, in which case
the terms sysdb and system cache refer to the same ldb database.</p>
<p>Individual entries in the sysdb cache are referenced using the
sysdb_attrs structure, which represents an entry that can have multiple
multi-valued attributes, and which is created by sysdb_new_attrs. It
is by using the sysdb_attrs API that a Process can get/set cached
values. Accessor functions are provided in sysdb.h (e.g.
sysdb_attrs_get_string, sysdb_attrs_add_string). Using the gettor
functions is self-explanatory, but care must be taken when using the
settor functions, to ensure that they are written in a transactional
manner (data completely stored or not stored at all). To this end, a
Process wanting to write information to the cache would make calls
similar to the following (with each call taking the sysdb_ctx as an
input argument):</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">sysdb_transaction_start</span><span class="p">();</span> <span class="o">//</span> <span class="nb">set</span> <span class="n">entries</span> <span class="n">using</span> <span class="n">either</span> <span class="n">the</span> <span class="n">sysdb_attrs</span> <span class="n">API</span> <span class="ow">or</span> <span class="n">directly</span> <span class="n">using</span> <span class="n">the</span> <span class="n">ldb</span> <span class="n">API</span> <span class="p">(</span><span class="n">ldb_modify</span><span class="p">,</span> <span class="n">etc</span><span class="p">)</span><span class="o">.</span>
<span class="n">sysdb_transaction_commit</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
   <span class="n">sysdb_transaction_cancel</span><span class="p">();</span>
</pre></div>
</div>
</div></div>
<div class="section" id="main-context">
<h2>6.4. main_context<a class="headerlink" href="#main-context" title="Permalink to this headline">¶</a></h2>
<p>As mentioned earlier, when it first starts, a Process performs some
initialization tasks, including</p>
<ul class="simple">
<li>server_setup</li>
<li>&lt;process-specific&gt; init function (e.g. nss_init, pam_init,
be_process_init)</li>
<li>server_loop</li>
</ul>
<p>In brief, server_setup creates a main_context, the process-specific
init function creates a process-specific context (i.e. nss_ctx,
pam_ctx, be_ctx), and the server_loop function simply calls
tevent_loop_wait in order to start the main loop.</p>
<p>The main_context essentially contains an appropriately initialized
tevent_context and confdb_ctx (described earlier), which each Process
will need in order to make tevent or confdb function calls. Rather than
containing a pointer to the main_context, each process-specific context
contains direct pointers to the tevent_context and confdb_ctx
components of the main_context (why??). The server_loop function calls
tevent_loop_wait using the main_context&#8217;s tevent_context as input.
Since the process-specific context&#8217;s tevent_context and the
main_context&#8217;s tevent_context are pointing to the same object, the
main loop will be able to see events added to the process-specific
tevent_context.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Monitor</span>                     <span class="n">Responder</span>          <span class="n">Backend</span>

<span class="n">load_configuration</span><span class="p">()</span>
<span class="n">server_setup</span><span class="p">()</span>
<span class="n">monitor_process_init</span><span class="p">()</span>

    <span class="n">add_new_provider</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">fork</span><span class="o">/</span><span class="n">exec</span> <span class="o">==============================&gt;</span> <span class="n">server_setup</span><span class="p">()</span>
                                        <span class="n">be_process_init</span><span class="p">()</span>
                                    <span class="n">server_loop</span><span class="p">()</span>

    <span class="n">add_new_service</span><span class="p">()</span> <span class="o">=&gt;</span> <span class="n">fork</span><span class="o">/</span><span class="n">exec</span><span class="o">=====&gt;</span> <span class="n">server_setup</span><span class="p">()</span>
                             <span class="n">nss</span><span class="o">/</span><span class="n">pam_process_init</span><span class="p">()</span>
                         <span class="n">sss_process_init</span><span class="p">()</span>
                         <span class="n">server_loop</span><span class="p">()</span>

<span class="n">server_loop</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="component-details">
<h1>7. Component Details<a class="headerlink" href="#component-details" title="Permalink to this headline">¶</a></h1>
<p>This section looks more closely at the SSSD components, including
process-specific data structures and functions, as well as inter-process
communication. The following components are discussed, where each
component uses its process-specific init function to produce its
process-specific context:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="43%" />
<col width="36%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>component</em></td>
<td><em>process-specific init function</em></td>
<td><em>process-specific context</em></td>
</tr>
<tr class="row-even"><td>Monitor</td>
<td><em>monitor_process_init</em></td>
<td>mt_ctx</td>
</tr>
<tr class="row-odd"><td>NSS Responder</td>
<td><em>nss_process_init</em></td>
<td>nss_ctx</td>
</tr>
<tr class="row-even"><td>PAM Responder</td>
<td><em>pam_process_init</em></td>
<td>pam_ctx</td>
</tr>
<tr class="row-odd"><td>Backend</td>
<td><em>be_process_init</em></td>
<td>be_ctx</td>
</tr>
</tbody>
</table>
<div class="section" id="monitor">
<h2>7.1. Monitor<a class="headerlink" href="#monitor" title="Permalink to this headline">¶</a></h2>
<p>The monitor is the master SSSD process that is executed when
/usr/sbin/sssd is run. The Monitor&#8217;s context (struct mt_ctx) is created
during startup by <em>monitor_process_init()</em> and is used to store
Monitor-relevant information, such as a list of <em>mt_svc</em> objects
representing spawned processes. The role of the Monitor is:</p>
<ul class="simple">
<li>to parse the config file and load config info into the confdb for
SSSD processes to access</li>
<li>to monitor networking changes and act on them accordingly</li>
<li>to spawn a Backend process for each domain specified in the config</li>
<li>to spawn a Responder process for each service specified in the config
(e.g. NSS, PAM)</li>
<li>to receive SBus messages (primarily RegisterService) from Responders
and Backends</li>
<li>to periodically ping all Responders and Backends, and to restart them
if unable to ping</li>
</ul>
<p>In addition to this section, more information can be found in [Monitor].</p>
<div class="section" id="spawning-and-registering-processes">
<h3>7.1.1. Spawning and Registering Processes<a class="headerlink" href="#spawning-and-registering-processes" title="Permalink to this headline">¶</a></h3>
<p>The SBus server running as part of the Monitor is characterized by the
following:</p>
<p>Soon after this SBus server is created, the Monitor spawns the Backend
processes (one per domain) by calling <em>add_new_provider</em>, which does
the following:</p>
<ul class="simple">
<li>retrieves relevant config info, and uses it to populate mt_svc
object, which includes the mt_ctx, sbus_connection, as well as ping
parameters</li>
<li>builds the command line needed to start the process</li>
<li>forks the process<ul>
<li>the child process execs the command line, spawning the process</li>
<li>the parent process:<ul>
<li>adds the mt_svc object to its mt_ctx-&gt;svc_list</li>
<li>sets up a timer, which periodically pings the process to assess
if it is reachable</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The newly spawned child process does two monitor-related things during
initialization:</p>
<ul class="simple">
<li>sends a connection request to the Monitor, specifying child process&#8217;s
sbus_interface</li>
<li>identifies itself by sending a RegisterService message to the Monitor</li>
</ul>
<p>In response to the connection request, the parent process (i.e. the
Monitor) performs generic SBus initialization, but also performs
Monitor-specific SBus initialization by calling
<em>monitor_service_init(conn, mt_ctx)</em>, which creates a mon_init_conn
object that represents a temporary connection for a Monitor client, and
includes the conn, the mt_ctx, and a 10-second tevent_timer (by which
time the child process must identify itself by sending a
<em>RegisterService</em> message). This mon_init_conn object is then set as
the new sbus_connections&#8217;s private data.</p>
<p>In response to the incoming RegisterService message, the corresponding
client_registration method is called (with the request message and
sbus_connection as inputs) which does the following:</p>
<ul class="simple">
<li>retrieves mon_init_conn object from sbus_connection</li>
<li>cancels the 10-second tevent timer (since the RegisterService message
has been received)</li>
<li>retrieves request args, extracted from request message (i.e. sender
name, sender version)</li>
<li>finds sender&#8217;s mt_svc in mon_init_conn-&gt;mt_ctx-&gt;svc_list</li>
<li>sets mt_ctx-&gt;conn to the value of mon_init_conn-&gt;conn (i.e. conn
is no longer temporary)</li>
<li>marks process as started</li>
<li>calls add_new_service for each Responder, which spawns each
Responder in a similar manner:<ul>
<li>sends a connection request to the Monitor, specifying Responder&#8217;s
sbus_interface</li>
<li>identifies itself by sending a RegisterService message to the
Monitor</li>
</ul>
</li>
<li>creates a reply message that matches the request message, indicating
success</li>
<li>appends output arguments to reply message (i.e. monitor version)</li>
<li>sends back reply message on same sbus_connection on which it
received the request</li>
</ul>
<p>Once initialization is complete, all Backends and Responders should be
registered with the Monitor, allowing the Monitor to send periodic pings
to each process. If the Monitor is unable to contact a child process
three times, the Monitor restarts the child process.</p>
</div>
</div>
<div class="section" id="sss-client">
<h2>7.2. SSS Client<a class="headerlink" href="#sss-client" title="Permalink to this headline">¶</a></h2>
<p>An SSS Client sends request messages to a matched Responder, and
receives back a corresponding response message. A request message
includes a command and command-specific input, while a response message
includes a status code and command-specific output. The SSS Clients
(e.g. NSS Client, PAM Client) use common code to send request messages
to a matching Responder, and receive responses from a matching
Responder, using the SSS_CLI protocol. This common code makes a
blocking call to send the request message and receive the response
message. The reason blocking calls are made is that, unlike the other
SSSD Components, SSS Clients do not use the tevent main loop, since we
have no control over the SSSD Client Application in which the SSS Client
is running.</p>
<div class="section" id="sss-cli">
<h3>7.2.1. SSS_CLI<a class="headerlink" href="#sss-cli" title="Permalink to this headline">¶</a></h3>
<p>Before moving on, let&#8217;s examine the SSS_CLI protocol. In this
client-server protocol, the Responder plays the server role and the SSS
Client plays the client role. On the client side, the SSS_CLI protocol
code is common among all the various types of SSS Clients (e.g. NSS
Client, PAM Client); this client-side code can be found at
sss_client/common.c. On the server side, the SSS_CLI protocol code is
common among all the various types of Responders (e.g. NSS Responder,
PAM Responder); this server-side code can be found at
responder_common.c</p>
<p>SSS_CLI is a request/response protocol that communicates over raw Unix
Domain Sockets, using its own TLV-encoding. Note that the SSS Client
only supports synchronous I/O, so it may block (e.g. while waiting for a
response). On the other hand, the Responder supports asynchronous I/O
using its tevent main loop, so it will not block (e.g. while waiting to
read from a client).</p>
<p>On the server side, the commands supported by the Responder will vary
depending on the type of Responder. The commands supported by the NSS
Responder are defined in nsssrv_cmd.c, while the commands supported by
the PAM Responder are defined in pamsrv_cmd.c.</p>
<p>On the client side, the commands available to all SSS Clients are
defined by an sss_cli_command enumeration in sss_cli.h. The SSS
Client&#8217;s request message essentially consists of this command, along
with various command-relevant data (e.g. command=SSS_PAM_AUTHENTICATE,
data=username/password). The response message essentially consists of
the same command, along with the reply data, and an errno value. The
encoding formats of the request and response messages are defined in
common.c. The SSS Client calls sss_cli_send_req in order to send the
request, and sss_cli_recv_rep in order to receive the reply.</p>
<p>Note that the SSS Client and Responder reference the same header file
(sss_cli.h) for command names. Indeed, it is the shared command name
(e.g. SSS_PAM_AUTHENTICATE) that ties the SSS Client and Responder
together.</p>
</div>
<div class="section" id="nss-client">
<h3>7.2.2. NSS Client<a class="headerlink" href="#nss-client" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, the API supported by the NSS Client is defined in
sss_nss.exports. It includes settors/gettor for several name databases
(e.g. passwd, group, etc). While these functions take different input
arguments, they all return an nss_status enumeration (e.g. SUCCESS,
UNAVAIL, NOTFOUND, TRYAGAIN, etc).</p>
<p>When a caller (i.e. SSS Client Application) calls one of these
functions, the NSS Client determines if the request is related to the
passwd or group database. If so, the NSS Client consults the memcache
(i.e. Fast Cache) to see if the request can be fulfilled immediately. If
not, or if the cache entry is not valid, the NSS client extracts the
caller&#8217;s arguments, creates a request message, and uses common client
functions to interact with an NSS Responder. After it receives a
response, it extracts the status and results (e.g. struct passwd), and
returns them to the caller.</p>
</div>
<div class="section" id="pam-client">
<h3>7.2.3. PAM Client<a class="headerlink" href="#pam-client" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, the API supported by the PAM Client is defined in
pam_sss.c. It includes a set of functions, each of which takes a
pam_handle object as input, and returns an integer representing the
pam_status. These functions include:</p>
<p>When a caller (i.e. an SSS Client Application) calls ones of these
functions, the PAM Client extracts the caller&#8217;s arguments (e.g.
pam_user) from the pam handle, prompts the caller for a password (if
needed), and creates a request message using common client functions to
interact with a PAM Responder. After it receives a response, it extracts
the pam_status from the response. At this point, if the pam_status is
PAM_SUCCESS, then PAM Client simply returns PAM_SUCCESS to the caller,
which can expect that the operation was successful. If not successful,
the PAM Client&#8217;s behavior will depend on the particular pam_status
(e.g. display error message, etc).</p>
<p>One complication that arises is when a user is successfully
authenticated (after contacting the AD Server), but the user&#8217;s password
has expired. Since the authentication succeeds, the PAM Client&#8217;s
authentication code would normally ignore the fact that the password has
expired, knowing that the account management code would discover this
for itself (but only after contacting the AD Server). However, since we
already have this information at the time of authentication, we optimize
the situation by having the authentication code set a flag in the pam
handle (for consumption by the account management code) indicating that
the user&#8217;s password has expired (and there is no need to contact the AD
Server again to establish this fact).</p>
</div>
</div>
<div class="section" id="responder">
<h2>7.3. Responder<a class="headerlink" href="#responder" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the common functionality shared by both NSS
and PAM Responders. Subsequent sections will discuss Responder-specific
functionality.</p>
<p>The role of a Responder is:</p>
<ul class="simple">
<li>to receive request messages from a matching SSS Client</li>
<li>to fulfill the requests in one of two ways, by either:<ul>
<li>directly retrieving a valid cached result from the sysdb Cache, or</li>
<li>asking the Backend to update the sysdb Cache (e.g. after
contacting the remote AD server), and then retrieving an
up-to-date result from the sysdb Cache</li>
</ul>
</li>
<li>to send back response messages to the matching SSS Client</li>
</ul>
<div class="section" id="resp-ctx">
<h3>7.3.1. resp_ctx<a class="headerlink" href="#resp-ctx" title="Permalink to this headline">¶</a></h3>
<p>The (Generic) Responder&#8217;s context (resp_ctx) is created at startup by
sss_process_init(). The resp_ctx data structure represents a common
set of Responder information that is referenced by a number of other
responder-related data structures. At startup, an NSS Responder or PAM
Responder calls nss_process_init() or pam_process_init(), which both
internally call sss_process_init() with Responder-specific arguments.
Note that some fields of the resp_ctx apply only to the Responder&#8217;s
client-facing interface, some fields apply only to the Responder&#8217;s
backend-facing interface, and some fields apply to both. When
sss_process_init() is called, the actions that take place include:</p>
<ul class="simple">
<li>retrieving config information from the confdb (including all domain
stanzas)</li>
<li>registering the Responder with the Monitor, by sending it a
RegisterService SBus message</li>
<li>registering the Responder with the Backend, by sending it a
RegisterService SBus message</li>
<li>initializing connections to each per-domain sysdb cache (only one for
our use case)</li>
<li>creating a socket and listening for client connections</li>
<li>creating a dp request hash table (an optimization technique discussed
later)</li>
</ul>
</div>
<div class="section" id="client-facing-interactions-generic">
<h3>7.3.2. Client-Facing Interactions (Generic)<a class="headerlink" href="#client-facing-interactions-generic" title="Permalink to this headline">¶</a></h3>
<p>As mentioned earlier, an SSS Client communicates with its matching
Responder using our SSS_CLI protocol. In order to set up a listening
server socket, the Responder retrieves an fd by calling
set_unix_socket, (which internally makes the standard socket, bind,
listen calls), and which then registers the fd with the main loop (along
with its accept_fd_handler, and READ flag). Once the Responder
receives a connection from an SSS Client, the main loop dutifully calls
accept_fd_handler, which, in turn, calls the standard accept call,
which returns a new fd for message traffic, and registers the new fd
with the main loop (along with its client_fd_handler and READ flag).
This new fd (and client_fd_handler) will be used for the duration of
the connection, while the original fd remains listening for new
connections. When the SSS Client sends a request message to the
Responder, the main loop notices that the Responder&#8217;s client socket is
ready for READ, and calls client_fd_handler, which results in
client_recv being called. After processing the command (i.e. consulting
cache, forwarding to backend, etc), the Responder registers the fd with
the main loop (along with its client_fd_handler, but this time, with a
WRITE flag). When the socket is available for writing, the main loop
calls client_fd_handler, which, this time (as a result of the WRITE
flag), calls client_send to send a response to the SSS Client.</p>
<p>As opposed to the resp_ctx object (which represents the entire
Responder process), the cli_ctx object (client_context) represents
per-client information. For example, the single file descriptor which
listens for connections from SSS Clients is stored in the resp_ctx,
while the per-client information (such as the file descriptor used to
exchange data with a client, a client&#8217;s request/response messages, etc)
is stored in cli_ctx.</p>
</div>
<div class="section" id="common-optimization-techniques">
<h3>7.3.3.Common Optimization Techniques<a class="headerlink" href="#common-optimization-techniques" title="Permalink to this headline">¶</a></h3>
<p>Much of a Responder&#8217;s functionality has to do with implementing
performance-enhancing optimizations. In addition to the sysdb system
cache, there are several additional optimizations used in the Responder
code. In this section, we examine the optimizations that are common to
both the NSS and PAM Responder. Responder-specific optimizations will be
discussed in their corresponding sections. After receiving an SSS Client
request, both Responders only resort to making SBus method calls to the
Backend if none of the optimization techniques they support can fulfill
the request.</p>
<p>A Data Provider request table (dp_request_table) hashtable is
maintained by a Responder to prevent it from sending identical requests
to the Backend. For example, when a user logs in to a local machine,
several different programs may call <em>getpwnam(“aduser”)</em> in order to
retrieve the user&#8217;s uid and gid. Assuming an empty sysdb cache, the
first such request received by a Responder will be sent over SBus to the
Backend and the request will be stored in the Responder&#8217;s
dp_request_table. If a second <strong>identical</strong> request is received by the
Responder, the Responder will notice that an existing request for the
same information is already in progress, and it will register the second
request (and any subsequent identical requests) to be called back when
the results are ready (so that they receive the same reply information).
Note that a dp_request_table is an in-memory data structure, resulting
in the NSS Responder and PAM Responder processes maintaining their own
separate dp_request_tables.</p>
</div>
</div>
<div class="section" id="nss-responder">
<h2>7.4. NSS Responder<a class="headerlink" href="#nss-responder" title="Permalink to this headline">¶</a></h2>
<p>This section examines the commands and optimization techniques supported
by the NSS Responder, as well as its overall code flow.</p>
<div class="section" id="nss-ctx">
<h3>7.4.1. nss_ctx<a class="headerlink" href="#nss-ctx" title="Permalink to this headline">¶</a></h3>
<p>The NSS Responder&#8217;s context (nss_ctx) is created at startup by
nss_process_init(), which takes several actions, including:</p>
<ul class="simple">
<li>calling sss_process_init() with Responder-specific arguments,
including supported commands and supported SBus methods</li>
<li>initializing idmap_ctx</li>
<li>initializing Responder-specific optimizations (see NSS Optimizations
section)</li>
<li>retrieving Responder-specific config information from the confdb</li>
</ul>
</div>
<div class="section" id="client-facing-interactions-nss">
<h3>7.4.2. Client-Facing Interactions (NSS)<a class="headerlink" href="#client-facing-interactions-nss" title="Permalink to this headline">¶</a></h3>
<p>The commands supported by the NSS Responder are defined in
nsssrv_cmd.c. These commands (and their inputs) are extracted from the
packet sent to the Responder by the SSS Client. After processing the
command, the NSS Responder returns a packet to the SSS Client containing
command output and/or an error message. As such, each command has its
own name, function, input, and output (very similar to a function
prototype). For example, if the SSS Client Application is making a call
with the function prototype of: struct passwd *getpwnam(foo_name),
then the SSS Client sends a packet to the Responder containing the input
(foo_name), along with an integer representing the command name
(getpwnam); and the SSS Client expects to receive a packet from the
Responder containing the same command integer, the output (struct
passwd), as well as a status code.</p>
</div>
<div class="section" id="backend-facing-interactions-nss">
<h3>7.4.3. Backend-Facing Interactions (NSS)<a class="headerlink" href="#backend-facing-interactions-nss" title="Permalink to this headline">¶</a></h3>
<p>The NSS Responder communicates with the Backend using a single SBus
method named <em>getAccountInfo</em>. For <em>getAccountInfo</em>, the outgoing SBus
request message is constructed by sss_dp_get_account_msg and “sent”
by sbus_conn_send. The incoming SBus reply message is “received” by
sss_dp_get_reply.</p>
</div>
<div class="section" id="code-flow-nss">
<h3>7.4.4. Code Flow (NSS)<a class="headerlink" href="#code-flow-nss" title="Permalink to this headline">¶</a></h3>
<p>This section examines the NSS Responder&#8217;s code flow. As with most of the
code, an NSS Responder&#8217;s basic code-flow has a “send” phase and a “recv”
phase. In the “send” phase, the NSS Responder reads a packet from the
client socket, processes it, and, assuming no optimization, writes an
SBus message to the backend socket (or “be socket”). In the “recv”
phase, the NSS Responder reads the SBus message reply from the backend
socket, processes the reply (which typically includes getting the actual
result from the updated Cache), and writes a reply packet to the client
socket. Of course, the contents of the incoming and outgoing client
packets, as well as the contents of the outgoing and incoming SBus
messages are command-specific. Note that the same responder-specific
search function (which has been underlined below) is called twice, once
for the “send” part (when check_provider = TRUE), and once for the
“recv” part (when check_provider = FALSE).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&quot;send&quot; phase (NSS: getAccountInfo)

  main loop notices client socket is READABLE; calls client_fd_handler

 handler receives packet on client socket           // client_recv: uses read syscall
 extracts command from packet                       // sss_packet_get_cmd
 executes function that matches command             // sss_cmd_execute
 extracts command-specific input from packet            // e.g. username
  calls command-specific search function (“send” part)
 tries to fulfill request using NSS Responder optimizations
 creates SBus message for Backend               // sss_dp_get_account_msg
 enqueues request (adds tevent_fd[WRITE] to ev)         // sss_dp_internal_get_send
 returns control to main loop

 main loop notices be socket is WRITEABLE; calls sbus_watch_handler
 handler writes SBus message on backend socket              // client_send: uses write syscall
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>&quot;recv&quot; phase (NSS: getAccountInfo)

  main loop notices be socket is readable; calls  sss_dp_internal_get_done

 handler extracts arguments from reply message          //  sss_dp_get_reply
 performs error processing (if needed)
  calls command-specific search function (“recv” part)
 retrieves updated information from sysdb cache         //  sysdb_getpwnam
 sets responder-specific optimizations (for next time)
 modifies existing client socket&#39;s flags, so that it is WRITEABLE

  main loop notices client socket is writeable; calls  client_fd_handler

  handler writes reply packet on client socket          //  client_send
</pre></div>
</div>
</div>
<div class="section" id="optimization-techniques-nss">
<h3>7.4.5. Optimization Techniques (NSS)<a class="headerlink" href="#optimization-techniques-nss" title="Permalink to this headline">¶</a></h3>
<p>A negative cache is maintained by an NSS Responder to store information
about operations that have not been successful. For example, when
performing an identity lookup against a remote AD Server, an NSS
Responder may determine that no such identity exists. At that point, an
NSS Responder would put that information into its negative cache for
some period of time (configurable with the entry_negative_timeout
field). If a subsequent request came in within that time period for the
same identity lookup, the NSS Responder would immediately return a
result to the client indicating that no such identity exists (without
going to the Backend). Since a negative cache is intended for identity
lookups, it would seem that it should be also be used by the PAM
Responder when it is looking up identities (i.e. when it is calling
initgroups). WhilE this is not currently the case, it is expected that
the PAM Responder will start using the negative cache in the near
future. Note that a negative cache is an in-memory data structure.</p>
<p>A Fast Cache is a set of memory-mapped cache files, from which an SSS
Client can retrieve identity (NSS) information without having to contact
the NSS Responder. This was described earlier in the document.</p>
</div>
</div>
<div class="section" id="pam-responder">
<h2>7.5. PAM Responder<a class="headerlink" href="#pam-responder" title="Permalink to this headline">¶</a></h2>
<p>This section examines the commands and optimization techniques supported
by the PAM Responder, as well as its overall code flow. Regardless of
the PAM request sent by the SSS Client (e.g. pam_authenticate), the PAM
responder always starts by determining the user&#8217;s group memberships. It
does this by internally calling initgroups on each domain stanza, until
it finds a match. Once a match is found, the PAM Responder knows which
domain to use, which identity to use, and the groups to which the
identity belongs. In our use case, there is only a single domain, so if
calling initgroups against our domain fails, then the whole client
request fails. Note that the presence of subdomains makes this more
complicated, but that has been discussed earlier in the document.</p>
<div class="section" id="pam-ctx">
<h3>7.5.1. pam_ctx<a class="headerlink" href="#pam-ctx" title="Permalink to this headline">¶</a></h3>
<p>The PAM Responder&#8217;s context (pam_ctx) is created at startup by
pam_process_init(), which takes several actions, including:</p>
<ul class="simple">
<li>calling sss_process_init with Responder-specific arguments,
including supported commands</li>
<li>initializing Responder-specific optimizations (see Optimizations
section)</li>
<li>retrieving Responder-specific config information from the confdb</li>
</ul>
</div>
<div class="section" id="client-facing-interactions-pam">
<h3>7.5.2. Client-Facing Interactions (PAM)<a class="headerlink" href="#client-facing-interactions-pam" title="Permalink to this headline">¶</a></h3>
<p>The commands supported by the PAM Responder are defined in
pamsrv_cmd.c. These commands (and their inputs) are extracted from the
packet sent to the Responder by the SSS Client. After processing the
command, the PAM Responder returns a packet to the SSS Client containing
command output and/or an error message. As such, each command has its
own name, function, input, and output (very similar to a function
prototype). For example, if the SSS Client Application is making a call
with the function prototype of: int pam_authenticate(pamh, flags), then
the SSS Client sends a packet to the Responder containing the command
name (pam_authenticate) and input (username); and the SSS Client
expects to receive a packet from the Responder containing the command
name (pam_authenticate), the output (e.g. user_info, text_message,
etc), as well as a status code.</p>
</div>
<div class="section" id="backend-facing-interactions-pam">
<h3>7.5.3. Backend-Facing Interactions (PAM)<a class="headerlink" href="#backend-facing-interactions-pam" title="Permalink to this headline">¶</a></h3>
<p>The PAM Responder communicates with the Backend using two SBus methods:
<em>getAccountInfo</em> (for initgroups) and <em>pamHandler</em> (for pam-related
functionality). The <em>getAccountInfo</em> request message is identical to
that discussed in the NSS Responder section, except that the operation
to perform (be_type) is always INITGROUPS. As such, we will only
examine the <em>pamHandler</em> SBus message in this section.</p>
<p>For <em>pamHandler</em>, the outgoing SBus request message is constructed by
pam_dp_send_req and “sent” by sbus_conn_send. The incoming SBus
reply message is “received” by sss_dp_get_reply.</p>
</div>
<div class="section" id="code-flow-pam">
<h3>7.5.4. Code Flow (PAM)<a class="headerlink" href="#code-flow-pam" title="Permalink to this headline">¶</a></h3>
<p>This section examines the PAM Responder&#8217;s code flow. The code flow for
<em>getAccountInfo</em> is very similar to that discussed in the NSS Responder
section. In this section, we will focus on examining <em>pamHandler</em>&#8216;s code
flow (which begins with the end of <em>getAccountInfo</em>&#8216;s flow). However,
for the sake of clarity, we show the entire code flow, including both
<em>getAccountInfo</em> and <em>pamHandler</em>.</p>
<p>The differences between the NSS:<em>getAccountInfo</em> and
PAM:<em>getAccountInfo</em> are as follows:</p>
<ul class="simple">
<li>PAM code uses PAM Responder-specific optimizations (not NSS
Responder-specific ones)</li>
<li>PAM code uses a different “search” function</li>
<li>PAM code doesn&#8217;t return a reply packet to the SSS Client after
getting the initgroups result; rather, it makes a second SBus method
call (<em>pamHandler</em>)</li>
</ul>
<p>** &#8220;send&#8221; phase (PAM: <em>getAccountInfo</em>) **</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">client</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">READABLE</span><span class="p">;</span> <span class="n">calls</span> <span class="n">client_fd_handler</span>
</pre></div>
</div>
<ol class="arabic">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">receives</span> <span class="n">packet</span> <span class="n">on</span> <span class="n">client</span> <span class="n">socket</span>  <span class="o">//</span> <span class="n">client_recv</span><span class="p">:</span> <span class="n">uses</span> <span class="n">read</span> <span class="n">syscall</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">extracts</span> <span class="n">command</span> <span class="kn">from</span> <span class="nn">packet</span>          <span class="o">//</span> <span class="n">sss_packet_get_cmd</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">executes</span> <span class="n">function</span> <span class="n">that</span> <span class="n">matches</span> <span class="n">command</span>        <span class="o">//</span> <span class="n">sss_cmd_execute</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">extracts</span> <span class="n">command</span><span class="o">-</span><span class="n">specific</span> <span class="nb">input</span> <span class="kn">from</span> <span class="nn">packet</span>   <span class="o">//</span> <span class="n">e</span><span class="o">.</span><span class="n">g</span><span class="o">.</span> <span class="n">username</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span>calls pam_check_user_search (“send” part)
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">tries</span> <span class="n">to</span> <span class="n">fulfill</span> <span class="n">request</span> <span class="n">using</span> <span class="n">responder</span><span class="o">-</span><span class="n">specific</span> <span class="n">optimizations</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">creates</span> <span class="n">SBus</span> <span class="n">message</span> <span class="k">for</span> <span class="n">Backend</span>      <span class="o">//</span> <span class="n">sss_dp_get_account_msg</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">enqueues</span> <span class="n">request</span> <span class="p">(</span><span class="n">adds</span> <span class="n">tevent_fd</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]</span> <span class="n">to</span> <span class="n">ev</span><span class="p">)</span>    <span class="o">//</span> <span class="n">sss_dp_internal_get_send</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">returns</span> <span class="n">control</span> <span class="n">to</span> <span class="n">main</span> <span class="n">loop</span>
</pre></div>
</div>
</li>
</ol>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">be</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">WRITEABLE</span><span class="p">;</span> <span class="n">calls</span> <span class="n">sbus_watch_handler</span>
</pre></div>
</div>
<ol class="arabic" start="10">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">writes</span> <span class="n">SBus</span> <span class="n">message</span> <span class="n">on</span> <span class="n">backend</span> <span class="n">socket</span> <span class="o">//</span> <span class="n">client_send</span><span class="p">:</span> <span class="n">uses</span> <span class="n">write</span> <span class="n">syscall</span>
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><strong>“recv” phase (PAM: *getAccountInfo* )</strong></div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">be</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">readable</span><span class="p">;</span> <span class="n">calls</span> <span class="n">sss_dp_internal_get_done</span>
</pre></div>
</div>
<ol class="arabic">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">extracts</span> <span class="n">arguments</span> <span class="kn">from</span> <span class="nn">reply</span> <span class="n">message</span>    <span class="o">//</span>  <span class="n">sss_dp_get_reply</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">performs</span> <span class="n">error</span> <span class="n">processing</span> <span class="p">(</span><span class="k">if</span> <span class="n">needed</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">calls</span>  <span class="n">pam_check_user_search</span>  <span class="p">(</span><span class="n">recv</span> <span class="n">part</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">retrieves</span> <span class="n">updated</span> <span class="n">information</span> <span class="kn">from</span> <span class="nn">sysdb</span> <span class="n">cache</span>   <span class="o">//</span>  <span class="n">sysdb_getpwnam</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">ets</span> <span class="n">responder</span><span class="o">-</span><span class="n">specific</span> <span class="n">optimizations</span> <span class="p">(</span><span class="k">for</span> <span class="nb">next</span> <span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">calls</span>  <span class="n">pam_dom_forwarder</span>
</pre></div>
</div>
</li>
</ol>
<p><strong>&#8220;send&#8221; phase (*pamHandler*)</strong></p>
<p><strong>pam_check_user_search (recv part) returns; code calls
pam_dom_forwarder</strong></p>
<ol class="arabic">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">creates</span> <span class="n">SBus</span> <span class="n">message</span> <span class="k">for</span> <span class="n">Backend</span>             <span class="o">//</span> <span class="n">pam_dp_send_req</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">enqueues</span> <span class="n">request</span> <span class="p">(</span><span class="n">adds</span> <span class="n">tevent_fd</span><span class="p">[</span><span class="n">WRITE</span><span class="p">]</span> <span class="n">to</span> <span class="n">ev</span>       <span class="o">//</span> <span class="n">pam_dp_send_req</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">returns</span> <span class="n">control</span> <span class="n">to</span> <span class="n">main</span> <span class="n">loop</span>
</pre></div>
</div>
</li>
</ol>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">be</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">WRITEABLE</span><span class="p">;</span> <span class="n">calls</span> <span class="n">sbus_watch_handler</span>
</pre></div>
</div>
<ol class="arabic" start="4">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">writes</span> <span class="n">SBus</span> <span class="n">message</span> <span class="n">on</span> <span class="n">backend</span> <span class="n">socket</span>            <span class="o">//</span> <span class="n">client_send</span><span class="p">:</span> <span class="n">uses</span> <span class="n">write</span> <span class="n">syscall</span>
</pre></div>
</div>
</li>
</ol>
<blockquote>
<div><strong>&#8220;recv&#8221; phase (*pamHandler*)</strong></div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">be</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">readable</span><span class="p">;</span> <span class="n">calls</span> <span class="n">pam_dp_process_reply</span>
</pre></div>
</div>
<ol class="arabic" start="5">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">extracts</span> <span class="n">arguments</span> <span class="kn">from</span> <span class="nn">reply</span> <span class="n">message</span>       <span class="o">//</span> <span class="n">dp_unpack_pam_response</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">construct</span> <span class="n">reply</span> <span class="n">massage</span>                     <span class="o">//</span> <span class="n">pam_reply</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">performs</span> <span class="n">error</span> <span class="n">processing</span> <span class="p">(</span><span class="k">if</span> <span class="n">needed</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">sets</span> <span class="n">responder</span><span class="o">-</span><span class="n">specific</span> <span class="n">optimizations</span> <span class="p">(</span><span class="k">for</span> <span class="nb">next</span> <span class="n">time</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">modifies</span> <span class="n">existing</span> <span class="n">client</span> <span class="n">socket</span><span class="s1">&#39;s flags, so that it is WRITEABLE</span>
</pre></div>
</div>
</li>
</ol>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">NSS</span><span class="p">:</span> <span class="n">main</span> <span class="n">loop</span> <span class="n">notices</span> <span class="n">client</span> <span class="n">socket</span> <span class="ow">is</span> <span class="n">writeable</span><span class="p">;</span> <span class="n">calls</span> <span class="n">client_fd_handler</span>
</pre></div>
</div>
<ol class="arabic" start="10">
<li><div class="first highlight-default"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="n">writes</span> <span class="n">reply</span> <span class="n">packet</span> <span class="n">on</span> <span class="n">client</span> <span class="n">socket</span>        <span class="o">//</span> <span class="n">client_send</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="optimization-techniques-pam">
<h3>7.5.5. Optimization Techniques (PAM)<a class="headerlink" href="#optimization-techniques-pam" title="Permalink to this headline">¶</a></h3>
<p>The Initgroups Cache (id_table) is maintained by the PAM Responder in
order to store initgroups information for some (usually very short)
period of time (configurable with the pam_id_timeout field) . While
the PAM Responder does not initially consult the sysdb cache before
going to the Backend, the PAM Responder does initially consult the
intigroups cache. If it finds a valid entry in the initgroups cache, the
PAM Responder does not send an internal initgroups request to the
Backend. The reason for this cache is that a full PAM conversation
typically includes multiple PAM requests sent by an SSS Client in quick
succession (one for authentication, another for account management,
etc). Having the Responder send a separate initgroups request for each
PAM request would be inefficient and unnecessary. Note that the
initgroups cache is an in-memory data structure used by the PAM
Responder. This mechanism is not used by the NSS Responder.</p>
</div>
</div>
<div class="section" id="optimizations-code-flow">
<h2>7.6. Optimizations Code Flow<a class="headerlink" href="#optimizations-code-flow" title="Permalink to this headline">¶</a></h2>
<p>Having discussed both NSS and PAM Optimizations, this section walks
through a couple of flowcharts showing how these optimizations come into
play in the code flow. These flow charts only cover the optimizations
performed during the “send” and “recv” phase of identity lookups (i.e.
NSS Responder and initgroups part of PAM Responder), not authentication
or other pam-related functionality. We first look at optimizations
performed during the “send” phase and then at optimizations performed
(or set for next time) during the “receive” phase.</p>
<p><em>Optimizations performed during the &#8220;send&#8221; phase</em></p>
<p>While the flowchart is fairly self-explanatory, there are a few things
to note:</p>
<ul class="simple">
<li>flowchart assumes that the function matching a client command has
been executed, and we are now seeing if we can avoid going to the
Backend using these optimization techniques</li>
<li>if there is a valid entry in the initgroups cache, that is a good
thing (list of group memberships)</li>
<li>if there is a valid entry in the negative cache, that is a bad thing
(“user didn&#8217;t exist last time”)</li>
<li>if there isn&#8217;t a valid entry in the initgroups cache, it does not
consult the sysdb Cache</li>
<li>the dp_request_table optimization is only used if there are dp
requests to be made (i.e. our optimizations have failed and message
needs to be sent to the Backend).</li>
<li>all dp requests (even the first one) are registered as callbacks</li>
</ul>
<p><em>Optimizations performed during the &#8220;recv&#8221; phase</em></p>
<p>While the flowchart is fairly self-explanatory, there are a few things
to note:</p>
<ul class="simple">
<li>each of the registered callbacks receives their own copy of the
return args</li>
<li>if the PAM Responder finds a valid entry in sysdb cache, it adds
entry to initgroups_cache</li>
<li>NSS Responder again checks if entry should be dismissed because it
exists in the negative cache</li>
<li>if NSS Responder does not find a valid entry in sysdb cache, it adds
an entry to the negative cache, and deletes an entry from the
memcache (fast cache).</li>
<li>the memcache is not being updated anywhere here (it only gets updated
when the Backend sends an initgrCheck SBus message to the NSS
Responder).</li>
</ul>
</div>
<div class="section" id="backend">
<h2>7.7. Backend<a class="headerlink" href="#backend" title="Permalink to this headline">¶</a></h2>
<p>In this section, we describe the functionality of a Backend, which
represent a domain stanza (e.g. [domain/foo.com]. Recall that a domain
stanza specifies the individual Provider Plugins to be used for each
provider type, as well as information needed to access the remote server
(e.g. ad_domain=foo.com). As such, for each domain stanza in the
configuration, the Monitor spawns a separate Backend process, and each
Backend process dynamically loads its configured provider plugins. The
role of a provider plugin is to provide plugin-specific implementations
of generic functions (bet_ops) used to handle request messages, to
perform check_online operations, and to perform finalize operations.
Additionally, a provider plugin retrieves plugin-specific configuration
(pvt_bet_data), which it passes to each of the above functions.</p>
<p>The role of a Backend (aka “Data Provider”) is:</p>
<ul class="simple">
<li>to receive SBus request messages from Backend clients (e.g.
Responders)</li>
<li>to fulfill the requests, by calling the appropriate function
registered by a Provider Plugin</li>
<li>to send back SBus response messages to Backend clients</li>
<li>to update the sysdb Cache with fresh results from the remote server</li>
</ul>
<div class="section" id="backend-concepts">
<h3>7.7.1. Backend Concepts<a class="headerlink" href="#backend-concepts" title="Permalink to this headline">¶</a></h3>
<p>SSSD distinguishes between services and servers, in that a single server
(i.e. IP address) can host multiple services (i.e. ports). In the code,
a service (e.g. LDAP) is represented using an fo_service object, while
each server that supports that service is represented by fo_server
objects. A list of servers associated with a service are specified in
the configuration. For example, in our use case, an AD Provider Plugin
is capable of consuming the LDAP, GC, and KRB services on one or more AD
Servers (as specified by the ad_users and ad_backup_users
configuration fields). A Backend implements service failover by
automatically switching to a different server if a server is
unreachable.</p>
<p>If we are able to successfully resolve a server and establish an
authenticated connection, SSSD enters online mode, and that connection
can be re-used to transfer requests and responses, until the connection
expires (or we go offline).</p>
<p>If we are unable to resolve a server on the service&#8217;s list, that server
is marked offline for all services, and we try to resolve the next
server on the service&#8217;s list. If we are unable to resolve any of the
servers on the service&#8217;s list, then SSSD enters offline mode. If we are
able to resolve a server on the service&#8217;s list, we then attempt to
connect to the service (e.g. LDAP) on that server. If successful, we
continue processing. If unsuccessful, that server is marked offline, but
only for that service. Since only that one service (e.g. LDAP) is marked
offline, the other services (e.g. KRB) on that server are still
considered online. The failover mechanism then automatically tries to
connect to the same service on the next server on the service&#8217;s list of
servers. If we are unable to connect to any of the servers on the
service&#8217;s list of servers, then SSSD enters offline mode.</p>
<p>Put another way, here is the algorithm for resolving and connecting to a
service:</p>
<ol class="arabic simple">
<li>retrieve service&#8217;s list of servers</li>
<li>resolve next server on list</li>
<li>if successful, goto step 5; else, mark server offline for all
services</li>
<li>if more servers on list, goto step 2; else, SSSD enters offline mode;
DONE</li>
<li>connect to service on resolved server</li>
<li>if successful, DONE; else, mark server offline for that service</li>
<li>if more servers on list, goto step 2; else, SSSD enters offline mode;
DONE</li>
</ol>
<p>Name resolution of a server (i.e. obtaining its IP address) is
accomplished in different ways, depending on how the server is specified
in the configuration:</p>
<ul class="simple">
<li>if server specified by IP address, we&#8217;re done (no resolution is
required)</li>
<li>if server specified by hostname, we resolve the server using DNS
address records (A/AAAA)</li>
<li>if server specified with the “_srv_” string, we resolve the service
using DNS SRV records</li>
</ul>
<p>A Backend&#8217;s Provider Plugin uses the external c-ares library to
communicate with a DNS Server, in order to resolve a service&#8217;s server
names. The address of the DNS server is retrieved from /etc/resolv.conf.</p>
<p>In order to resolve a server on a service&#8217;s list, a Backend calls
be_resolve_server_send and includes the service&#8217;s name as input. This
function retrieves the list of servers (primary and secondary)
associated with the service name input. For servers that support
resolution using SRV records, the service name is resolved by calling
resolv_srv_send; otherwise, the server name is resolved by calling
fo_resolve_service_server. In either case, if the resolution is
successful, an fo_server object is returned, which includes the desired
addressing information in server_common-&gt;rhostent. If unsuccessful, the
recv function indicates that there was an error, in which case upstream
callers typically mark the server as being offline (be_mark_offline).</p>
<p>As we saw in an earlier example, a domain stanza (represented by a
Backend) includes several provider lines, such as “id_provider = ad”.
Internally, the information corresponding to a single provider line is
stored in the be_ctx as a bet_info array element, which includes the
following information:</p>
<p>The bet_ops field (and pvt_bet_data arg field) are particularly
important, as they specify the actual plug-in specific functions (and
args) that are called by the Backend to invoke plug-in specific
functionality. The bet_ops structure for each provider line contains
three plug-in specific function pointers:</p>
<ul class="simple">
<li>check_online: determines whether SSSD is in “online mode” (i.e.
whether remote server is reachable on the network); this function
pointer is only used by bet_info[BET_ID]. This function is called
by check_if_online, which uses the results of check_online to
determine whether the Backend has transitioned to “online mode”, in
which case the Backend runs any registered online callbacks. The
check_if_online function itself is called by
data_provider_res_init and data_provider_reset_offline (i.e.
the sbus_method functions that handle resInit and <em>resetOffline</em>
SBus messages, respectively).</li>
<li>handler: provides the guts of the provider type&#8217;s functionality; for
example, the handler for bet_info[BET_ID] would implement identity
lookups (e.g. contact the remote server, retrieve data, etc), while
the handler for bet_info[BET_AUTH] would implement authentication
processing.</li>
<li>finalize: used to terminate the be_req and clean up any internal
data; this is optional</li>
</ul>
<p>The provider line that specifies “id_provider = ad” indicates two
things: “id_provider” indicates that we are dealing with a bet_type of
BET_ID, and “ad” indicates that we should dynamically load
“libsss_ad.so”, and we should use the bet_ops and pvt_bet_data
specified by the AD provider plugin. In other words, “id_provider = ad”
results in the creation of the following data structure:</p>
<p>For example, our use case uses four provider lines (id_provider,
auth_provider, access_provider, and chpass_provider). These are
stored in the be_ctx as an array of bet_info data structures:</p>
<ul class="simple">
<li>bet_info[BET_ID]</li>
<li>bet_info[BET_AUTH]</li>
<li>bet_info[BET_ACCESS]</li>
<li>bet_info[BET_CHPASS]</li>
</ul>
<p>In theory, each provider line can reference a different provider plugin,
resulting in multiple libraries being dynamically loaded. For example,
“id_provider = ldap”, “auth_provider=krb5” would result in both
libsss_ldap.so and libsss_krb5.so being dynamically loaded, with
bet_info[BET_ID] populated with LDAP-specific operations, and
bet_info[BET_AUTH] populated with KRB5-specific operations. Having
said that, it is now more common to use layered provider plugins (e.g.
AD, IPA) which greatly simplify configuration for an AD or IPA
environment. Indeed, our use case is configured by specifying
“id_provider = ad” (i.e. identity lookups are handled by the AD
provider plugin) and “auth_provider = ad” (i.e. authentication
processing is handled by the AD provider plugin). In this case, only a
single library (libsss_ad.so) would be dynamically loaded, but it would
internally make calls to the same shared code used by the LDAP and KRB5
provider plugins.</p>
</div>
<div class="section" id="be-ctx">
<h3>7.7.2. be_ctx<a class="headerlink" href="#be-ctx" title="Permalink to this headline">¶</a></h3>
<p>A Backend Process has a single Backend context (be_ctx), which it
shares with the various entities internal to the Backend that need it.
The be_ctx is created at startup by be_process_init, at which time
several actions take place, including:</p>
<ul class="simple">
<li>retrieving config information from the confdb (mostly related to
Backend&#8217;s domain stanza)</li>
<li>setting up the failover service</li>
<li>initializing failover <em>allows backend to auto-switch to different
server if current server fails</em></li>
<li>initializing connection to sysdb cache for Backend&#8217;s domain stanza</li>
<li>registering the Backend with the Monitor, by sending it a
RegisterService SBus message</li>
<li>exporting sbus methods supported by the Backend (to be called by
Responders or Monitor)</li>
<li>loading and initializing provider plugins (aka Backend Modules), as
specified in configuration<ul>
<li>this includes initializing the array of bet_info structures with
plugin-specific values</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="responder-facing-interactions">
<h3>7.7.3. Responder-Facing Interactions<a class="headerlink" href="#responder-facing-interactions" title="Permalink to this headline">¶</a></h3>
<p>The Responder interacts with the Backend using SBus. For our use case,
there are three Backend clients (NSS Responder, PAM Responder, Monitor).
The SBus server running as part of the Backend is characterized by the
following:</p>
<p>When a Responder process is spawned by the monitor, it does two
Backend-related things during initialization:</p>
<ul class="simple">
<li>sends a connection request to the Backend, specifying Responder&#8217;s
sbus_interface</li>
<li>registers itself with the Backend by sending a RegisterService
message to the Backend</li>
</ul>
<p>In response to the connection request, the Backend performs generic SBus
initialization, but also performs Backend-specific SBus initialization
by calling be_client_init(conn, be_ctx), which creates a be_client
object that represents a Backend client connection (which starts off
uninitialized). This be_client object includes the conn, the be_ctx,
and a 5-second tevent_timer (by which time the Responder must identify
itself by sending a RegisterService message). This be_client object is
then set as the sbus_connections&#8217;s private data.</p>
<p>In response to the incoming RegisterService message, the corresponding
client_registration method is called (with the request message and
sbus_connection as inputs) which does the following:</p>
<ul class="simple">
<li>retrieves be_client object from sbus_connection</li>
<li>cancels the 5-second tevent timer (because the RegisterService
message has been received)</li>
<li>retrieves request args, extracted from request message (i.e. sender
name, sender version)</li>
<li>marks Backend client as initialized</li>
<li>creates a reply message that matches the request message, indicating
success</li>
<li>appends output arguments to reply message (i.e. backend version)</li>
<li>sends back reply message on same sbus_connection on which it
received the request</li>
</ul>
<p>Once initialization is complete, all Responders should be registered
with the Backend.</p>
<p>Unlike the Responders, the Monitor process (which is also a Backend
client) does not need to register itself with the Backend. This is
because the Backend has already registered itself with the Monitor, and
therefore the Backend already has access to the Monitor&#8217;s
sbus_interface.</p>
<p>A Backend is capable of receiving the SBus methods (name/function pairs)
that were exported during its startup (be_process_init). The functions
associated with each sbus method name are generic (i.e. not
provider-plugin-specific). However, each function corresponds to a
particular provider plugin type. For example, <em>getAccountInfo</em> is used
for identity lookups and is therefore associated with the identity
provider. When the Backend receives an SBus message that targets one of
its sbus_method names, the Backend executes the corresponding generic
function. In turn, this generic function executes the handler function
registered for the particular provider plugin type associated with this
SBus method. For example, since <em>getAccountInfo</em> is associated with the
identity provider (i.e. BET_ID), we would extract its handler function
from bet_info[BET_ID]-&gt;bet_ops-&gt;handler (which was registered by
be_process_init). We would also extract the argument with which to
call the handler from bet_info[BET_ID]-&gt;pvt_bet_data.</p>
<p>Since our use case uses only the NSS and PAM Responders, we will only be
looking at the SBus methods sent by those Responders: <em>getAccountInfo</em>
(for identity lookups) and <em>pamHandler</em> (for pam-related functionality).</p>
<ul class="simple">
<li>sbus_method name: “<em>getAccountInfo</em>”<ul>
<li>generic function: be_get_account_info</li>
<li>provider_plugin type: BET_ID</li>
<li>plugin/type-specific handler function:
bet_info[BET_ID]-&gt;bet_ops-&gt;handler</li>
<li>plugin/type-specific handler argument:
bet_info[BET_ID]-&gt;pvt_bet_data</li>
</ul>
</li>
<li>sbus_method_name: “<em>pamHandler</em>”<ul>
<li>generic function: be_pam_handler</li>
<li>provider_plugin type: BET_AUTH</li>
<li>plugin/type-specific handler function:
bet_info[BET_AUTH]-&gt;bet_ops-&gt;handler</li>
<li>plugin/type-specific handler argument:
bet_info[BET_AUTH]-&gt;pvt_bet_data</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="ad-provider-plugin">
<h2>7.8. AD Provider Plugin<a class="headerlink" href="#ad-provider-plugin" title="Permalink to this headline">¶</a></h2>
<p>The AD Provider Plugin supports the following provider types, which are
initialized by corresponding functions in ad_init.c:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">id_provider</span>        <span class="o">//</span> <span class="n">initialized</span> <span class="n">by</span> <span class="n">sssm_ad_id_init</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">auth_provider</span>          <span class="o">//</span> <span class="n">initialized</span> <span class="n">by</span> <span class="n">sssm_ad_auth_init</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">chpass_provider</span>        <span class="o">//</span> <span class="n">initialized</span> <span class="n">by</span> <span class="n">sssm_ad_chpass_init</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">access_provider</span>        <span class="o">//</span> <span class="n">initialized</span> <span class="n">by</span> <span class="n">sssm_ad_access_init</span>
</pre></div>
</div>
<p>The ad_options global variable is used to maintain the configuration
options for the various provider types supported by the AD Provider
Plugin. This includes:</p>
<ul class="simple">
<li>basic configuration: ad_domain, ad_server, krb5_keytab,
ad_enable_dns_sites, etc</li>
<li>id_provider configuration: sdap service, gc service, etc</li>
<li>auth/chpass_provider configuration: principal name, service name,
keytab_name, krb5 service</li>
<li>dynamic dns updates configuration</li>
</ul>
<p>Since our use case uses the AD Provider Plugin for all provider lines,
each bet_info array will be populated with the following AD-specific
information:</p>
<ul class="simple">
<li>bet_info[BET_ID]<ul>
<li>bet_ops: ad_id_ops</li>
<li>pvt_bet_data: ad_options.id_ctx</li>
</ul>
</li>
<li>bet_info[BET_AUTH]<ul>
<li>bet_ops: ad_auth_ops</li>
<li>pvt_bet_data: ad_options.auth_ctx</li>
</ul>
</li>
<li>bet_info[BET_CHPASS]<ul>
<li>bet_ops: ad_chpass_ops</li>
<li>pvt_bet_data: ad_options.auth_ctx</li>
</ul>
</li>
<li>bet_info[BET_ACCESS]<ul>
<li>bet_ops: ad_access_ops</li>
<li>pvt_bet_data: access_ctx</li>
</ul>
</li>
</ul>
<p>The remainder of this section will examine each provider line in turn,
focussing on the functionality implemented by each line&#8217;s bet_ops
functions. Note that the first three provider lines use fields from
ad_options as the pvt_bet_data argument that is passed in to the
corresponding bet_ops functions.</p>
<div class="section" id="ad-provider-plugin-id-provider">
<h3>7.8.1. AD Provider Plugin: id_provider<a class="headerlink" href="#ad-provider-plugin-id-provider" title="Permalink to this headline">¶</a></h3>
<p>In this section, we examine the AD Provider Plugin&#8217;s implementation of
the id_provider type, including the AD-specific bet_ops and
pvt_bet_data that are used. Unlike the other provider types, the
bet_ops for the id_provider type includes values set for the
check_online and finalize function pointers.</p>
<ul class="simple">
<li>bet_ops:<ul>
<li>check_online: ad_check_online</li>
<li>handler: ad_account_info_handler</li>
<li>finalize: ad_shutdown</li>
</ul>
</li>
<li>pvt_bet_data: ad_opts.id_ctx (of type ad_id_ctx)</li>
</ul>
<p>The ad_id_ctx is created as part of the initialization that takes
place when the AD Provider Plugin is dynamically loaded for an
id_provider line, at which time several actions take place, including:</p>
<ul class="simple">
<li>retrieving relevant config info</li>
<li>initializing failover</li>
<li>initialized dynamic dns updates</li>
<li>setting up sdap child process</li>
<li>setting up various sdap options</li>
<li>setting up tasks</li>
<li>setting up id mapping object</li>
<li>setting up tls</li>
<li>setting up srv lookup plugin</li>
<li>setting up periodic refresh of expired records</li>
</ul>
<p>This function is used to fulfill an identity lookup request. In this
section, we will use getpwnam(“<a class="reference external" href="mailto:aduser&#37;&#52;&#48;foo&#46;com">aduser<span>&#64;</span>foo<span>&#46;</span>com</a>”) as our example. It is
called by be_get_account_info, which is the generic sbus_method
function that handles <em>getAccountInfo</em> messages, the details of which
have been previously discussed.</p>
<p>This function is called with a be_req input argument, from which it
extracts two important things:</p>
<ul class="simple">
<li>ad_id_ctx, which includes relevant config info, etc</li>
<li>be_acct_req, which includes the input values sent in the SBus
request message (entry_type, attr_type, filter and domain).</li>
</ul>
<p>Next, an entry_type-specific function is called (e.g.
users_get_send), which does the following:</p>
<ul class="simple">
<li>creates an sdap_id_op object to represent the operation request
(using sdap_id_op_create)</li>
<li>establishes LDAP connection by sending a connection request (or
re-uses existing connection)<ul>
<li>multi-step process, including resolving, connecting, and binding
to an LDAP server</li>
</ul>
</li>
<li>sends an operation request (and receives response) over the LDAP
connection<ul>
<li>performs ldap search using the be_acct_req fields as input
params (sdap_get_generic_send).</li>
</ul>
</li>
</ul>
<p>This function determines whether the Backend is in “online mode”. This
function is called with a be_req input argument, from which it extracts
the ad_id_ctx, after which it attempts to connect to the LDAP server.
If the LDAP server is reachable, this function sets its output to
DP_ERR_OK; otherwise, it sets its output to DP_ERR_OFFLINE.</p>
</div>
<div class="section" id="ad-provider-plugin-auth-provider-and-chpass-provider">
<h3>7.8.2. AD Provider Plugin: auth_provider and chpass_provider<a class="headerlink" href="#ad-provider-plugin-auth-provider-and-chpass-provider" title="Permalink to this headline">¶</a></h3>
<p>Since the auth_provider and chpass_provider for the AD Provider Plugin
have many similarities, we will discuss them together in this section.
Both providers use the same bet_ops and pvt_bet_data.</p>
<ul class="simple">
<li>bet_ops:<ul>
<li>handler: krb5_pam_handler</li>
</ul>
</li>
<li>pvt_bet_data: ad_opts.auth_ctx (of type krb5_auth_ctx)</li>
</ul>
<p>The krb5_auth_ctx is created as part of the initialization that takes
place when the AD Provider Plugin is dynamically loaded for an
auth_provider line or chpass provider line, at which time several
actions take place, including:</p>
<ul class="simple">
<li>retrieving relevant config info</li>
<li>forcing krb5_servers to match ad_servers</li>
<li>forcing krb5_realm to match ad_krb5_realm</li>
<li>setting up krb5 child process</li>
</ul>
<p>This function is used to fulfill an authentication request, or to
fulfill a change password request. For these requests, it is called by
be_pam_handler, which is the generic sbus_method function that
handles <em>pamHandler</em> messages, the details of which have been previously
discussed.</p>
<p>This function is called with a be_req input argument, from which it
extracts two important things:</p>
<ul class="simple">
<li>krb5_ctx, which includes relevant config info, etc</li>
<li>pam_data, which includes the many input values sent in the SBus
request message (e.g. cmd, user, authtok, etc).</li>
</ul>
<p>This function performs the following high-level tasks:</p>
<ul class="simple">
<li>retrieves several attributes for this user from the domain-specific
sysdb (e.g. upn, uid, gid, etc)</li>
<li>obtains addressing information for the KDC (which is also the kpasswd
server in AD)</li>
<li>forks a krb5_child, which will make the blocking krb5 api calls</li>
<li>performs an asynchronous write to send the appropriate request
information to the krb5_child</li>
<li>performs an asynchronous read to receive the response from the
krb5_child</li>
</ul>
<p>Next, the function calls be_resolve­_server to get the addressing
information for the KDC. Since the IP address of the LDAP service and
the KRB5 service is the same (i.e. that of the AD service), resolving
the KRB5 service may not require going to DNS, since we may already have
the information from resolving the LDAP service. Note that, in order to
make the Kerberos library aware of which IP address to use for the AD
server, we call write_krb5info_file, which writes a kdcinfo file to
the filesystem, which is later read by the Kerberos library. More info
on the kdcinfo files can be found in a separate subsection below.</p>
<p>In order to avoid blocking on synchronous Kerberos calls, this function
then spawns a krb5_child process and sends it the relevant input (e.g.
username, password, new password) using its write pipe. The krb_child
makes the appropriate Kerberos library calls (to perform the
authentication or password change), after which it returns a response to
the calling process&#8217;s read pipe, at which time the krb5_child process
exits.</p>
<div class="section" id="parent-child">
<h4>7.8.2.2.1. Parent =&gt; Child<a class="headerlink" href="#parent-child" title="Permalink to this headline">¶</a></h4>
<p>The information sent from the AD Provider Plugin to the krb5_child
process includes:</p>
<ul class="simple">
<li>cmd <em>e.g. SSS_PAM_AUTHENTICATE, SSS_PAM_CHAUTHTOK</em></li>
<li>upn <em>(from sysdb)</em></li>
<li>validate <em>whether TGT validation is desired (default: TRUE)</em></li>
<li>is_offline <em>whether SSSD is offline</em></li>
<li>send_pac <em>whether to send PAC to PAC Responder (for AD, always
TRUE)</em></li>
<li>ccname <em>credentials cache name</em></li>
<li>keytab <em>keytab name (used for TGT validation)</em></li>
<li>authtok <em>current password</em></li>
<li>newauthtok <em>new password (only used by chpass_provider; not by
auth_provider)</em></li>
</ul>
<p>For an authentication request, the krb5_child process uses the
krb5_principal (parsed from upn) and specified password to obtain
authentication credentials (i.e. TGT) from the ticket-granting service
on the AD KDC. If successful, and if validate is set to TRUE, the
krb5_child process proceeds to locally validate the TGT using the
specified keytab. As part of validation, if send_pac is set to TRUE,
the krb5_child extracts the PAC from the TGT and sends the PAC (along
with the user principal) to the PAC Responder, which decodes the PAC
information, such as group memberships from trusted domains, and updates
the System Cache accordingly. Finally, the authentication credentials
(i.e. TGT) are stored in the specified credentials cache for that
principal.</p>
<p>For a password change request, the krb5_child process also uses the
krb5_principal and password, but uses it to get change password
credentials from the password-change service on the AD KDC. If
successful, and with valid change password credentials in hand, the
krb5_child then asks the password-change service to change the password
to the specified new password, after which it obtains it sends an
authentication request (as above), by which a new TGT is obtained from
the ticket-granting service, and stored in the credentials cache for
that principal.</p>
</div>
<div class="section" id="child-parent">
<h4>7.8.2.2.2. Child=&gt;Parent<a class="headerlink" href="#child-parent" title="Permalink to this headline">¶</a></h4>
<p>While it is processing, the krb5_child process can add pam responses to
the pam_data object&#8217;s response list (resp_list), where each response
consists of a {type,length,value} tuple. It is this response_list which
is returned from the child to its parent after it has completed
processing. After receiving the responses, the parent passes the
responses back to the Responder, which passes back the responses (after
filtering some of them out) to the Client Library, which acts upon them
in some way. As such, these responses may be for consumption by the
parent, the Responder, and/or the Client Library.</p>
<p>For example, the krb5_child may wish to convey an error message to the
Client Library, indicating that a password change request has failed
(b/c the wrong password was entered for authentication). In this case,
the krb5_child would append the following response to the response
list, which the Client Library could use to display an error message to
the SSS Client Application.</p>
<ul class="simple">
<li>type: SSS_PAM_USER_INFO</li>
<li>len: data_length</li>
<li>data:<ul>
<li>resp_type: SSS_PAM_USER_INFO_CHPASS_ERROR</li>
<li>len: err_len</li>
<li>user_error_message: “Old password not accepted”</li>
</ul>
</li>
</ul>
<p>As another example, the krb5_child may wish to convey some data (e.g.
TGT lifetime) to the parent. In this case, the krb5_child might also
append the following response to the response list, which the parent
(i.e. AD Provider Plugin) could use as a parameter when adding the TGT
to a renew table.</p>
<ul class="simple">
<li>type: SSS_KRB5_INFO_TGT_LIFETIME</li>
<li>len: data-length</li>
<li>data: value of tgt lifetime</li>
</ul>
<div class="section" id="kdcinfo-files">
<h5>7.8.2.3. kdcinfo files<a class="headerlink" href="#kdcinfo-files" title="Permalink to this headline">¶</a></h5>
<p>The SSSD might discover additional KDC or Kadmin servers that are not
defined in krb5.conf. However, it would still be prudent if tools like
kinit or kpasswd could talk to the same servers the SSSD talks to. To
this end, the SSSD implements a plugin for libkrb5, located in the
<a class="reference external" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/krb5_plugin/sssd_krb5_locator_plugin.c">​sssd_krb5_locator_plugin.c</a>
file. When a new KDC is discovered, the sssd_be process writes the IP
address of this KDC into a file under the /var/lib/sss/pubconf
directory. With the help of the locator plugin, libkrb5 is able to read
these files in the pubconf directory and use the KDC servers discovered
by the SSSD.</p>
</div>
</div>
</div>
<div class="section" id="ad-provider-plugin-access-provider">
<h3>7.8.3. AD Provider Plugin: access_provider<a class="headerlink" href="#ad-provider-plugin-access-provider" title="Permalink to this headline">¶</a></h3>
<p>In this section, we examine the AD Provider Plugin&#8217;s implementation of
the access_provider type, including the AD-specific bet_ops and
pvt_bet_data that are used.</p>
<ul class="simple">
<li>bet_ops:<ul>
<li>handler: ad_access_handler</li>
</ul>
</li>
<li>pvt_bet_data: access_ctx (of type ad_access_ctx)</li>
</ul>
<p>The ad_access_ctx is created as part of the initialization that takes
place when the AD Provider Plugin is dynamically loaded for an
access_provider line, at which time several actions take place,
including:</p>
<ul class="simple">
<li>setting up sdap_access_ctx for checking expired/locked accounts</li>
</ul>
<p>This function is used to fulfill an access check request, such as
determining whether the password of &#8220;<a class="reference external" href="mailto:aduser&#37;&#52;&#48;foo&#46;com">aduser<span>&#64;</span>foo<span>&#46;</span>com</a>&#8221; has expired. It is
called for account management requests by be_pam_handler, which is the
generic sbus_method function that handles <em>pamHandler</em> messages, the
details of which have been previously discussed.</p>
<p>This function is called with a be_req input argument, from which it
extracts two important things:</p>
<ul class="simple">
<li>access_ctx, which includes relevant config info, etc</li>
<li>pam_data, which includes the many input values sent in the SBus
request message (e.g. cmd, user, authtok, etc).</li>
</ul>
<p>Currently, the ad_access_handler simply calls sdap_access_send,
which determines whether or not the account is expired/locked, and
returns the result.</p>
</div>
</div>
</div>
<div class="section" id="tevent-basics">
<h1>8. Tevent Basics<a class="headerlink" href="#tevent-basics" title="Permalink to this headline">¶</a></h1>
<p>This section examines events and requests based on file descriptors.</p>
<div class="section" id="events">
<h2>8.1. Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h2>
<p>The tevent library provides a main loop implementation capable of
supporting various types of events, of which we focus here on fd-based
events. A tevent_fd object encapsulates an fd, a set of flags (e.g.
READ, WRITE), an event handler, and handler data. As with all events, a
tevent_fd is managed by the tevent main loop, which monitors the events
in its event context. When an event fires (e.g. fd becomes readable),
the main loop calls the corresponding event handler callback, which uses
the handler data to continue where it left off. When the main loop calls
a handler, the main loop can not call a second handler until control has
been returned to it by the first handler.</p>
<p>In the tevent model, the handler code is responsible for performing
socket operations (e.g. accept, send, recv, etc) on a file descriptor,
while the main loop is responsible for polling the file descriptors to
determine which one is ready to send or recv data. When we call
tevent_add_fd(ev, talloc_ctx, fd, flags, handler, data), we are
simply asking the main loop to call the handler with the arg, when the
specified fd is able to read or write (as specified by the flags).</p>
</div>
<div class="section" id="requests">
<h2>8.2. Requests<a class="headerlink" href="#requests" title="Permalink to this headline">¶</a></h2>
<p>The tevent library also supports generic asynchronous functions, by
providing tevent request helper functions (and a naming convention).
Unlike synchronous functions, which provide callers with a single
interface that accepts inputs and returns outputs, asynchronous
functions provide two interfaces for a particular computation: one to
“send” the request (i.e. accept inputs) and another to “receive” the
response (i.e. return outputs). As such, a tevent request&#8217;s
&#8220;implementation&#8221; refers to the code that implements the tevent request
(e.g. comp_send and comp_recv), while a tevent request&#8217;s &#8220;caller&#8221;
refers to the code that calls comp_send or comp_recv. The tevent
library includes support for nested requests, in which the
&#8220;implementation&#8221; of one tevent request can be a &#8220;caller&#8221; for a different
tevent request. This allows for better modularization of the codebase.
This also enables the cancelling of a top-level request to result in the
cancelling of all its nested requests.</p>
<p>The implementation of a tevent request is responsible for creating a
tevent_req object, specifying data (used to hold inputs/outputs;
private to the implementation) that the implementation may need to
maintain, and determining whether or not the request has completed
successfully. In addition, since the caller is not aware of the data
details, the implementation has to provide a recv function so that the
caller can extract the relevant outputs from the state.</p>
<p>The caller of a tevent request specifies its inputs when issuing a
request, and also specifies a callback function (and argument) to be
called when the request has completed. This callback function is
typically used by the caller to receive the response (using the
implementation-provided recv function). Note that the caller is not
concerned with the details of the implementation (e.g. whether network
I/O was required, whether the request was fulfilled by cache, etc), as
long as the tevent request&#8217;s send/recv contract (e.g. input/output) is
maintained.</p>
<p>Let&#8217;s look at the naming convention used by tevent requests for an
example <strong>&#8220;comp&#8221;</strong> computation (note that this naming convention is not
always precisely followed in the SSSD code):</p>
<ul class="simple">
<li>the implementation of the comp computation:<ul>
<li>specifies public interface for caller consumption:<ul>
<li><strong>*comp*</strong><em>_send(mem_ctx, inputs)</em>: used by caller to
specify inputs for request</li>
<li><strong>*comp*</strong><em>_recv(req, outputs)</em>: used by caller to receive
outputs of request</li>
</ul>
</li>
<li>specifies private details for internal consumption by
implementation<ul>
<li><strong>*comp*</strong><em>_state: object used to pass around inputs/outputs
between internal functions</em></li>
</ul>
</li>
</ul>
</li>
<li>the caller of the <strong>comp</strong> computation:<ul>
<li>calls the public interface with inputs/outputs</li>
<li><strong>*comp*</strong><em>_done: specifies callback function and callback
argument</em></li>
</ul>
</li>
</ul>
<p>The following example illustrates the material presented in this
section. In this example, we are using <strong>“read_bytes”</strong> as the example
computation. The implementation implements the caller-accessible
<strong>read_bytes_send</strong> and <strong>read_bytes</strong><em>_recv</em> functions, as well
as its own internal functions (such as
<strong>*read_bytes*</strong>_<em>handler</em>). The caller calls the public interface
with inputs/outputs, and also specifies the callback function.</p>
<p>Implementation Code</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">tevent_req</span> <span class="o">*</span><span class="n">read_bytes_send</span><span class="p">(</span><span class="n">mem_ctx</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
       <span class="o">...</span>
       <span class="n">req</span> <span class="o">=</span> <span class="n">tevent_req_create</span><span class="p">(</span><span class="n">mem_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">struct</span> <span class="n">read_bytes_state</span><span class="p">);</span>
       <span class="n">state</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
       <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">talloc_size</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">);</span>
       <span class="n">state</span><span class="o">-&gt;</span><span class="nb">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="n">fde</span> <span class="o">=</span> <span class="n">tevent_add_fd</span><span class="p">(</span><span class="n">ev</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">TEVENT_FD_READ</span><span class="p">,</span> <span class="n">read_bytes_handler</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
       <span class="k">return</span> <span class="n">req</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">read_bytes_handler</span><span class="p">(</span><span class="n">struct</span> <span class="n">tevent_context</span> <span class="o">*</span><span class="n">ev</span><span class="p">,</span> <span class="n">struct</span> <span class="n">tevent_fd</span> <span class="o">*</span><span class="n">fde</span><span class="p">,</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvt</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="n">req</span> <span class="o">=</span> <span class="n">talloc_get_type</span><span class="p">(</span><span class="n">pvt</span><span class="p">,</span> <span class="n">struct</span> <span class="n">tevent_req</span><span class="p">);</span>
     <span class="n">state</span> <span class="o">=</span> <span class="n">tevent_req_data</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">struct</span> <span class="n">read_bytes_state</span><span class="p">);</span>
     <span class="n">read</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">);</span>
     <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">read_bytes_recv</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">mem_ctx</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="o">**</span><span class="n">buf</span><span class="p">,</span> <span class="n">ssize_t</span> <span class="o">*</span><span class="nb">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">tevent_req_data</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">struct</span> <span class="n">read_bytes_state</span><span class="p">);</span>
    <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">talloc_steal</span><span class="p">(</span><span class="n">mem_ctx</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
    <span class="o">*</span><span class="nb">len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="nb">len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">EOK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div><p>Caller Code</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">caller_func</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">caller_data</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="n">tevent_req</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">read_bytes_send</span><span class="p">(</span><span class="n">mem_ctx</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
     <span class="n">tevent_req_set_callback</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">caller_func_complete</span><span class="p">,</span> <span class="n">caller_data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div><div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">caller_func_complete</span><span class="p">(</span><span class="n">tevent_req</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="n">caller_data</span> <span class="o">=</span> <span class="n">tevent_req_callback_data</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">struct</span> <span class="n">caller_data</span><span class="p">);</span>
     <span class="o">...</span> <span class="n">do</span> <span class="n">something</span> <span class="k">with</span> <span class="n">caller_data</span> <span class="o">...</span>
     <span class="n">read_bytes_recv</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp_error</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">dp_error</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div><p>Note the distinction between an event handler and a request callback.
While they are both similar in function, the tevent main loop is only
aware of the events and handlers in the event context that it is
monitoring. A tevent request is not managed by the main loop. Rather,
the request&#8217;s implementation determines when the request has completed,
resulting in the request&#8217;s callback being called, which uses the
callback data to continue where it left off. Unlike an event, a tevent
request is quite flexible, as it represents a generic asynchronous
function call. Also, when a main loop calls a handler, the main loop can
not call a second handler until control has been returned to it by the
first handler. However, the first handler&#8217;s code may “send” a tevent
request, which may itself “send” a second tevent request, and so on, all
before returning control to the main loop.</p>
<p>Additionally, an event&#8217;s handler and handler_data are registered using
one of the tevent_add_* functions; when the event is triggered, the
main loop calls event-&gt;handler(..., event-&gt;handler_data), just as we
would expect. In other words, the handler and handler_data that we
registered are the same handler and handler_data that are called. In
contrast, since a request&#8217;s callback and callback data are registered
using tevent_req_set_callback(req, callback, callback_data), you
might expect the code to call callback(callback_data). However, this is
not the case; the code calls the tevent request&#8217;s callback with the
tevent request as a parameter, and the callback_data needs to be
extracted from the tevent request. In other words, the code calls
callback(req); the callback function then needs to extract the callback
data from the req using tevent_req_callback_data(req, ...).</p>
</div>
<div class="section" id="subrequests">
<h2>8.3. Subrequests<a class="headerlink" href="#subrequests" title="Permalink to this headline">¶</a></h2>
<p>If the async computation relies on a sub-computation taking place before
the async function can make progress, it can create a request with its
state, and then register the subcomputation by creating a subrequest
(representing the subcomputation) and setting the subrequest&#8217;s callback
to a function which will allow the original computation to make
progress. For example, you will often see the following pattern in the
codebase (note that the code listing can be read from top to bottom,
almost as if the calls were synchronous):</p>
<div class="code"><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">comp_send</span><span class="p">(</span><span class="n">memctx</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">tevent_req_create</span><span class="p">(</span><span class="n">memctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="n">struct</span> <span class="n">comp_state</span><span class="p">);</span>
        <span class="o">...</span><span class="n">populate</span> <span class="n">state</span><span class="s1">&#39;s input fields (using inputs)...</span>
        <span class="n">subreq</span> <span class="o">=</span> <span class="n">subcomp_send</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
        <span class="n">tevent_req_set_callback</span><span class="p">(</span><span class="n">subreq</span><span class="p">,</span> <span class="n">comp_done</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">req</span><span class="p">;</span>

<span class="n">comp_done</span><span class="p">(</span><span class="n">subreq</span><span class="p">)</span>
        <span class="n">req</span> <span class="o">=</span> <span class="n">tevent_req_callback_data</span><span class="p">(</span><span class="n">subreq</span><span class="p">,</span> <span class="n">tevent_req</span><span class="p">)</span>
         <span class="n">comp_state</span> <span class="o">=</span> <span class="n">tevent_req_data</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">comp_state</span><span class="p">)</span>
         <span class="o">...</span><span class="n">populate</span> <span class="n">state</span><span class="s1">&#39;s output fields by calling comp_recv(subreq, *state-&gt;outputs)...</span>
         <span class="o">...</span><span class="n">call</span> <span class="n">tevent_req_done</span> <span class="ow">or</span> <span class="n">tevent_req_error</span><span class="p">,</span> <span class="k">as</span> <span class="n">appropriate</span><span class="o">...</span>
</pre></div>
</div>
</div><p>In order to examine a nested chain of subrequests, it can be useful to
create a diagram to help visualize it. The following diagram displays
two such Kerberos-related visualizations. It is left as an exercise for
the reader to create an SDAP-related visualization! ;)</p>
<p><em>This diagram presents a visualization of the AD Provider Plugin&#8217;s
implementation of AUTH (top) and ACCT_MGMT (bottom). Several
abbreviations are used here, including: BR=be_resolve_server,
HAN_CHILD=handle_child, WR=write_pipe, RD=read_pipe, ID_OP =
sdap_id_op, GG=sdap_get_generic. Also note that be_resolve_server
makes several additional calls, which we have not shown.</em></p>
</div>
</div>
<div class="section" id="functions">
<h1>9. Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<p>This section provides documentation for several functions. We refer
below to the entire computation as if it were a synchronous function,
receiving logical inputs (i.e. comp_send), and returning logical ouputs
(comp_recv). This makes it easier to see the function&#8217;s input/output
characteristics.</p>
<div class="section" id="sdap-connection-functions">
<h2>9.1. SDAP Connection Functions<a class="headerlink" href="#sdap-connection-functions" title="Permalink to this headline">¶</a></h2>
<p>This section describes several of the functions called in order to
establish an authenticated LDAP connection. The call stack looks as
follows:</p>
<ul class="simple">
<li><strong>sdap_id_op_connect_send</strong><ul>
<li>sdap_cli_connect_send<ul>
<li>be_resolve_server_send<ul>
<li>fo_resolve_service_send<ul>
<li>resolv_gethostbyname_send<ul>
<li>resolv_gethostbyname_dns_send</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>sdap_connect_send <a href="#id1"><span class="problematic" id="id2">**</span></a><a href="#id3"><span class="problematic" id="id4">**</span></a></li>
<li>sdap_cli_rootdse_step<ul>
<li><strong>sdap_get_rootdse_send</strong></li>
</ul>
</li>
<li>sdap_cli_kinit_step<ul>
<li><strong>sdap_kinit_send</strong><ul>
<li>be_resolve_server_send</li>
<li>sdap_get_tgt_send <a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">**</span></a></li>
</ul>
</li>
</ul>
</li>
<li>sdap_cli_auth_step<ul>
<li><strong>sdap_auth_send</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="section" id="sdap-id-op-connect-send-recv">
<h3>9.1.1. sdap_id_op_connect_send/recv<a class="headerlink" href="#sdap-id-op-connect-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap_id_op object</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if successful, returns<ul>
<li>reply_count</li>
<li>reply (sysdb_attrs)</li>
<li>op created and added to sh-&gt;ops</li>
</ul>
</li>
</ul>
<p>Summary: This function initiates an LDAP connection, manages the
connection cache, and calls <em>sdap_cli_connect_send</em> to do the heavy
lifting.</p>
</div>
<div class="section" id="sdap-cli-connect-send-recv">
<h3>9.1.2. sdap_cli_connect_send/recv<a class="headerlink" href="#sdap-cli-connect-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap_options, sdap_service, skip_rootdse, force_tls,
skip_auth</p>
<p>Logical Output:</p>
<ul class="simple">
<li>can_retry boolean</li>
<li>sdap_handle</li>
<li>sdap_server_opts</li>
</ul>
<p>Summary: This functions attempts to perform multiple tasks in order to
establish a server connection for the specified sdap_service. This
function is called by ad_check_online in order to determine if we are
able to connect to server (in which case we are in online mode).
Internally, it makes the following calls to perform these tasks:</p>
<ul class="simple">
<li>calls be_resolve_server to obtain addressing information for a
server that supports the service</li>
<li>calls sdap_connect_send to establish a connection to the resolved
server</li>
<li>calls sdap_cli_rootdse_step to read rootDSE info from the resolved
server (if anonymous access allowed)</li>
<li>calls cli_kinit_step to obtain addressing information for a KDC and
to obtain a TGT from it</li>
<li>calls cli_auth_step performs an LDAP bind (either sasl or simple);
also, it we were unable to read rootDSE info anonymously, we try to
read it again now that we&#8217;re authenticated</li>
</ul>
</div>
<div class="section" id="be-resolve-server-send-recv">
<h3>9.1.3. be_resolve_server_send/recv<a class="headerlink" href="#be-resolve-server-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: be_ctx, service_name, first_retry</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if able to resolve an fo_server in fo_service-&gt;server_list<ul>
<li>set request done; output can be retrieved from state-&gt;srv</li>
<li>calls any cbs associated with service; for AD provider, this is
ad_resolve_cb(service)<ul>
<li>sets service-&gt;sdap-&gt;uri=ldap: <em>srv-name; populates sockaddr
with ip and LDAP_PORT</em></li>
<li>sets service-&gt;gc-&gt;uri=ldap: <em>srv-name:3268; populates sockaddr
with ip and GC_PORT</em></li>
</ul>
</li>
</ul>
</li>
<li>if unable to resolve any fo_server in fo_service-&gt;server_list</li>
<li>set request error to EIO, indicating that caller should mark us as
offline (be_mark_offline)</li>
</ul>
<p>Summary: attempts to resolve each server associated with service_name&#8217;s
fo_service, until server resolution succeeds or there are no more
servers to resolve; if successful, calls any callbacks associated with
service and returns resolved fo_server;</p>
</div>
<div class="section" id="fo-resolve-service-send-recv">
<h3>9.1.4. fo_resolve_service_send/recv<a class="headerlink" href="#fo-resolve-service-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: resolv_ctx, fo_ctx, fo_service</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if able to resolve hostname<ul>
<li>set fo_server-&gt;common-&gt;status to SERVER_NAME_RESOLVED</li>
<li>set request done; output can be retrieved from state-&gt;server</li>
</ul>
</li>
<li>if unable to resolve hostname for fo_server<ul>
<li>set fo_server-&gt;common-&gt;status to SERVER_NOT_WORKING</li>
<li>set request error to EAGAIN, indicating that the caller should try
the next fo_server (if any)</li>
</ul>
</li>
</ul>
<p>Summary: For next server on fo_service-&gt;server_list, if server
supports resolution using SRV records, perform resolution by calling
resolv_srv_send; otherwise, perform resolution by calling
fo_resolve_service_server. If resolution successful, return
fo_server, which includes the desired addressing information in
fo_server-&gt;server_common-&gt;rhostent. If unsuccessful, return EAGAIN,
indicating that caller should try next fo_server (if any).</p>
<p>Internals: While a name resolution request is being processed, if a
second identical request is received (i.e. for the same server name),
the Backend will notice that an existing request for the same
information is already in progress, and it will register the second
request (and any subsequent identical requests) to be called back when
the results are ready (so that they receive the same reply information).
While the Responder is able to maintain a single dp_request_table to
perform a similar function, the Backend has to maintain a separate
request list for each server.</p>
</div>
<div class="section" id="resolv-gethostbyname-send-recv">
<h3>9.1.5. resolv_gethostbyname_send/recv<a class="headerlink" href="#resolv-gethostbyname-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: res_ctx, name, family_order, db</p>
<p>Logical Output: status, rhostent, error</p>
<p>Summary: Attempts to resolve server name using each host database in the
specified db list, until successful. If successful, returns the rhostent
object (containing IP address) and returns EOK; if unsuccessful, returns
embedded error. In all cases, returns query status and how many times
query timed out.</p>
<p>Internals: If server name is an IP address, returns a fake hostent
structure populated with IP address. Translates family_order input to
family before calling subsequent functions. If first family doesn&#8217;t
work, tries second family.</p>
</div>
<div class="section" id="resolv-gethostbyname-dns-send-recv">
<h3>9.1.6. resolv_gethostbyname_dns_send/recv<a class="headerlink" href="#resolv-gethostbyname-dns-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input:res_ctx, name, family Logical Ouput: status, timeouts,
rhostent, error</p>
<p>Summary: Sends a DNS query for the specified server name over the DNS
connection represented by the specified resolv_ctx&#8217;s channel. If
successful, returns the rhostent object (containing the IP address
associated with specified server name); if domain name not found, sets
error to ENOENT; else sets error corresponding to status. In all cases,
returns query status and how many times query timed out.</p>
<p>Internals: This function registers a callback function
(resolv_gethostbyname_dns_query_done) with the c-ares library to be
called by the library when the query has completed or failed. When
called, the callback function parses the response (using
resolv_gethostbyname_dns_parse) and retrieves the hostent object.</p>
</div>
<div class="section" id="sdap-connect-send-recv">
<h3>9.1.7. sdap_connect_send/recv<a class="headerlink" href="#sdap-connect-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: uri (<a class="reference external" href="ldap://server-name:port">ldap://server-name:port</a>) and sockaddr (popoulated
with ip-address and port)</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if connection successfully established,<ul>
<li>set ldap connection callbacks</li>
<li>set various options on ldap handle</li>
<li>if not using start_tls, set request done; sdap_handle output can
be retreived from state-&gt;sh</li>
<li>if using start_tls, calls ldap_start_tls, sdap_set_connected,
sdap_op_add</li>
</ul>
</li>
</ul>
<p>Summary: This function establishes a connection to the LDAP server,
obtains the resulting LDAP handle, and registers a pair of connection
callbacks with the LDAP handle. These tasks are implemented in different
ways, depending on whether the system&#8217;s OpenLDAP library supports the
ldap_init_fd call, and whether it supports the LDAP_OPT_CONNECT_CB
option. In this description, we will assume that both are supported.</p>
<p>This function establishes the LDAP connection by calling
sss_ldap_init_send, which returns an initialized LDAP handle. After
the connection has been established, sdap_sys_connect_done registers
a pair of callbacks with OpenLDAP, such that OpenLDAP will call the add
connection callback (sdap_ldap_connect_callback_add) after a
connection is established, and will call the delete connection callback
(sdap_ldap_connect_callback_del) after a connection is closed. Since
we have just established a connection, the add_connection_callback is
called, which registers a handler (<em>sdap_ldap_result</em>) to handle
incoming responses.</p>
<p>At this point, several options are set on the LDAP handle (e.g. version,
timeouts, etc).</p>
<p>At this point, if TLS was not requested, we don&#8217;t consider the connected
to be connected (i.e. we don&#8217;t call sdap_set_connected); it will be
considered connected after the bind call succeeds. However, if TLS was
requested, we call ldap_start_tls, call sdap_set_connected, and call
sdap_add_op(sdap_connect_done). sdap_connect_done calls
ldap_parse_result to parse the StartTLS result.</p>
</div>
<div class="section" id="sss-ldap-init-send-recv">
<h3>9.1.8. sss_ldap_init_send/recv<a class="headerlink" href="#sss-ldap-init-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: uri (<a class="reference external" href="ldap://server-name:port">ldap://server-name:port</a>) and sockaddr (popoulated
with ip-address and port)</p>
<p>Logical Output: if successful, returns LDAP handle and file descriptor
for LDAP socket</p>
<p>Summary: creates a socket fd, connects to the ip-address of an LDAP
server, and initializes OpenLDAP by passing the connected fd to
ldap_init_fd, which returns an opaque LDAP structure, which is to be
used in subsequent OpenLDAP calls.</p>
<p>Internals: This function establishes an LDAP connection using the given
IP address and URI:</p>
<ul class="simple">
<li>fd = socket(...);</li>
<li>connect(fd, ip-address, ...)</li>
<li>ldap_init_fd(fd, uri)</li>
</ul>
</div>
<div class="section" id="sdap-get-rootdse-send-recv">
<h3>9.1.9. sdap_get_rootdse_send/recv<a class="headerlink" href="#sdap-get-rootdse-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap options, sdap handle</p>
<p>Logical Output: if successful, returns set of sysdb_attrs</p>
<p>Summary: This function retrieves several attributes from the LDAP
server&#8217;s rootdse by calling sdap_get_generic_send with the following
inputs:</p>
<ul class="simple">
<li>search_base:[]</li>
<li>filter: [(objectclass=*)];</li>
<li>attrs:
[*,altServer,namingContexts,supported{Control,Extension,Features,LDAPVersion,SASLMechanisms},
domainControllerFunctionality,defaultNamingContext,
last,highestCommitted}USN]</li>
</ul>
</div>
<div class="section" id="sdap-kinit-send-recv">
<h3>9.1.10. sdap_kinit_send/recv<a class="headerlink" href="#sdap-kinit-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap handle, krb_service_name, keytab, principal, realm</p>
<p>Logical Output: expire_time</p>
<p>Summary: This function first calls be_resolve_server_send to obtain
addressing information for a Kerberos server (KDC) that supports the
given service (i.e. as specified by krb_service_name). If successful,
this function then calls sdap_get_tgt_send to obtain a TGT for the
host principal from the resolved KDC server from the previous step.</p>
</div>
<div class="section" id="sdap-get-tgt-send-recv">
<h3>9.1.11. sdap_get_tgt_send/recv<a class="headerlink" href="#sdap-get-tgt-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: realm, principal, keytab, lifetime, timeout</p>
<p>Logical Output: result, krb5_error_code, ccname, expire_time_out</p>
<p>Brief: This function attempts to obtain a TGT from the KDC for the host
principal, using the host&#8217;s key entry (in its key table) to perform the
necessary authentication.</p>
<p>Internals: In order to avoid blocking on synchronous Kerberos calls,
this function spawns an ldap_child process, and sends it a TGT request
message (consisting of the realm, principal, and keytab) using its write
pipe. The ldap_child makes the necessary Kerberos library calls to
attempt to get a TGT, and returns a response to the calling process&#8217;s
read pipe, at which time the ldap_child process exits.</p>
<p>Kerberos library calls used by ldap_child include:</p>
<ul class="simple">
<li>krb5_init_context: create a krb5 library context</li>
<li>krb5_parse_name: convert a string principal name to a
krb5_principal structure<ul>
<li>krb5_unparse_name: convert a krb5_principal structure to a
string representation</li>
</ul>
</li>
<li>krb5_kt_default: resolve the default key table<ul>
<li>krb5_kt_start_seq_get: start a sequential retrieval of key
table entries</li>
<li>krb5_kt_next_entry: retrieve the next entry from the keytable</li>
<li>krb5_free_keytab_entry_contents: free the contents of a key
table entry</li>
<li>krb5_kt_end_seq_get: release a keytab cursor</li>
</ul>
</li>
<li>krb5_get_init_creds_opt_set_address_list: set address
restrictions in initial credential options<ul>
<li>krb5_get_init_creds_opt_set_forwardable: set/unset
forwardable flag in initial cred options</li>
<li>krb5_get_init_creds_opt_set_proxiable: set/unset proxiable
flag in initial credential options</li>
<li>krb5_get_init_creds_opt_set_tkt_life: set the ticket
lifetime in initial cred options</li>
<li>krb5_get_init_creds_opt_set_canonicalize: set/unset
canonicalize flag in init cred options</li>
</ul>
</li>
<li>krb5_get_init_creds_keytab: get initial credentials using a key
table (request TGT)</li>
<li>krb5_cc_resolve: resolve a credential cache name<ul>
<li>krb5_cc_initialize: initialize a credential cache</li>
<li>krb5_cc_store_cred: store credentials in a credential cache</li>
</ul>
</li>
<li>krb5_get_time_offset: return the time offsets from the os context</li>
</ul>
</div>
<div class="section" id="sdap-auth-send-recv">
<h3>9.1.12. sdap_auth_send/recv<a class="headerlink" href="#sdap-auth-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap_handle, sasl_mech, sasl_user, user_dn, authtok</p>
<p>Logical Output: if successful, returns EOK and (for simple bind only) an
sdap_ppolicy_data object if unsuccessful, returns ERR_AUTH_FAILED</p>
<p>Brief: This function peforms an LDAP bind by calling either
sdap_sasl_bind or sdap_simple_bind (based on whether the specified
sasl_mech is non-NULL). If the bind is successful, and we were not able
to read the rootDSE during unauthenticated bind, we try to read the
rootDSE again now that we&#8217;re authenticated.</p>
<p>If sasl_mech is specified, sdap_sasl_bind is called with the
specified sasl_mech and sasl_user. For the AD use case, the value for
sasl_mech is obtained from the ldap_sasl_mech configuration field
(which is typically GSSAPI). The value for sasl_user is obtained from
the ldap_sasl_authid configuration field. Internally, we make a
blocking call to ldap_sasl_interactive_bind_s.</p>
<p>If sasl_mech is not specified, sdap_simple_bind is called with the
specified user_dn and with a password retrieved from the specified
authtok. In an AD use case, the value for the specified user_dn is
obtained from the ldap_default_bind_dn configuration field. The value
for the specified password is obtained from the ldap_default_authtok
configuration field. Internally, we make a call to ldap_sasl_bind. If
it succeeds, we set the sdap handle to the connected state.</p>
</div>
</div>
<div class="section" id="sdap-operation-request-functions">
<h2>9.2. SDAP Operation Request Functions<a class="headerlink" href="#sdap-operation-request-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="users-get-send-recv">
<h3>9.2.1. users_get_send/recv<a class="headerlink" href="#users-get-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap_id_ctx, sdap_domain, sdap_id_conn_ctx, name,
filter_type</p>
<p>Logical Output:</p>
<ul class="simple">
<li>returns dp_error and sdap_ret</li>
</ul>
<p>Summary: This function is called in order to handle a USER request (i.e.
getpw*) with the specified inputs.</p>
<p>Internals: This function creates an sdap_id_op object to represent the
operation request. It then uses the specified inputs to create an LDAP
filter.</p>
<ul class="simple">
<li>creates an sdap_id_op object to represent the operation request
(using sdap_id_op_create)</li>
<li>establishes LDAP connection by sending a connection request (or
re-uses cached connection)<ul>
<li>multi-step process, including connecting and binding to an LDAP
server</li>
</ul>
</li>
<li>sends an operation request (and receives response) over the LDAP
connection<ul>
<li>performs asynchronous ldap search using the be_acct_req fields
as input params (sdap_get_generic_send).</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="sdap-get-generic-send-recv">
<h3>9.2.2. sdap_get_generic_send/recv<a class="headerlink" href="#sdap-get-generic-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap handle (including sdap_op objects), search_base,
scope, filter, attrs</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if successful, returns<ul>
<li>reply_count</li>
<li>reply (sysdb_attrs)</li>
<li>op created and added to sh-&gt;ops</li>
</ul>
</li>
</ul>
<p>Summary: This function performs an asynchronous ldap search operation by
calling ldap_search_ext with the specified inputs, which include where
to start the search (base), how deep to search (scope), what to match on
(filter), and which attributes to return (attrs). If successful, the
recv function returns the specified attributes of entries matching the
specified filter. If unsuccessful, the recv function indicates that
there was an error.</p>
</div>
<div class="section" id="sdap-get-generic-ext-send-recv">
<h3>9.2.3. sdap_get_generic_ext_send/recv<a class="headerlink" href="#sdap-get-generic-ext-send-recv" title="Permalink to this headline">¶</a></h3>
<p>Logical Input: sdap handle, search_base, scope, filter, attrs,
parse_cb</p>
<p>Logical Output:</p>
<ul class="simple">
<li>if successful<ul>
<li>set request done; output can be retrieved from state-&gt;sreply</li>
</ul>
</li>
<li>else returns error</li>
</ul>
<p>Summary: This function performs an asynchronous ldap search operation by
calling ldap_search_ext with the specified inputs, obtaining the
resulting msgid, and created an sdap_op object using the msgid.</p>
<p>Internals: The recv function is called when the ldap response messages
(corresponding to the search request) are received. Note that a search
request can generate several <em>search entry</em> responses
(LDAP_RES_SEARCH_ENTRY), followed by a single <em>search done</em> response
(LDAP_RES_SEARCH_RESULT). For each <em>search entry</em> response that is
received, we call the specified parse_cb function (e.g.
sdap_get_generic_parse_entry), which parses the response and adds
the returned attributes to an sdap_reply object. If a <em>search done</em>
response is received, then we call the standard ldap_parse_result
function to parse the response, primarily to extract the error message
(if any).</p>
</div>
</div>
</div>
<div class="section" id="filesystem-locations">
<h1>10. Filesystem Locations<a class="headerlink" href="#filesystem-locations" title="Permalink to this headline">¶</a></h1>
<p>This section describes the locations of the primary source code and
installation artifacts for each component.</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="29%" />
<col width="32%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>Component</em></td>
<td><em>Source File Location</em></td>
<td><em>Installation Location</em></td>
<td><em>Log File and Prefix</em></td>
</tr>
<tr class="row-even"><td>NSS Client Library</td>
<td>sss_client/nss_*.c</td>
<td>/usr/lib64/security/nss_sss.so</td>
<td>n/a</td>
</tr>
<tr class="row-odd"><td>PAM Client Library</td>
<td>sss_client/pam_sss.c</td>
<td>/usr/lib64/security/pam_sss.so</td>
<td>n/a</td>
</tr>
<tr class="row-even"><td>Monitor</td>
<td>monitor/monitor.c</td>
<td>/usr/sbin/sssd</td>
<td>sssd.log;</td>
</tr>
<tr class="row-odd"><td>NSS Responder</td>
<td>responder/nss/nsssrv.c</td>
<td>/usr/libexec/sssd/sssd_nss</td>
<td>sssd_nss.log;</td>
</tr>
<tr class="row-even"><td>PAM Responder</td>
<td>responder/pam/pamsrv.c</td>
<td>/usr/libexec/sssd/sssd_pam</td>
<td>sssd_pam.log;</td>
</tr>
<tr class="row-odd"><td>Backend</td>
<td>providers/data_provider_be.c</td>
<td>/usr/libexec/sssd/sssd_be</td>
<td>sssd_foo.com.log;</td>
</tr>
<tr class="row-even"><td>AD Provider Plugin</td>
<td>providers/ad/ad_init.c</td>
<td>/usr/lib64/sssd/libsss_ad.so</td>
<td>n/a</td>
</tr>
<tr class="row-odd"><td>Config DB</td>
<td>confdb/confdb.c</td>
<td>/var/lib/sss/db/config.ldb</td>
<td>n/a</td>
</tr>
<tr class="row-even"><td>System DB</td>
<td>db/sysdb.c</td>
<td>/var/lib/sss/db/cache_foo.com.ldb</td>
<td>n/a</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="helpful-links">
<h1>11. Helpful Links<a class="headerlink" href="#helpful-links" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>SSSD Overview Video<ul>
<li>Presented by Stephen Gallagher-
<a class="reference external" href="http://www.youtube.com/user/opensourceidm">​http://www.youtube.com/user/opensourceidm</a></li>
</ul>
</li>
<li>SSSD Wiki -
<a class="reference external" href="https://fedorahosted.org/sssd/wiki/">​https://fedorahosted.org/sssd/wiki/</a><ul>
<li>This is the main repository for SSSD information. It includes:<ul>
<li>[Design Docs] -
<a class="reference external" href="https://docs.pagure.org/sssd-test2/DesignDocs.html">​https://fedorahosted.org/sssd/wiki/DesignDocs</a></li>
<li>[Developer Pages] -
<a class="reference external" href="https://docs.pagure.org/sssd-test2/DevRes.html">​https://fedorahosted.org/sssd/wiki/DevRes</a><ul>
<li>such as Developer Tips and Tutorials</li>
</ul>
</li>
<li>[Documentation] -
<a class="reference external" href="https://docs.pagure.org/sssd-test2/Documentation.html">​https://fedorahosted.org/sssd/wiki/Documentation</a><ul>
<li>such as Man Pages, Deployment Guides, Conference
Presentations</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Realmd Page -
<a class="reference external" href="http://www.freedesktop.org/software/realmd/">​http://www.freedesktop.org/software/realmd/</a><ul>
<li>[Realmd Page] This is the main repository for Realmd information.
Among other things, it includes man pages, as well as an
Administrative Guide.</li>
</ul>
</li>
<li>Samba Components<ul>
<li>[Talloc Tutorial] -
<a class="reference external" href="http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html">​http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html</a></li>
<li>[Tevent Tutorial] -
<a class="reference external" href="http://tevent.samba.org/tevent_tutorial.html">​http://tevent.samba.org/tevent_tutorial.html</a></li>
<li>[LDB Tutorial] -
<a class="reference external" href="http://wiki.samba.org/index.php/Samba4/LDBIntro">​http://wiki.samba.org/index.php/Samba4/LDBIntro</a></li>
</ul>
</li>
<li>FreeIPA Design Proposals (out-of-date)<ul>
<li>SSSD was originally conceived of as the IPAv2 Client, so these
documents are useful in understanding the initial client design.
However, keep in mind that these documents are out-of-date. For
example, the sections on Policy Kit Back-End Daemon (PKBED) and
the Info Pipe Daemon (IPD) are not relevant to SSSD. Also, the
Service Controller Daemon in these documents refers to what later
became known as the SSSD Monitor process.<ul>
<li>[Design Overview]
<a class="reference external" href="http://www.freeipa.org/page/V2/IPA_Client_Design_Overview">​http://www.freeipa.org/page/V2/IPA_Client_Design_Overview</a></li>
<li>[Monitor]
<a class="reference external" href="http://www.freeipa.org/page/SSSD/Service_Controller_Daemon">​http://www.freeipa.org/page/SSSD/Service_Controller_Daemon</a></li>
<li>[SBus]
<a class="reference external" href="http://www.freeipa.org/page/SSSD/SBUS">​http://www.freeipa.org/page/SSSD/SBUS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">1. Introduction</a></li>
<li><a class="reference internal" href="#active-directory-use-case">2. Active Directory Use Case</a></li>
<li><a class="reference internal" href="#system-overview">3. System Overview</a><ul>
<li><a class="reference internal" href="#external-perspective">3.1. External Perspective</a><ul>
<li><a class="reference internal" href="#sss-client-applications">3.1.1. SSS Client Applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#internal-perspective">3.2. Internal Perspective</a><ul>
<li><a class="reference internal" href="#control-flow">3.2.1. Control Flow</a></li>
<li><a class="reference internal" href="#data-flow">3.2.2. Data Flow</a><ul>
<li><a class="reference internal" href="#data-flow-nss-responder">3.2.2.1. Data Flow (NSS Responder)</a></li>
<li><a class="reference internal" href="#data-flow-pam-responder">3.2.2.2. Data Flow (PAM Responder)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sssd-components">3.3. SSSD Components</a><ul>
<li><a class="reference internal" href="#processes-and-shared-objects">3.3.1. Processes and Shared Objects</a></li>
<li><a class="reference internal" href="#protocols">3.3.2. Protocols</a></li>
<li><a class="reference internal" href="#unix-signals">3.3.3. UNIX signals</a></li>
<li><a class="reference internal" href="#databases">3.3.4. Databases</a></li>
<li><a class="reference internal" href="#samba-libraries">3.3.5. Samba Libraries</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics">4. Advanced Topics</a><ul>
<li><a class="reference internal" href="#offline-mode">4.1. Offline Mode</a></li>
<li><a class="reference internal" href="#multiple-domains-and-trust-relationships">4.2. Multiple Domains and Trust Relationships</a><ul>
<li><a class="reference internal" href="#ad-concepts">4.2.1. AD Concepts</a></li>
<li><a class="reference internal" href="#domain-stanza-vs-domain">4.2.2. Domain Stanza vs. Domain</a></li>
<li><a class="reference internal" href="#sssd-implementation">4.2.3. SSSD Implementation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sssd-wrappers">5. SSSD Wrappers</a><ul>
<li><a class="reference internal" href="#sbus">5.1. SBus</a><ul>
<li><a class="reference internal" href="#sbus-concepts">5.1.1. SBus Concepts</a></li>
<li><a class="reference internal" href="#responder-to-backend-api">5.1.2. Responder-to-Backend API</a><ul>
<li><a class="reference internal" href="#request-nss-pam-responder-backend">5.1.2.1.1. Request (NSS/PAM Responder-&gt;Backend)</a></li>
<li><a class="reference internal" href="#response-backend-nss-pam-responder">5.1.2.1.2. Response (Backend=&gt;NSS/PAM Responder)</a><ul>
<li><a class="reference internal" href="#pamhandler">5.1.2.2. pamHandler</a></li>
</ul>
</li>
<li><a class="reference internal" href="#request-pam-responder-backend">5.1.2.2.1. Request (PAM Responder -&gt; Backend)</a></li>
<li><a class="reference internal" href="#response-pam-responder-backend">5.1.2.2.2. Response (PAM Responder -&gt; Backend)</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#sdap">5.2. SDAP</a><ul>
<li><a class="reference internal" href="#sdap-concepts">5.2.1. SDAP Concepts</a></li>
<li><a class="reference internal" href="#establishing-an-ldap-connection">5.2.2. Establishing an LDAP Connection</a></li>
<li><a class="reference internal" href="#performing-ldap-operations">5.2.3. Performing LDAP Operations</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#common-data-structures">6. Common Data Structures</a><ul>
<li><a class="reference internal" href="#tevent-context">6.1. tevent_context</a></li>
<li><a class="reference internal" href="#confdb-ctx">6.2. confdb_ctx</a></li>
<li><a class="reference internal" href="#sysdb-ctx">6.3. sysdb_ctx</a></li>
<li><a class="reference internal" href="#main-context">6.4. main_context</a></li>
</ul>
</li>
<li><a class="reference internal" href="#component-details">7. Component Details</a><ul>
<li><a class="reference internal" href="#monitor">7.1. Monitor</a><ul>
<li><a class="reference internal" href="#spawning-and-registering-processes">7.1.1. Spawning and Registering Processes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sss-client">7.2. SSS Client</a><ul>
<li><a class="reference internal" href="#sss-cli">7.2.1. SSS_CLI</a></li>
<li><a class="reference internal" href="#nss-client">7.2.2. NSS Client</a></li>
<li><a class="reference internal" href="#pam-client">7.2.3. PAM Client</a></li>
</ul>
</li>
<li><a class="reference internal" href="#responder">7.3. Responder</a><ul>
<li><a class="reference internal" href="#resp-ctx">7.3.1. resp_ctx</a></li>
<li><a class="reference internal" href="#client-facing-interactions-generic">7.3.2. Client-Facing Interactions (Generic)</a></li>
<li><a class="reference internal" href="#common-optimization-techniques">7.3.3.Common Optimization Techniques</a></li>
</ul>
</li>
<li><a class="reference internal" href="#nss-responder">7.4. NSS Responder</a><ul>
<li><a class="reference internal" href="#nss-ctx">7.4.1. nss_ctx</a></li>
<li><a class="reference internal" href="#client-facing-interactions-nss">7.4.2. Client-Facing Interactions (NSS)</a></li>
<li><a class="reference internal" href="#backend-facing-interactions-nss">7.4.3. Backend-Facing Interactions (NSS)</a></li>
<li><a class="reference internal" href="#code-flow-nss">7.4.4. Code Flow (NSS)</a></li>
<li><a class="reference internal" href="#optimization-techniques-nss">7.4.5. Optimization Techniques (NSS)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pam-responder">7.5. PAM Responder</a><ul>
<li><a class="reference internal" href="#pam-ctx">7.5.1. pam_ctx</a></li>
<li><a class="reference internal" href="#client-facing-interactions-pam">7.5.2. Client-Facing Interactions (PAM)</a></li>
<li><a class="reference internal" href="#backend-facing-interactions-pam">7.5.3. Backend-Facing Interactions (PAM)</a></li>
<li><a class="reference internal" href="#code-flow-pam">7.5.4. Code Flow (PAM)</a></li>
<li><a class="reference internal" href="#optimization-techniques-pam">7.5.5. Optimization Techniques (PAM)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimizations-code-flow">7.6. Optimizations Code Flow</a></li>
<li><a class="reference internal" href="#backend">7.7. Backend</a><ul>
<li><a class="reference internal" href="#backend-concepts">7.7.1. Backend Concepts</a></li>
<li><a class="reference internal" href="#be-ctx">7.7.2. be_ctx</a></li>
<li><a class="reference internal" href="#responder-facing-interactions">7.7.3. Responder-Facing Interactions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ad-provider-plugin">7.8. AD Provider Plugin</a><ul>
<li><a class="reference internal" href="#ad-provider-plugin-id-provider">7.8.1. AD Provider Plugin: id_provider</a></li>
<li><a class="reference internal" href="#ad-provider-plugin-auth-provider-and-chpass-provider">7.8.2. AD Provider Plugin: auth_provider and chpass_provider</a><ul>
<li><a class="reference internal" href="#parent-child">7.8.2.2.1. Parent =&gt; Child</a></li>
<li><a class="reference internal" href="#child-parent">7.8.2.2.2. Child=&gt;Parent</a><ul>
<li><a class="reference internal" href="#kdcinfo-files">7.8.2.3. kdcinfo files</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#ad-provider-plugin-access-provider">7.8.3. AD Provider Plugin: access_provider</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#tevent-basics">8. Tevent Basics</a><ul>
<li><a class="reference internal" href="#events">8.1. Events</a></li>
<li><a class="reference internal" href="#requests">8.2. Requests</a></li>
<li><a class="reference internal" href="#subrequests">8.3. Subrequests</a></li>
</ul>
</li>
<li><a class="reference internal" href="#functions">9. Functions</a><ul>
<li><a class="reference internal" href="#sdap-connection-functions">9.1. SDAP Connection Functions</a><ul>
<li><a class="reference internal" href="#sdap-id-op-connect-send-recv">9.1.1. sdap_id_op_connect_send/recv</a></li>
<li><a class="reference internal" href="#sdap-cli-connect-send-recv">9.1.2. sdap_cli_connect_send/recv</a></li>
<li><a class="reference internal" href="#be-resolve-server-send-recv">9.1.3. be_resolve_server_send/recv</a></li>
<li><a class="reference internal" href="#fo-resolve-service-send-recv">9.1.4. fo_resolve_service_send/recv</a></li>
<li><a class="reference internal" href="#resolv-gethostbyname-send-recv">9.1.5. resolv_gethostbyname_send/recv</a></li>
<li><a class="reference internal" href="#resolv-gethostbyname-dns-send-recv">9.1.6. resolv_gethostbyname_dns_send/recv</a></li>
<li><a class="reference internal" href="#sdap-connect-send-recv">9.1.7. sdap_connect_send/recv</a></li>
<li><a class="reference internal" href="#sss-ldap-init-send-recv">9.1.8. sss_ldap_init_send/recv</a></li>
<li><a class="reference internal" href="#sdap-get-rootdse-send-recv">9.1.9. sdap_get_rootdse_send/recv</a></li>
<li><a class="reference internal" href="#sdap-kinit-send-recv">9.1.10. sdap_kinit_send/recv</a></li>
<li><a class="reference internal" href="#sdap-get-tgt-send-recv">9.1.11. sdap_get_tgt_send/recv</a></li>
<li><a class="reference internal" href="#sdap-auth-send-recv">9.1.12. sdap_auth_send/recv</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sdap-operation-request-functions">9.2. SDAP Operation Request Functions</a><ul>
<li><a class="reference internal" href="#users-get-send-recv">9.2.1. users_get_send/recv</a></li>
<li><a class="reference internal" href="#sdap-get-generic-send-recv">9.2.2. sdap_get_generic_send/recv</a></li>
<li><a class="reference internal" href="#sdap-get-generic-ext-send-recv">9.2.3. sdap_get_generic_ext_send/recv</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#filesystem-locations">10. Filesystem Locations</a></li>
<li><a class="reference internal" href="#helpful-links">11. Helpful Links</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/InternalsDocs.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Red Hat.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/InternalsDocs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>