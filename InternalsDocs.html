<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#a1.Introduction">1. Introduction</a>
  </li>
  <li>
    <a href="#a2.ActiveDirectoryUseCase">2. Active Directory Use Case</a>
  </li>
  <li>
    <a href="#a3.SystemOverview">3. System Overview</a>
    <ol>
      <li>
        <a href="#a3.1.ExternalPerspective">3.1. External Perspective</a>
        <ol>
          <li>
            <a href="#a3.1.1.SSSClientApplications">3.1.1. SSS Client Applications</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a3.2.InternalPerspective">3.2. Internal Perspective</a>
        <ol>
          <li>
            <a href="#a3.2.1.ControlFlow">3.2.1. Control Flow</a>
          </li>
          <li>
            <a href="#a3.2.2.DataFlow">3.2.2. Data Flow</a>
            <ol>
              <li>
                <ol>
                  <li>
                    <a href="#a3.2.2.1.DataFlowNSSResponder">3.2.2.1. Data Flow (NSS Responder)</a>
                  </li>
                  <li>
                    <a href="#a3.2.2.2.DataFlowPAMResponder">3.2.2.2. Data Flow (PAM Responder)</a>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a3.3.SSSDComponents">3.3. SSSD Components</a>
        <ol>
          <li>
            <a href="#a3.3.1.ProcessesandSharedObjects">3.3.1. Processes and Shared Objects</a>
            <ol>
              <li>
                <a href="#a3.3.1.1.SSSClientLibrary">3.3.1.1. SSS Client Library</a>
              </li>
              <li>
                <a href="#a3.3.1.2.Monitor">3.3.1.2. Monitor</a>
              </li>
              <li>
                <a href="#a3.3.1.3.Responder">3.3.1.3. Responder</a>
              </li>
              <li>
                <a href="#a3.3.1.4.BackendakaDataProvider">3.3.1.4. Backend (aka Data Provider)</a>
              </li>
              <li>
                <a href="#a3.3.1.5.ProviderPlugin">3.3.1.5. Provider Plugin</a>
              </li>
              <li>
                <a href="#a3.3.1.6.Short-LivedChildProcess">3.3.1.6. Short-Lived Child Process</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#a3.3.2.Protocols">3.3.2. Protocols</a>
          </li>
          <li>
            <a href="#a3.3.3.UNIXsignals">3.3.3. UNIX signals</a>
          </li>
          <li>
            <a href="#a3.3.4.Databases">3.3.4. Databases</a>
          </li>
          <li>
            <a href="#a3.3.5.SambaLibraries">3.3.5. Samba Libraries</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a4.AdvancedTopics">4. Advanced Topics</a>
    <ol>
      <li>
        <a href="#a4.1.OfflineMode">4.1. Offline Mode</a>
      </li>
      <li>
        <a href="#a4.2.MultipleDomainsandTrustRelationships">4.2. Multiple Domains and Trust Relationships</a>
        <ol>
          <li>
            <a href="#a4.2.1.ADConcepts">4.2.1. AD Concepts</a>
          </li>
          <li>
            <a href="#a4.2.2.DomainStanzavs.Domain">4.2.2. Domain Stanza vs. Domain</a>
          </li>
          <li>
            <a href="#a4.2.3.SSSDImplementation">4.2.3. SSSD Implementation</a>
            <ol>
              <li>
                <a href="#a4.2.3.1.Subdomains">4.2.3.1. Subdomains</a>
              </li>
              <li>
                <a href="#a4.2.3.2.GlobalCatalogGC">4.2.3.2. Global Catalog (GC)</a>
              </li>
              <li>
                <a href="#a4.2.3.3.PACResponder">4.2.3.3. PAC Responder</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a5.SSSDWrappers">5. SSSD Wrappers</a>
    <ol>
      <li>
        <a href="#a5.1.SBus">5.1. SBus</a>
        <ol>
          <li>
            <a href="#a5.1.1.SBusConcepts">5.1.1. SBus Concepts</a>
            <ol>
              <li>
                <a href="#a5.1.1.1.SBusConnections">5.1.1.1. SBus Connections</a>
              </li>
              <li>
                <a href="#a5.1.1.2.CreatingSBusClientsandServers">5.1.1.2. Creating SBus Clients and Servers</a>
              </li>
              <li>
                <a href="#a5.1.1.3.SendingandReceivingSBusMessages">5.1.1.3. Sending and Receiving SBus Messages</a>
              </li>
              <li>
                <a href="#a5.1.1.4.DescribingtheSBUSinterface">5.1.1.4. Describing the SBUS interface</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#a5.1.2.Responder-to-BackendAPI">5.1.2. Responder-to-Backend API</a>
            <ol>
              <li>
                <a href="#a5.1.2.1.getAccountInfo">5.1.2.1. getAccountInfo</a>
                <ol>
                  <li>
                    <a href="#a5.1.2.1.1.RequestNSSPAMResponder-Backend">5.1.2.1.1. Request (NSS/PAM Responder-&gt;Backend)</a>
                  </li>
                  <li>
                    <a href="#a5.1.2.1.2.ResponseBackendNSSPAMResponder">5.1.2.1.2. Response (Backend=&gt;NSS/PAM Responder)</a>
                  </li>
                </ol>
              </li>
              <li>
                <a href="#a5.1.2.2.pamHandler">5.1.2.2. pamHandler</a>
                <ol>
                  <li>
                    <a href="#a5.1.2.2.1.RequestPAMResponder-Backend">5.1.2.2.1. Request (PAM Responder -&gt; Backend)</a>
                  </li>
                  <li>
                    <a href="#a5.1.2.2.2.ResponsePAMResponder-Backend">5.1.2.2.2. Response (PAM Responder -&gt; Backend)</a>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a5.2.SDAP">5.2. SDAP</a>
        <ol>
          <li>
            <a href="#a5.2.1.SDAPConcepts">5.2.1. SDAP Concepts</a>
          </li>
          <li>
            <a href="#a5.2.2.EstablishinganLDAPConnection">5.2.2. Establishing an LDAP Connection</a>
          </li>
          <li>
            <a href="#a5.2.3.PerformingLDAPOperations">5.2.3. Performing LDAP Operations</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a6.CommonDataStructures">6. Common Data Structures</a>
    <ol>
      <li>
        <a href="#a6.1.tevent_context">6.1. tevent_context</a>
      </li>
      <li>
        <a href="#a6.2.confdb_ctx">6.2. confdb_ctx</a>
      </li>
      <li>
        <a href="#a6.3.sysdb_ctx">6.3. sysdb_ctx</a>
      </li>
      <li>
        <a href="#a6.4.main_context">6.4. main_context</a>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a7.ComponentDetails">7. Component Details</a>
    <ol>
      <li>
        <a href="#a7.1.Monitor">7.1. Monitor</a>
        <ol>
          <li>
            <a href="#a7.1.1.SpawningandRegisteringProcesses">7.1.1. Spawning and Registering Processes</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.2.SSSClient">7.2. SSS Client</a>
        <ol>
          <li>
            <a href="#a7.2.1.SSS_CLI">7.2.1. SSS_CLI</a>
          </li>
          <li>
            <a href="#a7.2.2.NSSClient">7.2.2. NSS Client</a>
          </li>
          <li>
            <a href="#a7.2.3.PAMClient">7.2.3. PAM Client</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.3.Responder">7.3. Responder</a>
        <ol>
          <li>
            <a href="#a7.3.1.resp_ctx">7.3.1. resp_ctx</a>
          </li>
          <li>
            <a href="#a7.3.2.Client-FacingInteractionsGeneric">7.3.2. Client-Facing Interactions (Generic)</a>
          </li>
          <li>
            <a href="#a7.3.3.CommonOptimizationTechniques">7.3.3.Common Optimization Techniques</a>
            <ol>
              <li>
                <a href="#a7.3.3.1.DataProviderRequestTable">7.3.3.1. Data Provider Request Table</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.4.NSSResponder">7.4. NSS Responder</a>
        <ol>
          <li>
            <a href="#a7.4.1.nss_ctx">7.4.1. nss_ctx</a>
          </li>
          <li>
            <a href="#a7.4.2.Client-FacingInteractionsNSS">7.4.2. Client-Facing Interactions (NSS)</a>
          </li>
          <li>
            <a href="#a7.4.3.Backend-FacingInteractionsNSS">7.4.3. Backend-Facing Interactions (NSS)</a>
          </li>
          <li>
            <a href="#a7.4.4.CodeFlowNSS">7.4.4. Code Flow (NSS)</a>
          </li>
          <li>
            <a href="#a7.4.5.OptimizationTechniquesNSS">7.4.5. Optimization Techniques (NSS)</a>
            <ol>
              <li>
                <a href="#a7.4.5.1.NegativeCache">7.4.5.1. Negative Cache</a>
              </li>
              <li>
                <a href="#a7.4.5.2.FastCacheakamemcache">7.4.5.2. Fast Cache (aka memcache)</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.5.PAMResponder">7.5. PAM Responder</a>
        <ol>
          <li>
            <a href="#a7.5.1.pam_ctx">7.5.1. pam_ctx</a>
          </li>
          <li>
            <a href="#a7.5.2.Client-FacingInteractionsPAM">7.5.2. Client-Facing Interactions (PAM)</a>
          </li>
          <li>
            <a href="#a7.5.3.Backend-FacingInteractionsPAM">7.5.3. Backend-Facing Interactions (PAM)</a>
          </li>
          <li>
            <a href="#a7.5.4.CodeFlowPAM">7.5.4. Code Flow (PAM)</a>
          </li>
          <li>
            <a href="#a7.5.5.OptimizationTechniquesPAM">7.5.5. Optimization Techniques (PAM)</a>
            <ol>
              <li>
                <a href="#a7.5.5.1.InitgroupsCache">7.5.5.1. Initgroups Cache</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.6.OptimizationsCodeFlow">7.6. Optimizations Code Flow</a>
      </li>
      <li>
        <a href="#a7.7.Backend">7.7. Backend</a>
        <ol>
          <li>
            <a href="#a7.7.1.BackendConcepts">7.7.1. Backend Concepts</a>
            <ol>
              <li>
                <a href="#a7.7.1.1.ServicesandServers">7.7.1.1. Services and Servers</a>
              </li>
              <li>
                <a href="#a7.7.1.2.NameResolution">7.7.1.2. Name Resolution</a>
              </li>
              <li>
                <a href="#a7.7.1.3.ConfigurationLines">7.7.1.3. Configuration Lines</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#a7.7.2.be_ctx">7.7.2. be_ctx</a>
          </li>
          <li>
            <a href="#a7.7.3.Responder-FacingInteractions">7.7.3. Responder-Facing Interactions</a>
            <ol>
              <li>
                <a href="#a7.7.3.1.RegisteringResponders">7.7.3.1. Registering Responders</a>
              </li>
              <li>
                <a href="#a7.7.3.2.ReceivingSBusMessages">7.7.3.2. Receiving SBus Messages</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a7.8.ADProviderPlugin">7.8. AD Provider Plugin</a>
        <ol>
          <li>
            <a href="#a7.8.1.ADProviderPlugin:id_provider">7.8.1. AD Provider Plugin: id_provider</a>
            <ol>
              <li>
                <a href="#a7.8.1.1.ad_id_ctx">7.8.1.1. ad_id_ctx</a>
              </li>
              <li>
                <a href="#a7.8.1.2.ad_account_info_handler">7.8.1.2. ad_account_info_handler</a>
              </li>
              <li>
                <a href="#a7.8.1.3.ad_check_online">7.8.1.3. ad_check_online</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#a7.8.2.ADProviderPlugin:auth_providerandchpass_provider">7.8.2. AD Provider Plugin: auth_provider and chpass_provider</a>
            <ol>
              <li>
                <a href="#a7.8.2.1.krb5_auth_ctx">7.8.2.1. krb5_auth_ctx</a>
              </li>
              <li>
                <a href="#a7.8.2.2.krb5_pam_handler">7.8.2.2. krb5_pam_handler</a>
                <ol>
                  <li>
                    <a href="#a7.8.2.2.1.ParentChild">7.8.2.2.1. Parent =&gt; Child</a>
                  </li>
                  <li>
                    <a href="#a7.8.2.2.2.ChildParent">7.8.2.2.2. Child=&gt;Parent</a>
                  </li>
                </ol>
              </li>
              <li>
                <a href="#a7.8.2.3.kdcinfofiles">7.8.2.3. kdcinfo files</a>
              </li>
            </ol>
          </li>
          <li>
            <a href="#a7.8.3.ADProviderPlugin:access_provider">7.8.3. AD Provider Plugin: access_provider</a>
            <ol>
              <li>
                <a href="#a7.8.3.1.ad_access_ctx">7.8.3.1. ad_access_ctx</a>
              </li>
              <li>
                <a href="#a7.8.3.2.ad_access_handler">7.8.3.2. ad_access_handler</a>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a8.TeventBasics">8. Tevent Basics</a>
    <ol>
      <li>
        <a href="#a8.1.Events">8.1. Events</a>
      </li>
      <li>
        <a href="#a8.2.Requests">8.2. Requests</a>
      </li>
      <li>
        <a href="#a8.3.Subrequests">8.3. Subrequests</a>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a9.Functions">9. Functions</a>
    <ol>
      <li>
        <a href="#a9.1.SDAPConnectionFunctions">9.1. SDAP Connection Functions</a>
        <ol>
          <li>
            <a href="#a9.1.1.sdap_id_op_connect_sendrecv">9.1.1. sdap_id_op_connect_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.2.sdap_cli_connect_sendrecv">9.1.2. sdap_cli_connect_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.3.be_resolve_server_sendrecv">9.1.3. be_resolve_server_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.4.fo_resolve_service_sendrecv">9.1.4. fo_resolve_service_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.5.resolv_gethostbyname_sendrecv">9.1.5. resolv_gethostbyname_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.6.resolv_gethostbyname_dns_sendrecv">9.1.6. resolv_gethostbyname_dns_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.7.sdap_connect_sendrecv">9.1.7. sdap_connect_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.8.sss_ldap_init_sendrecv">9.1.8. sss_ldap_init_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.9.sdap_get_rootdse_sendrecv">9.1.9. sdap_get_rootdse_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.10.sdap_kinit_sendrecv">9.1.10. sdap_kinit_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.11.sdap_get_tgt_sendrecv">9.1.11. sdap_get_tgt_send/recv</a>
          </li>
          <li>
            <a href="#a9.1.12.sdap_auth_sendrecv">9.1.12. sdap_auth_send/recv</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#a9.2.SDAPOperationRequestFunctions">9.2. SDAP Operation Request Functions</a>
        <ol>
          <li>
            <a href="#a9.2.1.users_get_sendrecv">9.2.1. users_get_send/recv</a>
          </li>
          <li>
            <a href="#a9.2.2.sdap_get_generic_sendrecv">9.2.2. sdap_get_generic_send/recv</a>
          </li>
          <li>
            <a href="#a9.2.3.sdap_get_generic_ext_sendrecv">9.2.3. sdap_get_generic_ext_send/recv</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#a10.FilesystemLocations">10. Filesystem Locations</a>
  </li>
  <li>
    <a href="#a11.HelpfulLinks">11. Helpful Links</a>
  </li>
</ol>
</div><p>
</p>
<p>
<strong>SSSD Internals (October, 2013)<br />Author: Yassir Elley</strong>
</p>
<h1 id="a1.Introduction">1. Introduction</h1>
<p>
The purpose of this document is to give a basic description of the internals of the SSSD implementation. The material in this document is accurate as of SSSD 1.10. It is assumed that the reader is already familiar with the external usage of SSSD. The intended audience of this document are new contributors to the SSSD project. This document is not intended to be comprehensive. For additional details on specific features, please refer to the various <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs.html"><span class="icon">​</span>Design Documents</a>. This document does not discuss the details of building, installing, and debugging SSSD. More information on these topics can be found in the <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DevRes.html"><span class="icon">​</span>Developer Pages</a>, and the <a class="ext-link" href="https://docs.pagure.org/sssd-test2/Documentation.html"><span class="icon">​</span>Documentation</a>. To be most useful, this document should be updated as appropriate, and reviewed at regular intervals.
</p>
<p>
In order to better understand the material and make things more concrete, this document starts by describing a specific use case (and configuration) that will be discussed throughout the document. The document starts with a high level end-to-end overview, and then deep-dives into detailed descriptions. The document is organized into the following sections:
</p>
<ul><li>Active Directory Use Case: specifies use case used throughout the document
</li><li>System Overview: end-to-end SSSD overview, including short descriptions of components
</li><li>Advanced Topics: offline operation, multiple domains, trust relationships
</li><li>SSSD Wrappers: SBus, SDAP
</li><li>Common Data Structures: data structures used by each SSSD process
</li><li>Component Details: gory details of each component
</li><li>Appendix: tevent, function descriptions, filesystem locations, helpful links
</li></ul><h1 id="a2.ActiveDirectoryUseCase">2. Active Directory Use Case</h1>
<p>
From an SSSD perspective, there are two main Active Directory (AD) use cases, depending on whether we are directly integrated with AD, or whether we are indirectly integrated with AD through IPA. For now, this document only covers the direct AD integration use case.
</p>
<p>
SSSD consumes DNS, LDAP, and Kerberos services in order to resolve server names, perform identity lookups, and perform security-related tasks. In an AD environment, all three services are typically provided by a single AD server.
</p>
<p>
In the direct AD integration use case, a host directly joins an AD domain. At this point, the AD's LDAP service creates a computer account for the host, and the AD's Kerberos service creates a service principal and shared secret credentials for the host. After these host credentials are installed in the host's keytab, the host looks to AD as any other Windows client, allowing us to leverage existing AD technology. The preceding steps to join a domain, as well as additional steps that generate appropriate configuration files, and kick off the master SSSD process (/usr/sbin/sssd), can all be performed by simply running “realm join <span style="color: #FF0000">foo.com</span>” as root. For more information on realmd, see <a class="ext-link" href="http://www.freedesktop.org/software/realmd/"><span class="icon">​</span>Realmd Page</a>.
</p>
<p>
For our use case, the SSSD configuration file (<em>/etc/sssd/sssd.conf</em>) simply specifies an NSS Responder, a PAM Responder, and a single Backend that uses an AD Provider Plugin to communicate with an AD server. We will use the following values for our use case. Throughout the document, we will mark these values (and derived values) in <span style="color: #FF0000">red</span>, to indicate that other values could have been used.
</p>
<ul><li>the AD domain is named “<span style="color: #FF0000">foo.com</span>”
</li><li>the AD server is named “<span style="color: #FF0000">adserver.foo.com</span>”
</li><li>the AD username and password we will use in our examples is "<span style="color: #FF0000">aduser@foo.com</span>" and ”<span style="color: #FF0000">adpass</span>”
</li></ul><p>
Using those values, our use case can be represented by the following SSSD configuration file:
</p>
<pre class="wiki">[sssd]				# information needed by the monitor is specified in [sssd]
domains = foo.com 		# each domain stanza corresponds to a Backend
services = nss, pam		# each configured service corresponds to a Responder

[nss]
default_shell = /bin/bash

[pam]				# SSSD should use default values for pam-related options

[domain/foo.com]		# on this line, foo.com represents a domain stanza
ad_domain = foo.com             # on this line, foo.com represents an AD domain
ad_server = adserver.foo.com
krb5_realm = FOO.COM
id_provider = ad
auth_provider = ad
chpass_provider = ad
access_provider = ad
</pre><p>
Note that one of SSSD's design goals is to allow its configuration file (<em>sssd.conf</em>) to be very short, where configuration values that are needed (but not provided) are populated by either using default values, or by using DNS to auto-discover the values.
</p>
<ul><li>if <em>ad_domain</em> is not specified, it defaults to the value of the domain stanza's name (e.g. <em>foo.com</em>)
</li><li>if <em>ad_server</em> is not specified, DNS service discovery is used to find an appropriate server
</li><li>if <em>auth_provider</em>, <em>chpass_provider</em>, or <em>access_provider</em> are not specified, they default to the value of the <em>id_provider</em> (e.g. <em>ad</em>).
</li></ul><p>
For example, if DNS service discovery were available, the domain configuration above could have equivalently been written as:
</p>
<pre class="wiki">[domain/foo.com]
id_provider = ad
krb5_realm = FOO.COM
</pre><h1 id="a3.SystemOverview">3. System Overview</h1>
<h2 id="a3.1.ExternalPerspective">3.1. External Perspective</h2>
<p>
Fundamentally, SSSD provides identity (NSS) and authentication (PAM) services to its SSS Client Applications using information stored in remote servers (e.g. AD Server, IPA Server). SSSD serves as a central point of enforcement and management for the local machine on which it is running. SSSD components are able to share consistent state because multiple technologies are configured in a single configuration file. SSSD also improves performance by maintaining a local SSSD Cache, and by the fact that SSSD only needs to maintain a single connection to each of the remote servers (while servicing multiple SSS Client Applications). SSSD can optionally use the local SSSD Cache to continue to provide identity and authentication services to users when they go offline.
</p>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 1" /></a>
</p>
<p>
<em>This diagram shows two different SSS Client Applications making NSS/PAM calls to SSSD. In order to fulfill the request, SSSD either uses a cached result (by consulting the Cache), or an up-to-date result (by contacting the AD Server using LDAP/KRB). As such, SSSD is acting in a server role for the SSS Client Applications, and in a client role with respect to AD.</em>
</p>
<h3 id="a3.1.1.SSSClientApplications">3.1.1. SSS Client Applications</h3>
<p>
Through the beauty of the pluggable NSS and PAM frameworks, an SSS Client Application (e.g. <em>ls</em>) is unaware that it is communicating with an SSS Client Library. An SSS Client Application simply calls a standard NSS or PAM function, which is mapped by the NSS/PAM runtime to a module-specific function name, and which is then delivered to an SSS Client Library (assuming that SSSD configuration has taken place). Note that we can either refer to a Client Library generically (e.g. “SSS Client Library”), or we can refer to it specifically (e.g. “NSS Client Library”).
</p>
<p>
Examples of NSS-using SSS Client Applications include <em>ls</em>, <em>id</em>, and <em>getent</em>. These commands call standard NSS functions, which include settors/gettors for several name databases (e.g. passwd, group, service, netgroup, etc). An entry in a name database can be retrieved by using an appropriate key (e.g. name, id, port, etc). Alternatively, the entries in a name database can be enumerated, although this can be quite inefficient for large databases. The full API supported by the NSS Client Library is defined in sss_nss.exports.
</p>
<p>
Examples of PAM-using SSS Client Applications include <em>login</em>, <em>su</em>, and <em>ssh</em>. These commands call standard PAM functions. However, unlike NSS functions, PAM functions are called within the context of a PAM transaction, which maintains the state for the entire transaction (including any input values set by the caller, such as username, etc). A typical PAM transaction looks like:
</p>
<div class="code"><pre>pam_start<span class="p">(</span><span class="s">"login"</span><span class="p">,</span> <span class="s">"aduser"</span><span class="p">,</span> <span class="o">&amp;</span>pam_conv<span class="p">,</span> <span class="o">&amp;</span>pamh<span class="p">);</span> <span class="c1">// initiate pam transaction
</span>pam_authenticate<span class="p">(</span>pamh<span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                      <span class="c1">// verify identity of user
</span>ret <span class="o">=</span> pam_acct_mgmt<span class="p">(</span>pamh<span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                   <span class="c1">// determine if user account is valid
</span><span class="k">if</span> <span class="p">(</span>ret <span class="o">==</span> PAM_NEW_AUTHTOK_REQD<span class="p">)</span>                <span class="c1">// if user password has expired
</span>   pam_chauthtok<span class="p">(</span>pamh<span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                      <span class="c1">// change user password
</span>pam_setcred<span class="p">(</span>pamh<span class="p">,</span> PAM_ESTABLISH_CRED<span class="p">);</span>          <span class="c1">// set user's credentials
</span>pam_open_session<span class="p">(</span>pamh<span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                       <span class="c1">// initiate session management
</span><span class="p">...</span>                                             <span class="c1">// non-pam code
</span>pam_close_session<span class="p">(</span>pamh<span class="p">,</span> <span class="mi">0</span><span class="p">)</span>                      <span class="c1">// terminate session management
</span>pam_end<span class="p">(</span>pamh<span class="p">,</span> ret<span class="p">);</span>                             <span class="c1">// terminate pam transaction
</span></pre></div><p>
The PAM conversation function (pam_conv), set by the caller, allows the implementation to communicate directly with the application. For example, the implementation of PAM functions that use passwords (i.e. pam_authenticate, pam_chauthtok) would use the registered PAM conversation function to prompt the user for a password.
</p>
<p>
The full API supported by the PAM Client Library is defined in pam_sss.c. Note that the PAM Client Library does not handle the pam_start() and pam_end() calls that surround a pam transaction, but it handles all of the PAM functions in between.
</p>
<h2 id="a3.2.InternalPerspective">3.2. Internal Perspective</h2>
<p>
This section gives an internal system overview of SSSD's control flow (i.e. messages used for control, configuration, initialization) and SSSD's data flow (i.e. messages related to data traffic resulting from client requests).
</p>
<h3 id="a3.2.1.ControlFlow">3.2.1. Control Flow</h3>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 2" /></a>
</p>
<p>
<em>This diagram shows SSSD's start-up procedure. The diagram only shows a single NSS Responder for clarity, but keep in mind that our use case requires two Responders (NSS and PAM).</em>
</p>
<ol><li>Monitor process initializes itself, which includes parsing configuration file (sssd.conf) and loading it into confdb. After it is loaded, the Monitor retrieves and applies Monitor-specific config from the confdb.
</li><li>Monitor spawns (i.e. fork/exec) a Backend process for the single domain specified in config.
</li><li>Backend process initializes itself, which includes sending <em>Register</em> message to Monitor, as well as dynamically loading AD Provider Plugin.
</li><li>Backend contacts confdb in order to retrieve and apply Backend-specific config.
</li><li>Monitor spawns an NSS Responder process (shown), as well as a PAM Responder (not shown).
</li><li>Responder process initializes itself, which includes sending <em>Register</em> message to Monitor, and sending separate <em>Register</em> message to Backend.
</li><li>Responder contacts confdb in order to retrieve and apply Responder-specific config.
</li><li>Monitor periodically sends <em>Ping</em> messages to registered processes, and restarts them as needed.
</li></ol><h3 id="a3.2.2.DataFlow">3.2.2. Data Flow</h3>
<p>
In this section, we will separately examine the internal data flow for the NSS Responder and the PAM Responder, since the data flow for the PAM Responder is more complicated. Note that all of the components in the Data Flow diagrams are under the SSSD team's control, except for the SSS Client Application and remote AD Server. Also note that this section assumes that we are in “online mode”, meaning that SSSD is able to communicate with the AD Server. In the “offline mode” case, we are only able to consult the Cache (since the AD Server is not reachable).
</p>
<h5 id="a3.2.2.1.DataFlowNSSResponder">3.2.2.1. Data Flow (NSS Responder)</h5>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 3" /></a>
</p>
<p>
<em>This diagram shows the data flow generated by an SSS Client Application making an NSS request to SSSD.</em>
</p>
<ol><li>SSS Client Application's request is handled by our dynamically loaded NSS Client Library, which consults the fast cache (aka memcache). If valid cache entry exists (unexpired), NSS Client Library immediately returns cached result to SSS Client Application.
</li><li>If no valid cache entry exists in fast cache, NSS Client Library sends client's NSS request to matching NSS Responder.
</li><li>NSS Responder consults Cache. If valid cache entry exists (unexpired), NSS Responder immediately returns cached result to SSS Client Application (this step not shown above)
</li><li>If no valid cache entry exists, NSS Responder sends <em>getAccountInfo</em> request message to Backend, asking Backend to update Cache with data corresponding to client's NSS request.
</li><li>Backend uses AD Provider Plugin to make LDAP call to remote AD Server and to retrieve response from AD Server.
</li><li>Backend updates Cache, and also sends <em>getAccountInfo</em> response message (containing status) to NSS Responder; this also serves as indication that Cache has been updated.
</li><li>NSS Responder reads updated result from Cache.
</li><li>NSS Responder returns updated result to NSS Client Library, which passes it to SSS Client Application.
</li></ol><h5 id="a3.2.2.2.DataFlowPAMResponder">3.2.2.2. Data Flow (PAM Responder)</h5>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 4" /></a>
</p>
<p>
<em>This diagram shows the data flow generated by an SSS Client Application making a PAM request to SSSD</em>
</p>
<ol><li>SSS Client Application's request is handled by our dynamically loaded PAM Client Library, which sends request to matching PAM Responder.
</li><li>Like the NSS Responder, the PAM Responder sends <em>getAccountInfo</em> request message to Backend, but only to ask it to update Cache with client's group memberships (i.e. initgroups)
</li><li>Backend uses AD Provider Plugin to make LDAP call to remote AD Server and to retrieve response.
</li><li>Backend updates Cache, and also sends <em>getAccountInfo</em> response message (containing status) to PAM Responder; this also serves as indication that Cache has been updated.
</li><li>PAM Responder reads updated initgroups information from Cache.
</li><li>PAM Responder sends <em>pamHandler</em> request message to Backend
</li><li>Backend uses AD Provider Plugin to retrieve response from Child Process, which makes the actual KRB calls; note that the Child Process (not shown) will be discussed later in the document
</li><li>Backend sends <em>pamHandler</em> response message (containing status) to PAM Responder
</li><li>PAM Responder returns updated result to PAM Client Library, which passes it to SSS Client Application.
</li></ol><p>
Clearly, the PAM Responder's data flow is different from the NSS Responder's data flow. The primary difference is that the result of a <em>pamHandler</em> request is not stored in the Cache. The <em>pamHandler</em> response message contains status information, most of which is passed back to the PAM Client Library. Another difference is that the NSS Responder sends the Backend only a single request message, corresponding to the SSS Client's request. In contrast, the PAM Responder sends two request messages: the first one to find the client's group memberships, and the second one corresponding to the SSS Client's request. There are a couple of reasons for this. First, the PAM Responder wants to ensure that the identity returned by LDAP is the same identity that should be used for authentication. Second, in the case where multiple domains are configured, the given identity is tried against each domain, in the same order as it appears in the <em>domains</em> line in sssd.conf. As soon as the requested identity has group memberships in a particular domain, that domain is used as <strong>the</strong> authoritative domain for that client request. Note that complications arising from the use of subdomains will be discussed later. Additional difference is that while the PAM responder always downloads the group memberships from the server (if reachable) even if the cache is up to date. This is to ensure correct authorization data on login, because group memberships are set on login on a Linux system.
</p>
<h2 id="a3.3.SSSDComponents">3.3. SSSD Components</h2>
<h3 id="a3.3.1.ProcessesandSharedObjects">3.3.1. Processes and Shared Objects</h3>
<p>
Despite the fact that its name suggests there is only a <strong>single</strong> daemon, the term “SSSD” usually refers to a <strong>set</strong> of daemons and shared objects that work together to provide identity and authentication services to SSS Client Applications. The following table summarizes the SSSD-related processes and shared objects needed for our AD use case (along with their configuration files). Note that default values are used for configuration fields that are not specified. A brief description of these components follows.
</p>
<table class="wiki">
<tr><td><em>Component Name</em></td><td style="text-align: left"><em>Component Configuration</em>
</td></tr><tr><td>Shared Object: NSS Client Library</td><td style="text-align: left">/etc/nsswitch.conf; using nss_sss.so module
</td></tr><tr><td>Shared Object: PAM Client Library</td><td style="text-align: left">/etc/pam.d/system-auth; using pam_sss.so module
</td></tr><tr><td>Process: Monitor</td><td style="text-align: left">/etc/sssd/sssd.conf: [sssd] stanza
</td></tr><tr><td>Process: NSS Responder</td><td style="text-align: left">/etc/sssd/sssd.conf: [nss] stanza
</td></tr><tr><td>Process: PAM Responder</td><td style="text-align: left">/etc/sssd/sssd.conf: [pam] stanza
</td></tr><tr><td>Process: Backend</td><td style="text-align: left">/etc/sssd/sssd.conf: [domain/<span style="color: #FF0000">foo.com</span>] stanza
</td></tr><tr><td>Shared Object: AD Provider Plugin</td><td style="text-align: left">/etc/sssd/sssd.conf: [domain/<span style="color: #FF0000">foo.com</span>] provider lines
</td></tr><tr><td>Process: Short-Lived Child Process</td><td style="text-align: left">no config; used to perform blocking operations
</td></tr></table>
<h4 id="a3.3.1.1.SSSClientLibrary">3.3.1.1. SSS Client Library</h4>
<p>
An SSS Client Library is a shared object that is dynamically loaded by an SSS Client Application in order to communicate with SSSD. While we have so far been careful to distinguish between the SSS Client Application and SSS Client Library, from now on, we shall drop the “Library” and refer to the SSS Client Library as simply SSS Client (or NSS Client or PAM Client). Indeed, when the code refers to “SSS Client” (or to identifiers prefixed with “sss_cli”), it is referring an SSS Client Library.
</p>
<h4 id="a3.3.1.2.Monitor">3.3.1.2. Monitor</h4>
<p>
The monitor is <strong>the</strong> master SSSD process that spawns other SSSD processes and ensures they stay alive. It also sends SBus messages to other SSSD processes if it detects networking status changes. For example, if SSSD is in offline mode, and the Monitor detects that a cable has been plugged in, the Monitor sends SBus messages to the other SSSD processes to go online immediately.
</p>
<h4 id="a3.3.1.3.Responder">3.3.1.3. Responder</h4>
<p>
A Responder is a process that receives requests from an SSS Client Library, and that returns responses to it. In order to ensure that the Responder and Cache have a consistent view of user data, most Responders (e.g. NSS Responder) fulfill the client’s request by retrieving data from the Cache (although the Cache may need to be updated first). The PAM Responder is an exception, in that the Backend returns authentication results directly to the PAM Responder (as opposed to storing them in the Cache). Having said that, the PAM Responder <strong>does</strong> store authentication-related data in the Cache, but this is only used for offline authentication, which will be discussed later in the document. Note that each Responder (NSS, PAM) runs in its own process.
</p>
<h4 id="a3.3.1.4.BackendakaDataProvider">3.3.1.4. Backend (aka Data Provider)</h4>
<p>
A Backend is a process that represents a domain stanza (e.g. [domain/<span style="color: #FF0000">foo.com</span>]) and that uses Provider Plugins to talk to remote servers (e.g. AD) in order to perform the necessary identity lookups and/or pam-related tasks. The term “Backend” is synonymous with the term “Data Provider”. In fact, while some parts of the code use the term “Backend” (or use “<em>be_</em>” prefixes), other parts of the code use the term “Data Provider” (or use “<em>dp_</em>” prefixes) to refer to a Backend. However, to prevent confusion between a Data Provider and Provider Plugin, this document uses the term “Backend” for this component. 
</p>
<p>
A Backend receives a request message from a Responder, processes the request message by communicating with a remote server, updates the Cache, and sends a response message to the Responder, which also serves as an indication that the Cache has been updated. Each domain stanza has its own Backend process, which dynamically loads one or more Provider Plugins (aka “Backend Modules”), which do the heavy lifting of communicating with the remote server. A Backend's configuration specifies the individual Provider Plugins to be used for each provider type, as information needed to access the remote server. Think of a Backend as a container, consisting of several individual provider types, each of which could potentially be using a different Provider Plugin.
</p>
<h4 id="a3.3.1.5.ProviderPlugin">3.3.1.5. Provider Plugin</h4>
<p>
A Provider Plugin is a shared object that is dynamically loaded by a Backend to communicate with remote servers. The role of a provider plugin is to provide plugin-specific implementations of generic functions used to handle requests and to determine whether or not we are in online mode. 
</p>
<p>
Each Provider Plugin has a name (e.g. AD), along with a set of provider types that it supports (id_provider, auth_provider, access_provider, chpass_provider, etc). Each individual <span style="color: #800080">provider type</span> could use a different <span style="color: #00ff00">Provider Plugin</span> (e.g. <span style="color: #800080">id_provider</span>=<span style="color: #00ff00">ldap</span>, <span style="color: #800080">auth_provider</span>=<span style="color: #00ff00">krb5</span>) or all of the individual provider types could use the same Provider Plugin (e.g. <span style="color: #800080">id_provider</span>=<span style="color: #00ff00">ad</span>, <span style="color: #800080">auth_provider</span>=<span style="color: #00ff00">ad</span>). You can tell which Provider Plugins are supported in the code by looking at the names of the subdirectories of the providers directory (i.e. ad, ipa, krb5, ldap, proxy, simple). Each provider plugin will require certain additional configuration information to be specified in sssd.conf (e.g. “<em>id_provider=ad</em>” will require the <em>ad_domain</em> field, which will be used to locate the actual AD server).
</p>
<h4 id="a3.3.1.6.Short-LivedChildProcess">3.3.1.6. Short-Lived Child Process</h4>
<p>
SSSD tries very hard not to make blocking function calls. The main exception is that we make blocking calls to access our various databases. However, those calls are expected to return very quickly, so they do not negatively affect our performance much. However, there are times when we have no choice but to call external libraries or commands that only support blocking semantics. For example, all calls to the MIT Kerberos library are blocking function calls. Similarly, in order to perform dynamic DNS (DDNS) updates, we call the <em>nsupdate</em> command, which will not necessarily return very quickly. In such scenarios, rather than having an SSSD process (which is running a tevent main loop) perform a blocking operation, the SSSD process spawns a short-lived Child Process, which performs the blocking operation on the parent's behalf. As soon as the child process is spawned, the parent process asynchronously sends it a request (using UNIX pipes), and then returns control to its tevent main loop, thereby maintaining aysnchronous semantics. The child process then performs the blocking operation. Later, when the operation is finally complete, the child process sends the parent process the result (which it asynchronously reads), and then exits. It may seem inefficient to spawn a new child process each time a blocking operation needs to performed. However, these blocking operations are called relatively infrequently. If this were to present a problem in the future, a dedicated pool of child processes could be used. Instances in which Child Processes are currently used in the code include:
</p>
<ul><li>during gssapi-bind authentication for ldap searches (kerberos function calls)
</li><li>during kinit of behalf of user (kerberos function calls)
</li><li>during the update of client records using dynamic dns (<em>nsupdate</em>)
</li></ul><h3 id="a3.3.2.Protocols">3.3.2. Protocols</h3>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 5" /></a>
</p>
<p>
<em>This diagram shows the protocols used between various SSSD components.</em>
</p>
<ul><li><strong>DBus</strong>: used for local IPC between Responders, Backends, and Monitor. Note that SSSD uses SBus (“SSSD DBus”) as a wrapper around the DBus library (libdbus), in order to integrate the DBus API with the tevent main loop. 
</li><li><strong>LDAP</strong>: used by a Provider Plugin to send LDAP operation requests to a remote LDAP server. Note that SSSD uses SDAP (“SSSD LDAP”) as a wrapper around the OpenLDAP library (libldap), in order to integrate the OpenLDAP API with the tevent main loop.
</li><li><strong>Kerberos</strong>: used by a Provider Plugin or short-lived Child Process to perform Kerberos operations. Since the MIT Kerberos library (libkrb5) does not support non-blocking calls, any Kerberos function call that requires communicating with a remote Kerberos server (KDC) will result in the spawning of a short-lived Child Process. A Kerberos function call that operates locally (reading a keytab, writing a ccache, parsing names, etc) can be handled directly in the Provider Plugin, and does not require a short-lived Child Process to be spawned.
</li><li><strong>DNS</strong>: used by a Provider Plugin to interact with a remote DNS server in order to resolve server names (using standard A/AAAA address records) or to resolve service names (using domain-specific SRV records). While SSSD doesn't use a wrapper around the C-Ares DNS library (libcares), it does perform the necessary tasks to integrate the library with the tevent main loop.
</li><li><strong>SSS_CLI</strong>: an SSSD-specific custom protocol that is used by an SSS Client to communicate with its matching Responder. SSS_CLI is a request/response protocol that communicates over raw Unix Domain Sockets, using its own TLV-encoding.
</li></ul><h3 id="a3.3.3.UNIXsignals">3.3.3. UNIX signals</h3>
<p>
Apart from the internal SBUS communication, SSSD also uses UNIX signals for certain functionality - either for communication with external utilities or for cases where the SBUS communication might not work, such as an unresponsive worker process. Below is an overview of the supported signals and their use. The singal handlers are typically integrated with the tevent event loop using its <tt>tevent_add_signal</tt> call.
<dl class="wiki"><dt>SIGTERM</dt><dd>If a responder or a provider process fails to send a <tt>pong</tt> message to the monitor process after receiving the <tt>ping</tt> message, the monitor terminates the unresponsive process with a SIGTERM. Also used to terminate helper processes (such as the krb5_child process) in case of a timeout. 
</dd><dt>SIGKILL</dt><dd>In cases where an unresponsive worker process does not terminate after receiving SIGTERM, the monitor forcibly kills it with SIGKILL
</dd><dt>SIGUSR1</dt><dd>Can be handled a sssd_be process individually or the monitor process (in that case, the monitor re-sends the signal to all sssd_be processes it handles). Upon receiving this signal, the sssd_be process transitions into the 'offline' state. This signal is mostly useful for testing.
</dd><dt>SIGUSR2</dt><dd>Similar to the SIGUSR1 signal, the SIGUSR2 would cause an sssd_be process to reset the offline status and retry the next request it receives against a remote server.
</dd><dt>SIGHUP</dt><dd>Can be delivered to the sssd process. After receiving SIGHUP, the monitor rotates its logfile and sends a <tt>reset</tt> method to the managed processes. The managed processes also rotate logfiles. In addition, the sssd_be processes re-read resolv.conf and the sssd_nss process clears the fast in-memory cache.
</p>
</dd></dl>
<h3 id="a3.3.4.Databases">3.3.4. Databases</h3>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 6" /></a>
</p>
<p>
<em>This diagram shows which SSSD components access which SSSD databases.</em>
</p>
<ul><li><strong>Configuration DB (confdb)</strong>: a single memory-mapped LDB database in which the parsed contents of the SSSD configuration file are stored by the Monitor process, upon initialization. Any SSSD process can read from the Configuration DB, while only a few (e.g. Monitor) can write to it. The configuration DB is typically found at /var/lib/sss/db/config.ldb
</li><li><strong>System DB (sysdb)</strong>: a per-domain memory-mapped LDB database, which caches responses of recently sent requests. The sysdb is written to by the Backend, and read by the Responders. Even though this is a per-domain database, it is sometimes referred to generally as the System Cache. Since our use case only has a single domain, the System Cache and System DB refer precisely to the same LDB database. The System DB for a domain named "<span style="color: #FF0000">foo.com</span>” is typically found at /var/lib/sss/db/cache_<span style="color: #FF0000">foo.com</span>.ldb
</li><li><strong>Fast Cache (memcache)</strong>: a single set of memory-mapped cache files, from which an SSS Client can retrieve identity (NSS) information without having to contact the NSS Responder. The NSS Responder populates the memcache files, while the SSS Client reads the memcache files. Currently, only two maps that are supported: the password map (/var/lib/sss/mc/passwd) and the group map (/var/lib/sss/mc/group). If the memcache does not have the necessary information, then the SSS Client falls back to using the NSS Responder. Note that this mechanism is not used by the PAM Responder. Note also that this Fast Cache (memcache) is not considered part of the System Cache (sysdb).
</li></ul><h3 id="a3.3.5.SambaLibraries">3.3.5. Samba Libraries</h3>
<ul><li><strong>LDB</strong>: database library that uses an ldap-like data model (although schema-less). While using a TDB backend to provide the actual storage, LDB manipulates the TDB data into an LDAP-like structure; TDB is a very simple in-memory key/value database that stores data in binary format and supports transactions. For more information, refer to <a class="ext-link" href="http://wiki.samba.org/index.php/Samba4/LDBIntro"><span class="icon">​</span>LDB Tutorial</a>.
</li><li><strong>Talloc</strong>: a hierarchical memory allocator in which each dynamically allocated memory chunk can have a parent, as well as children. When a data structure is freed (using talloc_free), it frees not only itself but all of its children as well. Additionally, talloc maintains a reference to the allocated data structure's type, providing type checking when casting from a void pointer to a typed pointer (assuming you perform the cast by calling talloc_get_type). For more information, refer to <a class="ext-link" href="http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html"><span class="icon">​</span>Talloc Tutorial</a>
</li><li><strong>Tevent</strong>: a talloc-based event system that provides a main loop that supports the asynchronous processing of several event types (e.g. timers, file descriptors). Each SSSD process (Monitor, Responder, Backend) is single-threaded, and each process runs its own tevent main loop, which dispatches events using registered event handlers (and contexts). Tevent also facilitates the writing of asynchronous code by introducing the concept of tevent requests, where one request can call sub-requests, allowing for better modularization of the codebase. Using tevent on top of talloc gives us the ability to trivially cancel tevent requests (by simply freeing the tevent_req pointer), which will also automatically free resources of all descendant subrequests (e.g. children, grandchildren, etc). It is common to cancel a tevent request when an associated timer event expires, since this prevents us from waiting indefinitely for results. For more information, refer to <a class="ext-link" href="http://tevent.samba.org/tevent_tutorial.html"><span class="icon">​</span>Tevent Tutorial</a>.
</li></ul><h1 id="a4.AdvancedTopics">4. Advanced Topics</h1>
<h2 id="a4.1.OfflineMode">4.1. Offline Mode</h2>
<p>
So far, we have been assuming that SSSD is in online mode, but SSSD can transition from online mode to offline mode and back again, depending on whether its AD server is reachable on the network. When reachable, SSSD is in online mode and remains in online mode, unless the AD server becomes unreachable (e.g. perhaps because of a temporary failure). Similarly, once in offline mode, SSSD remains in offline mode, unless the AD server becomes reachable (more on that in a bit).
</p>
<p>
When SSSD is in online mode, it receives various requests from the SSS Client, which it initially fulfills by contacting the AD server and storing the identity lookup result or authentication artifacts in the Cache. Authentication artifacts refer to data needed to reproduce an authentication result when SSSD is offline. Specifically, when a presented username and password are able to authenticate successfully (i.e. when we receive PAM_SUCCESS from an authenticate operation), we perform a one-way hash on that password and store it in the user's Cache entry. If we go offline, and we need to re-authenticate the user, the user again enters the username and password, and we are able to perform the offline authentication, by hashing the presented password and comparing it to the authentication artifact in the user's entry. Of course, while SSSD is in online mode, we never use these authentication artifacts. 
</p>
<p>
Once a TGT has been acquired (which requires a valid password), SSSD can automatically renew the TGT at a configurable interval. If the AD server becomes unreachable, then SSSD enters offline mode, at which time any registered offline callback functions are called. For example, one offline callback function disables the regularly scheduled renewal of TGTs (since contacting the AD server is not possible). While offline, SSSD can only fulfill requests directly from the Cache. However, if a cache entry expires while offline, SSSD continues to honor the cache entry, until SSSD returns to online mode. If the AD server becomes reachable again, SSSD enters online mode, at which time any registered online callback functions are called. For example, one online callback uses the user's plaintext password stored in the kernel's keyring (only if explicitly enabled by config) to automatically request a TGT upon entering online mode, without prompting the user for the password.
</p>
<p>
Since multiple AD servers can be configured (i.e. for failover purposes), SSSD only goes offline if <strong>none</strong> of the configured AD servers are reachable. The circumstances under which a server is considered unreachable include the following:
</p>
<ul><li>SSSD is unable to resolve server's name
</li><li>SSSD is able to resolve server's name, but is unable to connect to service on server
</li><li>SSSD is not connected to the network
</li></ul><p>
Once offline, SSSD attempts to transition back to online mode by attempting to reconnect every 30 seconds. In addition to this polling, there are two notification mechanisms used (by the Monitor) that may result in an earlier transition to online mode. The Monitor uses netlink to receive notifications from the kernel when networking state has changed (e.g. cable is plugged in, routing table is changed, etc). If notified of a change, the Monitor sends SBus messages to all Backends to <em>resetOffline</em> (i.e. before the hard-coded 30 seconds), which means that they should attempt to retry the next network operation. If successful, SSSD transitions to online mode; it not successful (e.g. if the remote server is down), SSSD remains offline. Separately, the Monitor uses inotify to receive notifications when the DNS configuration in /etc/resolv.conf has changed. If notified of a change, the Monitor sends SBus messages to all Responders and Backends to immediately reload /etc/resolv.conf, which may result in a transition to online mode (i.e. if failed name resolution had earlier caused the transition to offline mode). Finally, during initialization, the Monitor registers tevent_signal events that are triggered by receiving the SIGUSR1 (go offline) and SIGUSR2 (go online) signals. If the Monitor receives either of those signals, it sends SBus messages to all Backends to go offline or to go online (and reload /etc/resolv.conf), at which time the appropriate offline or online callbacks are called, respectively. For the remainder of the document, unless otherwise stated, we assume that SSSD is in online mode.
</p>
<h2 id="a4.2.MultipleDomainsandTrustRelationships">4.2. Multiple Domains and Trust Relationships</h2>
<h3 id="a4.2.1.ADConcepts">4.2.1. AD Concepts</h3>
<p>
Things are relatively straightforward if we restrict ourselves to a single domain. In an AD context, this restriction means that only objects (e.g. users, computers, etc) managed by the domain controller (DC) for that single domain are able to interact with each other. For example, a user in Domain A (i.e. User A) can authenticate with DC A, and attempt to access Service A, after receiving the appropriate Kerberos service ticket for that service from DC A. Service A's ACL is then evaluated to see if User A has permission to use Service A. If not, a query can be made to DC A to obtain User A's group memberships, after which the ACL could be re-evaluated and a final authorization decision could be made. However, this only works because DC A has all the necessary information (keys, group memberships, etc) for each of the managed objects in its domain (i.e. users, groups, computers, resources, etc). 
</p>
<p>
An attempt by User A to access Service B (which is not managed by DC A) would be unsuccessful. DC A would have no way of generating a Kerberos service ticket for Service B, since there is no shared secret for Service B in its security principal database. For the same reason, Service B would be unable to obtain User A's group memberships from DC A (since AD typically requires authenticated LDAP searches). And why would Service B even trust the information it received from DC A? 
</p>
<p>
All of these issues are resolved by the introduction of Kerberos trust relationships, which are used extensively in an AD environment. In fact, AD is usually deployed in a multi-domain forest topology, with two-way transitive trust relationships automatically created between each domain (by default). Creating a trust relationship between two domains involves setting up a shared secret between the two domains, so that they can issue cross-domain referrals for each other's users. With regard to the group membership issue, there are two components to the solution: a Global Catalog (GC) server, and Privilege Attribute Certificate (PAC) information. With regard to the GC Server, while each domain maintains all attributes for each of the managed objects in its domain, the GC server maintains a partial set of attributes for each object in the forest (i.e. in any domain in the forest). Also, while a domain's DC stores and manages its own domain groups (which can only consist of users from the same domain), the GC stores and manages universal groups (which can contain accounts from any domain in the forest). Finally, it would be nice if we just collected the user's group memberships when the user was authenticated, and then passed that information along in the Kerberos service tickets. In fact, this is exactly what is done. As part of user authentication, AD collects the user's group memberships (and other security-related information) into a PAC, which it then places in the TGT's AuthorizationData field. Later, when User A requests a service ticket for Service B, AD copies the PAC from the TGT to the service ticket. Service B can then extract the PAC when it receives the Service Ticket, making it easier and faster to come to an authorization decision.
</p>
<h3 id="a4.2.2.DomainStanzavs.Domain">4.2.2. Domain Stanza vs. Domain</h3>
<p>
Before moving on, we need to understand the difference between a domain stanza and an ad_domain. A domain stanza identifies a stanza in the sssd.conf file (e.g. [domain/<span style="color: #FF0000">foo.com</span>]), which specifies the ad_domain and other parameters needed by the Backend process that represents this domain stanza. As such, while the domain stanza and the ad_domain might both have the same name, the domain stanza is simply an arbitrary configuration label. The primary purpose of naming the domain stanza is so that it can be referenced by the domains line in the [sssd] stanza, which lists the active domain stanzas for which the Monitor should spawn Backend processes. While AD has full knowledge of the ad_domain named “<span style="color: #FF0000">foo.com</span>”, it knows nothing about the domain stanza named “<span style="color: #FF0000">foo.com</span>”.
</p>
<h3 id="a4.2.3.SSSDImplementation">4.2.3. SSSD Implementation</h3>
<p>
Even without trust relationships, we can have multiple domain stanzas in the configuration, each corresponding to a single Backend (and a single ad_domain). In this simpler case, a Responder still needs some way of determining to which Backend it should forward a particular client request. If the client request includes a fully-qualified username (i.e. including a domain name), then the Responder simply selects the Backend with a matching domain stanza name. If a fully-qualified username is not used (which is common), the Responder uses each Backend (in the same order as specified in the [sssd] stanza) to find the username's entry, stopping as soon as one is found.
</p>
<p>
Now, let's see what happens when trust relationships are introduced. In order to deal with multiple domains that have trust relationships between them, SSSD implements support for three separate, but related, features:
</p>
<ul><li>Subdomains
</li><li>Global Catalog
</li><li>PAC Responder
</li></ul><h4 id="a4.2.3.1.Subdomains">4.2.3.1. Subdomains</h4>
<p>
In the presence of trust relationships between ad_domains, things get complicated. Now, a single domain stanza, while still corresponding to a single Backend, may correspond to multiple ad_domains (the primary one, as well as several other ad_domains with which the primary ad_domain has direct or transitive trust relationships). As such, a single domain stanza (and Backend) can support multiple trusted ad_domains, which SSSD refers to as “subdomains” (not to be confused with DNS subdomains, which require a parent/child relationship). As such, regardless of whether or not a fully-qualified username is included in the client request, the Responder sends an SBus message to each Backend (in the same order as it is specified in the config), asking it to send back the list of subdomains it supports, and then attempts to find an entry for the username in each subdomain, stopping as soon as one is found, and moving on to the next Backend (and its subdomains) if not found. The concept of subdomains also applies to groups. 
</p>
<h4 id="a4.2.3.2.GlobalCatalogGC">4.2.3.2. Global Catalog (GC)</h4>
<p>
In a single ad_domain scenario, the Backend can use the standard LDAP interface of AD to lookup users and groups. However, the LDAP interface only returns information about the users and groups in that single ad_domain. In order to obtain forest-wide information, including universal group memberships, the Backend uses the GC interface of AD to lookup users and groups. Note that the GC is essentially an LDAP server running on a non-standard port.
</p>
<h4 id="a4.2.3.3.PACResponder">4.2.3.3. PAC Responder</h4>
<p>
Similar to other Responders, the PAC Responder is an SSSD Process which is spawned and managed by the Monitor. It registers itself with the Monitor and the Backend. Unlike other Responders, the PAC Responder is not called by an SSS Client Library. Rather, it is called by a short-lived Kerberos Child Process during Kerberos authentication. If a PAC exists in the Kerberos ticket, the Child Process sends the PAC, along with the user principal, to the PAC Responder. The PAC Responder decodes the information in the PAC, such as group membership from trusted domains, and updates the System Cache accordingly.
</p>
<p>
Having discussed the subdomains, global catalog, and pac responder concepts in this section, we will now return to our simplifying assumption for the remainder of the document: that only a single ad_domain (without any trust relationships) is being used. 
</p>
<h1 id="a5.SSSDWrappers">5. SSSD Wrappers</h1>
<p>
When SSSD calls an external library, it needs to maintain its tevent-based asynchronous semantics. We have already discussed the case in which the external library only supports blocking function calls (e.g. krb5). SSSD simply spawns a Child Process, which will make the blocking calls and will return the response to SSSD when its done (which may take some time). In this section, we discuss the case in which the external library does support non-blocking function calls (e.g. dbus, openldap). Since such external libraries were likely not written with the tevent main loop in mind, SSSD uses a wrapper around each external library in order to integrate it with the tevent main loop. This section examines the SBus wrapper (for the DBus library) and the SDAP wrapper (for the OpenLDAP library).
</p>
<h2 id="a5.1.SBus">5.1. SBus</h2>
<h3 id="a5.1.1.SBusConcepts">5.1.1. SBus Concepts</h3>
<p>
SBus is a wrapper library used to integrate the D-Bus library with the tevent main loop. SBus uses UNIX Domain Sockets to send messages between SBus Clients (which initiate new connections) and SBus Servers (which accept new connections). Note that SBus does not make use of the D-Bus message bus, but rather uses the D-Bus protocol in a point-to-point manner (mostly for data marshalling). Once an SBus connection has been established between an SBus Client and SBus Server, it becomes a peer-to-peer situation, in which either end can send and receive SBus messages. An SBus message is made up of a header and a body. Essentially, the header contains the method-name and its typed arguments, while the body contains specific values for each argument. In addition to this section, more information can be found at [SBus].
</p>
<h4 id="a5.1.1.1.SBusConnections">5.1.1.1. SBus Connections</h4>
<p>
The fundamental data structure used by SBus (for both SBus Clients and SBus Servers) is the sbus_connection object, which represents a peer-to-peer connection over which messages can be sent and received. Each peer's sbus_connection is created with one or more (in the case of the public DBus API) sbus intefaces, which specify the sbus_methods that the peer implements (essentially method/function pairs). These sbus_method name/function pairs are extremely useful when examining the code base, since they specify each process's message processing entry points. When a peer's socket receives an SBus message that targets one of its sbus_method names, the peer executes the corresponding sbus_method function.
</p>
<p>
SSSD has several peer-to-peer connections, where each peer can call sbus_methods specified in the other peer's sbus_interface. If we examine each sender/receiver pair, the sbus_methods called by the sender and implemented by the receiver are as follows (ones in bold are particularly important):
</p>
<ul><li>Control Traffic
<ul><li>Monitor =&gt; Backend or Responder
<ul><li><em>ping</em>: send messages to registered child processes to determine if they are alive
</li><li><em>resInit</em>: reload /etc/resolv.conf to get address of DNS server
</li><li><em>rotateLogs</em>: close current debug file; open new debug file
</li><li><em>clearMemcache</em> (NSS Responder only): reinitialize Fast Cache (memcache) maps
</li></ul></li><li>Monitor =&gt; Backend
<ul><li><em>goOffline</em>: mark process as offline; run any offline callbacks
</li><li><em>resetOffline</em>: attempt to go online; if successful, run any online callbacks
</li></ul></li><li>Backend or Responder =&gt; Monitor
<ul><li><em>getVersion</em>: called by process to retrieve monitor's version number
</li><li><em>RegisterService</em>: called by process to register itself with Monitor
</li></ul></li><li>Responder =&gt; Backend
<ul><li><em>RegisterService</em>: called by Responder to register itself with Backend
</li></ul></li></ul></li><li>Data Traffic
<ul><li><strong>Responder</strong> =&gt; <strong>Backend</strong>
<ul><li><strong><em>getAccountInfo</em>: initiate identity lookup (e.g. getpwnam, initgroups, etc)</strong>
</li><li><strong><em>pamHandler</em>: initiate pam-related functionality (e.g. authentication, acct mgmt, etc)</strong>
</li></ul></li><li>Backend =&gt; NSS Responder
<ul><li>initgrCheck: send user's group memberships (pre-refresh) to NSS Responder, so that it can determine if memberships have changed (between pre-refresh and post-refresh), in which case it can clean up the memcache accordingly. Note that this is not related to the Initgroups Cache (id_table) maintained by the PAM Responder.
</li></ul></li></ul></li></ul><h4 id="a5.1.1.2.CreatingSBusClientsandServers">5.1.1.2. Creating SBus Clients and Servers</h4>
<p>
In SSSD, SBus servers are run as part of the Monitor and Backend processes (but not the Responder processes). Each SBus server can be characterized by the following:
</p>
<ul><li>server_address:     well-known socket address on which server listens for connections
</li><li><em>srv_init_fn</em>:     connection initialization function
</li><li>srv_init_data:      connection initialization private data
</li></ul><p>
An SBus Server creates an sbus_connection object by calling <em>sbus_new_server</em> with the three parameters given above. Once created, an SBus Server begins listening for new connections at its well-known server_address. When it receives a new connection request from a Process, the SBus Server calls <em>sbus_server_init_new_connection</em>, which does the following:
</p>
<ul><li>creates a new per-connection sbus_connection object
</li><li>uses the previously specified <em>init_fn</em> and init_pvt_data to call <em>init_fn(conn, init_pvt_data)</em>
</li><li>registers the per-server interface (an instance of sbus_vtable) and the initialization private data with a call to <tt>sbus_new_interface</tt> at an object path. This vtable and private data would be used by the <tt>sbus_message_handler</tt> when a message targeted at the registered object path arrives.
</li></ul><p>
An SBus Client creates an sbus_connection object by calling <em>sbus_client_init</em> with the following parameters: server_address, intf, conn_pvt_data. Once created, an SBus Client can request a connection to the SBus Server listening at server_address, after which it can send messages supported by the SBus Server's sbus_interface. Once connected to an SBus Server, that SBus Server can send messages supported by the SBus Client's sbus_interface (intf). The conn_pvt_data is opaque data stored with the sbus_connection object, that can later be retrieved from the SBus Client. Each SBus Client in SSSD is associated with its SBus Server's server_address, its SBus Client intf, and SBus Client conn_pvt_data.
</p>
<pre class="wiki">NSS Responder =&gt; Monitor
    server_address:	/var/lib/sss/pipes/private/sbus-monitor
    methods:		monitor_nss_methods
    conn_pvt_data: 	resp_ctx

PAM Responder =&gt; Monitor
    server_address:	/var/lib/sss/pipes/private/sbus-monitor
    methods:		monitor_pam_methods
    conn_pvt_data: 	resp_ctx

Backend =&gt; Monitor
    server_address:	/var/lib/sss/pipes/private/sbus-monitor
    methods:		monitor_be_methods
    conn_pvt_data:	be_ctx

NSS Responder =&gt; Backend
    server_address:	/var/lib/sss/pipes/private/sbus-dp_foo.com (domain_name=foo.com)
    methods:		nss_dp_methods
    conn_pvt_data:	resp_ctx

PAM Responder =&gt; Backend
    server_address:	/var/lib/sss/pipes/private/sbus-dp_foo.com (domain_name=foo.com)
    methods:		pam_dp_methods
    conn_pvt_data:	resp_ctx
</pre><h4 id="a5.1.1.3.SendingandReceivingSBusMessages">5.1.1.3. Sending and Receiving SBus Messages</h4>
<p>
A sender calls <em>sbus_conn_send</em>(msg, <strong>reply_handler</strong>, pvt) in order to send a message, and to register a <strong>reply handler</strong>, which will handle the reply message. When the message arrives at the receiver, it calls <em>sbus_message_handler</em>, which extracts the sbus_interface and sbus_connection registered for that object path, and calls the function corresponding to the method name, with the request message and sbus_connection as inputs. The entry-point function does the following:
</p>
<ul><li>extracts its private data from the sbus_connection input
</li><li>extracts request arguments from the request message input
</li><li>performs method-specific processing using inputs to generate outputs
</li><li>creates a reply message that matches the request message (i.e. same serial number)
</li><li>appends output arguments to reply message
</li><li>sends back reply message on same sbus_connection on which it received the request
</li></ul><p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 7" /></a>
</p>
<p>
<em>This figure shows the functions used in the sending and receiving of an SBus message</em>
</p>
<h4 id="a5.1.1.4.DescribingtheSBUSinterface">5.1.1.4. Describing the SBUS interface</h4>
<p>
Starting with upstream version 1.12, when the SSSD implemented its public DBus interface, the SSSD switched from hardcoding interface names, methods etc in the source files directly to only describing the interfaces in XML files using the <a class="ext-link" href="http://dbus.freedesktop.org/doc/dbus-specification.html#introspection-format"><span class="icon">​</span>introspection format</a>, which are then used to autogenerate message handlers, property getters and similar. While using generated code might sound odd at first, using a code generator removes a large amount of code duplication, packing and unpacking from DBus types to C types or vice versa, or unpacking DBus message properties (if needed).
</p>
<p>
The code generator and the generated code are currently used for both the DBus public interface (which is outside the scope of this page) and the internal SBUS communication. The internal SBUS code, however, uses the generated code in a 'raw' mode mostly and still does packing/unpacking of the parameters on its own. The reason is that the 'raw' code in SSSD predates the code generator, is quite stable and tested and converting it to the easier handlers with unpacked parameters might cause functional regressions.
</p>
<p>
One example of the canonical XML code might be found in the <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/tests/sbus_codegen_tests.xml"><span class="icon">​</span>unit tests</a>, along with the <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/tests/sbus_codegen_tests_generated.c"><span class="icon">​</span>corresponding autogenerated code</a>. The XML files for the internal interfaces, such as the <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_iface.xml"><span class="icon">​</span>Data Provider</a> can also be inspected. Since all the internal interfaces use the raw approach, the autogenerated code is <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_iface_generated.c"><span class="icon">​</span>quite terse</a> and the <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/providers/data_provider_be.c"><span class="icon">​</span>interface handlers</a> do the packing and unpacking on their own.
</p>
<h3 id="a5.1.2.Responder-to-BackendAPI">5.1.2. Responder-to-Backend API</h3>
<p>
This section examines those sbus_methods exported in the Backend's SBus Interface that are called by the NSS/PAM Responders. For NSS requests, a Responder sends a <em>getAccountInfo</em> message to the Backend, which handles it by calling be_get_account_info. For PAM requests, a Responder sends a <em>pamHandler</em> message to the Backend, which handles it by calling be_pam_handler. The be_methods array of sbus_method objects specify the name/function pairs supported by the Backend.
</p>
<p>
Note that when the Backend receives an incoming SBus message, it creates a be_req object, and includes in that object a backend response callback. Once the Backend has completed processing the request (after contacting the AD Server, etc) and is ready to return a response to the Responder, the registered backend response callback is called. More on this below.
</p>
<h4 id="a5.1.2.1.getAccountInfo">5.1.2.1. getAccountInfo</h4>
<h5 id="a5.1.2.1.1.RequestNSSPAMResponder-Backend">5.1.2.1.1. Request (NSS/PAM Responder-&gt;Backend)</h5>
<p>
The <em>sbus_method</em> named <em>getAccountInfo</em> is sent by the NSS Responder and PAM Responder to the Backend for identity lookups. Note that while the NSS Responder is sending the message in response to an SSS Client request (e.g. getpwnam, getgrgid, etc), the PAM Responder only sends the message for group membership retrieval (regardless of the SSS Client request it is handling). As such, the INITGROUPS operation is handled differently by the Backend, as noted below.
</p>
<p>
The <em>getAccountInfo</em> request message takes the following four arguments:
</p>
<div class="code"><pre><span class="kt">int</span> <span class="nl">be_type:</span>    the operation to perform         <span class="c1">// e.g. USER, GROUP, INITGROUPS, etc
</span><span class="kt">int</span> <span class="nl">attrs:</span>      attributes to be returned        <span class="c1">// e.g. CORE, MEM, ALL
</span><span class="kt">char</span> <span class="o">*</span><span class="nl">filter:</span>   the elements to select           <span class="c1">// e.g. "name=aduser", "idnumber=73", etc
</span><span class="kt">char</span> <span class="o">*</span><span class="nl">dom_name:</span> the domain name                  <span class="c1">// e.g. "foo.com", etc
</span></pre></div><p>
For example, an SBus request message representing getpwnam("<span style="color: #FF0000">aduser@foo.com</span>") includes the following input values:
</p>
<ul><li>be_type:    BE_REQ_USER
</li><li>attrs:      BE_ATTR_CORE
</li><li>filter:     "name=<span style="color: #FF0000">aduser</span>"
</li><li>domain:     "<span style="color: #FF0000">foo.com</span>"
</li></ul><p>
As specified in be_methods, the function on the Backend corresponding to this sbus_method name is <em>be_get_account_info</em>. For all operations other than INITGROUPS, <em>be_get_account_info</em> specifies acctinfo_callback as the backend response callback, after which it calls <em>ad_account_info_handler</em> to do the actual processing (for our AD use case). Once processing is complete, <em>acctinfo_callback</em> is called, which prepares the response message and sends it back to the Responder.
</p>
<p>
For the INITGROUPS operation, <em>be_get_account_info</em> specifies <em>acctinfo_initgroups_callback</em> as the backend response callback. In this case, once processing is complete, <em>acctinfo_initgroups_callback</em> is called, which sends an <em>initgrCheck</em> SBus message to the NSS Responder. As mentioned earlier, this allows the NSS Responder to compare the user's pre-refresh and post-refresh group memberships, so that it can clean up the memcache accordingly. Once the <em>initgrCheck</em> SBus message has been sent, then <em>acctinfo_callback</em> is called, which prepares the actual initgroups response message, and sends it back to the Responder.
</p>
<h5 id="a5.1.2.1.2.ResponseBackendNSSPAMResponder">5.1.2.1.2. Response (Backend=&gt;NSS/PAM Responder)</h5>
<p>
The SBus reply message for the <em>getAccountInfo</em> sbus_method contains the following three arguments:
</p>
<div class="code"><pre><span class="kt">int</span> <span class="nl">dp_err:</span>     error code                      <span class="c1">// e.g..DP_ERR_OK, DP_ERR_TIMEOUT, DP_ERR_OFFLINE
</span><span class="kt">int</span> <span class="nl">dp_ret:</span>     errno                           <span class="c1">// e.g. EOK, EINVAL
</span><span class="kt">char</span> <span class="o">*</span><span class="nl">err_msg:</span>  error message <span class="k">for</span> logging       <span class="c1">// e.g. “Success”, “Out of memory”
</span></pre></div><p>
For example, a successful SBus reply message would include the following output values:
</p>
<pre class="wiki">dp_err:		DP_ERR_OK
dp_ret:		EOK
err_msg:	NULL
</pre><p>
An unsuccessful SBus reply message might include the following output values:
</p>
<pre class="wiki">dp_err:		DP_ERR_FATAL
dp_ret:		EINVAL
err_msg: 	"Internal error”
</pre><p>
Note that the actual result of the request is written to the sysdb Cache by the Backend. The SBus response message is used not only to convey error/success information, but also to indicate to the Responder that it can retrieve the up-to-date result from the sysdb Cache. Initially, if an entry didn't exist in the Cache, it was considered a cache miss, and it resulted in an update cache request to the Backend. Now that the Backend has updated the cache, if an entry still doesn't exist in the Cache, it means that the entry really just doesn't exist.
</p>
<h4 id="a5.1.2.2.pamHandler">5.1.2.2. pamHandler</h4>
<h5 id="a5.1.2.2.1.RequestPAMResponder-Backend">5.1.2.2.1. Request (PAM Responder -&gt; Backend)</h5>
<p>
The sbus_method named <em>pamHandler</em> is sent by the PAM Responder to the Backend for PAM-related functionality, corresponding to PAM-supported library calls (e.g. pam_authenticate, pam_acct_mgmt, etc). When a caller (i.e. an SSS Client Application) calls a PAM function (e.g. pam_authenticate) with various inputs, the PAM Client includes a pam_items object in its client request to the PAM Responder, which stores the caller-specified inputs, as well as some additional information. In turn, when the PAM Responder receives the client request message, it extracts the many arguments and stores them in a pam_data object. Finally, the PAM Responder includes the pam_data object's many fields as arguments for the <em>pamHandler</em> message. These arguments include:
</p>
<div class="code"><pre><span class="kt">int</span> <span class="nl">cmd:</span>                <span class="c1">// e.g. SSS_PAM_AUTHENTICATE, etc
</span><span class="kt">char</span> <span class="o">*</span><span class="nl">domain:</span>           <span class="c1">// e.g. "foo.com", etc
</span><span class="kt">char</span> <span class="o">*</span><span class="nl">user:</span>             <span class="c1">// e.g. "aduser", etc
</span><span class="kt">int</span> <span class="nl">authtok_type:</span>       <span class="c1">// e.g. PASSWORD, CCFILE, etc
</span><span class="kt">int</span> <span class="o">*</span><span class="nl">authtok_data:</span>      <span class="c1">// e.g. "adpass", etc
</span></pre></div><p>
For example, an SBus request message representing pam_authenticate("<span style="color: #FF0000">aduser@foo.com</span>", "<span style="color: #FF0000">adpass</span>") includes the following input values:
</p>
<pre class="wiki">cmd:		SSS_PAM_AUTHENTICATE
domain: 	"foo.com"
user:		"aduser"
authtok_type:	SSS_AUTHTOK_TYPE_PASSWD
authtok_data:	"adpass"
</pre><p>
As specified in be_methods, the function on the Backend corresponding to this sbus_method name is <em>be_pam_handler</em>, which specifies <em>be_pam_handler_callback</em> as its backend response callback, after which it calls <em>krb5_pam_handler</em>(for the SSS_PAM_AUTHENTICATE or SSS_PAM_CHAUTHTOK commands) or <em>ad_access_handler</em> (for the SSS_PAM_ACCT_MGMT command). Once processing is complete, <em>be_pam_handler_callback</em> is called, which prepares the response message and sends it back to the Responder.
</p>
<h5 id="a5.1.2.2.2.ResponsePAMResponder-Backend">5.1.2.2.2. Response (PAM Responder -&gt; Backend)</h5>
<p>
The SBus reply message for the <em>pamHandler</em> sbus_method contains the pam status, followed by an array of responses, with each response consisting of a response type and response message. Note that after the Responder receives the responses, it includes them in its reply to the SSS Client (after filtering out certain response types). 
</p>
<p>
The pam_status argument (defined by the PAM library) can take one of many values, including the following (I have omitted the “PAM_” prefixes): SUCCESS, PERM_DENIED, ACCT_EXPIRED, AUTHINFO_UNAVAIL, NEW_AUTHTOK_REQD, CRED_ERROR, CRED_UNAVAIL, SYSTEM_ERR, AUTH_ERR
</p>
<p>
Let us examine some responses, each consisting of a {type, message} tuple. Some responses are intended for consumption by the SSS Client. These response types are documented in sss_cli.h.
Examples include:
</p>
<ul><li>{SSS_PAM_USER_INFO, SSS_PAM_USER_INFO_OFFLINE_CHPASS}
</li><li>{SSS_PAM_SYSTEM_INFO, “The user account is expired on the AD server"}
</li><li>{SSS_PAM_ENV_ITEM, “KRB5CCNAME=/run/user/...”}
</li><li>{SSS_PAM_DOMAIN_NAME, &lt;domain&gt;}
</li><li>{SSS_OTP, NULL}
</li></ul><p>
Other responses are filtered out by the PAM Responder, as they are not intended for the SSS Client. Examples include:
</p>
<ul><li>{SSS_KRB_INFO_TGT_LIFETIME, &lt;time&gt;}
</li><li>{SSS_KRB5_INFO_UPN, &lt;upn&gt;}
</li></ul><h2 id="a5.2.SDAP">5.2. SDAP</h2>
<h3 id="a5.2.1.SDAPConcepts">5.2.1. SDAP Concepts</h3>
<p>
SDAP (“SSSD LDAP”) is a wrapper around the OpenLDAP library. It is used to integrate the OpenLDAP API with the tevent main loop. It is also used to provide additional support for failover (among other things). Specifically, when an OpenLDAP connection is made to a particular LDAP server's IP address, OpenLDAP maintains only the server's hostname as part of its connection state. OpenLDAP periodically resolves the host name using DNS, which could result in the connection being transparently switched to another server with the same hostname, but different IP address (i.e. no server affinity). 
</p>
<p>
On the other hand, once an SDAP connection is made to a particular LDAP server's IP address, SDAP maintains the server's IP address as part of its connection state, meaning that the connection remains with that server (until it expires or goes offline). This allows us to have semantics where we failover only when that particular server fails (rather than having to deal with intermittent failures). Note that SDAP also maintains an LDAP URI as part of its connection state, in order to make certificate comparisons when TLS is used. 
</p>
<p>
All of this is possible because SDAP connects to the LDAP server itself (rather than relying on OpenLDAP to make the connection) and simply passing the resulting file descriptor to OpenLDAP using ldap_init_fd (when available). By owning the connection, SDAP has full control over how it wants to deal with failover, DNS resolution, etc. 
</p>
<p>
SDAP represents a connection to the LDAP server using the sdap_id_conn_data object. Once a connection is established (typically on the first operation request), it can be used multiple times to transfer LDAP operation requests and responses until the connection expires (or we go offline). For each LDAP operation request (e.g. bind, search, etc) , two objects are created: one for the operation request itself (sdap_op) and one for keeping track of retrying the operation request (sdap_id_op). 
</p>
<h3 id="a5.2.2.EstablishinganLDAPConnection">5.2.2. Establishing an LDAP Connection</h3>
<p>
Establishing an LDAP connection (<em>sdap_cli_connect_send</em>) is a multi-step process that involves the DNS server, the LDAP server, and the KDC. The steps involved are as follows:
</p>
<ul><li><em>be_resolve_server_send</em>: retrieve addressing information (ip/port) for AD's LDAP service
</li><li><em>sdap_connect_send</em>: connect to server; register incoming message handler (<em>sdap_ldap_result</em>)
</li><li><em>sdap_cli_rootdse_step</em>: attempt to anonymously retrieve the LDAP server's rootDSE
</li><li><em>sdap_cli_kinit_step</em>: obtain a TGT from a KDC (after retrieving its addressing information)
</li><li><em>sdap_cli_auth_step</em>: perform an LDAP bind (either sasl or simple); if we were unable to retrieve rootDSE info earlier (anonymously), we try to retrieve it again now that we're authenticated
</li></ul><h3 id="a5.2.3.PerformingLDAPOperations">5.2.3. Performing LDAP Operations</h3>
<p>
Once an authenticated connection has been established, including registering the <em>sdap_ldap_result</em> handler for incoming messages, we can start sending LDAP operations over the connection. The OpenLDAP API allows most operations to be performed with either synchronous or asynchronous funcions. In order to perform a synchronous LDAP operation, the appropriate synchronous API call is made (e.g. ldap_search_ext_s), and we block on that call until it completes (or times out). 
</p>
<p>
In order to perform an asynchronous LDAP operation, the appropriate asynchronous API call is made (e.g. ldap_search_ext), which returns a message id. We then call sdap_op_add, which creates an sdap_op object representing the operation (msgid, callback=<em>sdap_get_generic_ext_done</em>, and callback arg=req w/ sdap_get_generic_ext_state), and which adds the sdap_op object to the sdap handle's list of sdap_op objects.
</p>
<p>
Later, when a response is received on the fd, the tevent main loop calls the handler we registered when establishing the connection (i.e. <em>sdap_ldap_result</em>), which calls <em>ldap_result</em> with that message id in order to poll the library to check whether results have been received. If results have not been received, <em>ldap_result</em> returns 0, in which case we try polling for results again later on. If results have been received, <em>ldap_result</em> returns an LDAPMessage, which we proceed to process by calling <em>sdap_process_message</em>. We extract the msgid from the message, and iterate through our sdap_handle's list of sdap_op objects until we find an sdap_op with a matching msgid, at which point we add the message to the op's list and call the sdap_op's callback, passing it the LDAP message and the callback's arg. This callback switches on the msgtype of the message. If the reply message is a SEARCH_ENTRY, then we call the parse_cb registered earlier (as part of sdap_get_generic_ext_send). For sdap_get_generic_send, the parse_cb is <em>sdap_get_generic_parse_entry</em>. We then add a timer event to process the next reply after the timer expires. If the reply message is a SEARCH_RESULT, then we simply call <em>ldap_parse_result</em>.
</p>
<h1 id="a6.CommonDataStructures">6. Common Data Structures</h1>
<p>
This section describes some important data structures that are used by each of the SSSD Processes. In order to have a more readable description, the text below uses the term “Process” with a capital 'P' to interchangeably mean either the Monitor process, the Responder processes, or the Backend process. Exceptions to this rule are noted.
</p>
<p>
When it first starts, a Process calls the following functions:
</p>
<div class="code"><pre>server_setup<span class="p">()</span>                  <span class="c1">// creates main_context (includes tevent_ctx and confdb_ctx)
</span><span class="o">&lt;</span>process<span class="o">-</span>specific<span class="o">&gt;</span>_init<span class="p">()</span>       <span class="c1">// creates process-specific context
</span>server_loop<span class="p">()</span>                   <span class="c1">// calls tevent_loop_wait on tevent_ctx (to start the main loop)
</span></pre></div><h2 id="a6.1.tevent_context">6.1. tevent_context</h2>
<p>
The purpose of a Process's tevent_context is to contain the events that are to be monitored by that Process's main loop. As such, the primary interaction that a Process has with its tevent_context is to add/remove events. During startup, a Process calls the following tevent-related functions:
</p>
<div class="code"><pre>server_setup
        tevent_context_init     <span class="c1">// creates singleton tevent_context
</span><span class="o">&lt;</span>process<span class="o">-</span>specific<span class="o">&gt;</span> init
        tevent_add_<span class="o">*</span>            <span class="c1">// adds some events to tevent_context
</span>server_loop
        tevent_loop_wait        <span class="c1">// starts main loop using tevent_context
</span></pre></div><p>
Note that tevent_loop_wait initially monitors only the events in its just-populated tevent_context input argument. Once a Process's main loop has started, it adds additional events to its tevent_context as needed. Of the four types of events, the SSSD code primarily adds tevent_fd and tevent_timer events, using the <em>tevent_add_fd</em> and <em>tevent_add_timer</em> functions.
</p>
<h2 id="a6.2.confdb_ctx">6.2. confdb_ctx</h2>
<p>
The purpose of a Process's confdb_ctx is to allow the Process to interact with the Config DB (config.ldb). As such, the primary interaction that a Process has with the Config DB is to get or set configuration information, using functions such as <em>confdb_get_int</em> and <em>confdb_set_bool</em>. 
</p>
<p>
There is a single system-wide Config DB, which is initialized by the Monitor before it spawns the other processes. As part of its initialization, the Monitor calls load_configuration, which contains the confdb initialization code (specifically <em>confdb_init_db</em>). The load_configuration function reads the configuration text file (sssd.conf), parses it, and uses <em>ldb_add</em> to store the parsed values into the Config DB. As such, any changes made to sssd.conf after the Monitor has started will require the Monitor to be restarted. The Monitor parses sssd.conf using libiniconfig, resulting in minimal validation of configuration values; any additional validation is left to the SSSD code. However, once dinglibs adds support for schema validation, SSSD should be able to take advantage of it (since libiniconfig is based on dinglibs). 
</p>
<p>
Once the Config DB has been initially populated, a Process's initialization code calls <em>confdb_init()</em>, which internally calls <em>ldb_connect()</em> to connect to the Config DB, and which returns a new confdb_ctx that is needed for subsequent confdb calls. All of the gettor functions that interact with the confdb take the confdb_ctx as one of their input arguments. Generic accessor functions are provided in confdb.h, while plugin-specific accessor functions are also provided (e.g. ad_opts.h).
</p>
<p>
In summary, the following confdb-related functions are called during startup: 
</p>
<ul><li><strong>load_configuration (only called by Monitor)</strong> <em> initializes Config DB
</em></li><li>server_setup (called by all Processes)
<ul><li><strong>confdb_init</strong>  <em> creates singleton confdb_ctx
</em></li></ul></li><li>&lt;process-specific&gt; init
<ul><li><strong>confdb_get_*</strong> <em> retrieves config info from Config DB
</em></li></ul></li></ul><h2 id="a6.3.sysdb_ctx">6.3. sysdb_ctx</h2>
<p>
The purpose of a Process's sysdb_ctx is to allow the Process to interact with a domain's system cache (i.e. to get/set cached information for a domain). The exception to this is the Monitor process, which only initializes a sysdb_ctx in order to allow the sysdb to be upgraded at startup, which is typically needed when an upgrade to a new SSSD version results in changes to the internal db schema). As such, only a Responder/Backend process maintains a reference to its sysdb_ctx.
</p>
<p>
The sysdb_ctx field is primarily accessed through the sss_domain_info structure that encapsulates it. As such, a Process first calls confdb_get_domains, and then passes all of the configured sss_domain_info structures to sysdb_init, which creates a separate sysdb (i.e. ldb database) for each domain. Since our use case has only a single domain, there is only a single system-wide sysdb, in which case the terms sysdb and system cache refer to the same ldb database.
</p>
<p>
Individual entries in the sysdb cache are referenced using the sysdb_attrs structure, which represents an entry that can have multiple multi-valued attributes, and which is created by sysdb_new_attrs. It is by using the sysdb_attrs API that a Process can get/set cached values. Accessor functions are provided in sysdb.h (e.g. sysdb_attrs_get_string, sysdb_attrs_add_string). Using the gettor functions is self-explanatory, but care must be taken when using the settor functions, to ensure that they are written in a transactional manner (data completely stored or not stored at all). To this end, a Process wanting to write information to the cache would make calls similar to the following (with each call taking the sysdb_ctx as an input argument):
</p>
<div class="code"><pre>sysdb_transaction_start<span class="p">();</span> <span class="c1">// set entries using either the sysdb_attrs API or directly using the ldb API (ldb_modify, etc).
</span>sysdb_transaction_commit<span class="p">();</span>
<span class="k">if</span> <span class="p">(</span>error<span class="p">)</span> 
   sysdb_transaction_cancel<span class="p">();</span>
</pre></div><h2 id="a6.4.main_context">6.4. main_context</h2>
<p>
As mentioned earlier, when it first starts, a Process performs some initialization tasks, including
</p>
<ul><li>server_setup
</li><li>&lt;process-specific&gt; init function (e.g. nss_init, pam_init, be_process_init)
</li><li>server_loop
</li></ul><p>
In brief, server_setup creates a main_context, the process-specific init function creates a process-specific context (i.e. nss_ctx, pam_ctx, be_ctx), and the server_loop function simply calls tevent_loop_wait in order to start the main loop.
</p>
<p>
The main_context essentially contains an appropriately initialized tevent_context and confdb_ctx (described earlier), which each Process will need in order to make tevent or confdb function calls. Rather than containing a pointer to the main_context, each process-specific context contains direct pointers to the tevent_context and confdb_ctx components of the main_context (why??). The server_loop function calls tevent_loop_wait using the main_context's tevent_context as input. Since the process-specific context's tevent_context and the main_context's tevent_context are pointing to the same object, the main loop will be able to see events added to the process-specific tevent_context.
</p>
<pre>
<b>
Monitor						Responder		   Backend
</b>
<span style="color:black">load_configuration()</span>
<span style="color:red">server_setup()</span>
<span style="color:green">monitor_process_init()</span>

	add_new_provider() =&gt; fork/exec ==============================&gt; <span style="color:red">server_setup()</span>
			      						<span style="color:green">be_process_init()</span>
									<span style="color:purple">server_loop()</span>

	add_new_service() =&gt; fork/exec=====&gt; <span style="color:red">server_setup()</span>
			     		     <span style="color:green">nss/pam_process_init()</span>
					     <span style="color:green">sss_process_init()</span>
					     <span style="color:purple">server_loop()</span>

<span style="color:purple">server_loop()</span>

</pre>
<h1 id="a7.ComponentDetails">7. Component Details</h1>
<p>
This section looks more closely at the SSSD components, including process-specific data structures and functions, as well as inter-process communication. The following components are discussed, where each component uses its process-specific init function to produce its process-specific context:
</p>
<table class="wiki">
<tr><td><em>component</em></td><td><em>process-specific init function</em></td><td style="text-align: left"><em>process-specific context</em>
</td></tr><tr><td>Monitor</td><td><em>monitor_process_init</em></td><td style="text-align: left">mt_ctx
</td></tr><tr><td>NSS Responder</td><td><em>nss_process_init</em></td><td style="text-align: left">nss_ctx
</td></tr><tr><td>PAM Responder</td><td><em>pam_process_init</em></td><td style="text-align: left">pam_ctx
</td></tr><tr><td>Backend</td><td><em>be_process_init</em></td><td> be_ctx
</td></tr></table>
<h2 id="a7.1.Monitor">7.1. Monitor</h2>
<p>
The monitor is the master SSSD process that is executed when /usr/sbin/sssd is run. The Monitor's context (struct mt_ctx) is created during startup by <em>monitor_process_init()</em> and is used to store Monitor-relevant information, such as a list of <em>mt_svc</em> objects representing spawned processes. The role of the Monitor is:
</p>
<ul><li>to parse the config file and load config info into the confdb for SSSD processes to access
</li><li>to monitor networking changes and act on them accordingly
</li><li>to spawn a Backend process for each domain specified in the config
</li><li>to spawn a Responder process for each service specified in the config (e.g. NSS, PAM)
</li><li>to receive SBus messages (primarily RegisterService) from Responders and Backends
</li><li>to periodically ping all Responders and Backends, and to restart them if unable to ping
</li></ul><p>
In addition to this section, more information can be found in [Monitor].
</p>
<h3 id="a7.1.1.SpawningandRegisteringProcesses">7.1.1. Spawning and Registering Processes</h3>
<p>
The SBus server running as part of the Monitor is characterized by the following:
</p>
<pre class="wiki">server_address:		/var/lib/sss/pipes/private/sbus-monitor
server_intf: 		monitor_server_interface
srv_init_fn: 		''monitor_service_init''
srv_init_data:  	mt_ctx
</pre><p>
Soon after this SBus server is created, the Monitor spawns the Backend processes (one per domain) by calling <em>add_new_provider</em>, which does the following:
</p>
<ul><li>retrieves relevant config info, and uses it to populate mt_svc object, which includes the mt_ctx, sbus_connection, as well as ping parameters
</li><li>builds the command line needed to start the process
</li><li>forks the process
<ul><li>the child process execs the command line, spawning the process
</li><li>the parent process:
<ul><li>adds the mt_svc object to its mt_ctx-&gt;svc_list
</li><li>sets up a timer, which periodically pings the process to assess if it is reachable
</li></ul></li></ul></li></ul><p>
The newly spawned child process does two monitor-related things during initialization:
</p>
<ul><li>sends a connection request to the Monitor, specifying child process's sbus_interface
</li><li>identifies itself by sending a RegisterService message to the Monitor 
</li></ul><p>
In response to the connection request, the parent process (i.e. the Monitor) performs generic SBus initialization, but also performs Monitor-specific SBus initialization by calling <em>monitor_service_init(conn, mt_ctx)</em>, which creates a mon_init_conn object that represents a temporary connection for a Monitor client, and includes the conn, the mt_ctx, and a 10-second tevent_timer (by which time the child process must identify itself by sending a <em>RegisterService</em> message). This mon_init_conn object is then set as the new sbus_connections's private data.
</p>
<p>
In response to the incoming RegisterService message, the corresponding client_registration method is called (with the request message and sbus_connection as inputs) which does the following:
</p>
<ul><li>retrieves mon_init_conn object from sbus_connection
</li><li>cancels the 10-second tevent timer (since the RegisterService message has been received)
</li><li>retrieves request args, extracted from request message (i.e. sender name, sender version)
</li><li>finds sender's mt_svc in mon_init_conn-&gt;mt_ctx-&gt;svc_list
</li><li>sets mt_ctx-&gt;conn to the value of mon_init_conn-&gt;conn (i.e. conn is no longer temporary)
</li><li>marks process as started
</li><li>calls add_new_service for each Responder, which spawns each Responder in a similar manner:
<ul><li>sends a connection request to the Monitor, specifying Responder's sbus_interface
</li><li>identifies itself by sending a RegisterService message to the Monitor 
</li></ul></li><li>creates a reply message that matches the request message, indicating success
</li><li>appends output arguments to reply message (i.e. monitor version)
</li><li>sends back reply message on same sbus_connection on which it received the request 
</li></ul><p>
Once initialization is complete, all Backends and Responders should be registered with the Monitor, allowing the Monitor to send periodic pings to each process. If the Monitor is unable to contact a child process three times, the Monitor restarts the child process.
</p>
<h2 id="a7.2.SSSClient">7.2. SSS Client</h2>
<p>
An SSS Client sends request messages to a matched Responder, and receives back a corresponding response message. A request message includes a command and command-specific input, while a response message includes a status code and command-specific output. The SSS Clients (e.g. NSS Client, PAM Client) use common code to send request messages to a matching Responder, and receive responses from a matching Responder, using the SSS_CLI protocol. This common code makes a blocking call to send the request message and receive the response message. The reason blocking calls are made is that, unlike the other SSSD Components, SSS Clients do not use the tevent main loop, since we have no control over the SSSD Client Application in which the SSS Client is running.
</p>
<h3 id="a7.2.1.SSS_CLI">7.2.1. SSS_CLI</h3>
<p>
Before moving on, let's examine the SSS_CLI protocol. In this client-server protocol, the Responder plays the server role and the SSS Client plays the client role. On the client side, the SSS_CLI protocol code is common among all the various types of SSS Clients (e.g. NSS Client, PAM Client); this client-side code can be found at sss_client/common.c. On the server side, the SSS_CLI protocol code is common among all the various types of Responders (e.g. NSS Responder, PAM Responder); this server-side code can be found at responder_common.c
</p>
<p>
SSS_CLI is a request/response protocol that communicates over raw Unix Domain Sockets, using its own TLV-encoding. Note that the SSS Client only supports synchronous I/O, so it may block (e.g. while waiting for a response). On the other hand, the Responder supports asynchronous I/O using its tevent main loop, so it will not block (e.g. while waiting to read from a client).
</p>
<p>
On the server side, the commands supported by the Responder will vary depending on the type of Responder. The commands supported by the NSS Responder are defined in nsssrv_cmd.c, while the commands supported by the PAM Responder are defined in pamsrv_cmd.c. 
</p>
<p>
On the client side, the commands available to all SSS Clients are defined by an sss_cli_command enumeration in sss_cli.h. The SSS Client's request message essentially consists of this command, along with various command-relevant data (e.g. command=SSS_PAM_AUTHENTICATE, data=username/password). The response message essentially consists of the same command, along with the reply data, and an errno value. The encoding formats of the request and response messages are defined in common.c. The SSS Client calls sss_cli_send_req in order to send the request, and sss_cli_recv_rep in order to receive the reply. 
</p>
<p>
Note that the SSS Client and Responder reference the same header file (sss_cli.h) for command names. Indeed, it is the shared command name (e.g. SSS_PAM_AUTHENTICATE) that ties the SSS Client and Responder together. 
</p>
<h3 id="a7.2.2.NSSClient">7.2.2. NSS Client</h3>
<p>
As mentioned earlier, the API supported by the NSS Client is defined in sss_nss.exports. It includes settors/gettor for several name databases (e.g. passwd, group, etc). While these functions take different input arguments, they all return an nss_status enumeration (e.g. SUCCESS, UNAVAIL, NOTFOUND, TRYAGAIN, etc).
</p>
<p>
When a caller (i.e. SSS Client Application) calls one of these functions, the NSS Client determines if the request is related to the passwd or group database. If so, the NSS Client consults the memcache (i.e. Fast Cache) to see if the request can be fulfilled immediately. If not, or if the cache entry is not valid, the NSS client extracts the caller's arguments, creates a request message, and uses common client functions to interact with an NSS Responder. After it receives a response, it extracts the status and results (e.g. struct passwd), and returns them to the caller. 
</p>
<h3 id="a7.2.3.PAMClient">7.2.3. PAM Client</h3>
<p>
As mentioned earlier, the API supported by the PAM Client is defined in pam_sss.c. It includes a set of functions, each of which takes a pam_handle object as input, and returns an integer representing the pam_status. These functions include:
</p>
<pre class="wiki">pam_sm_open_session:	 initiate session management
pam_sm_authenticate:	 verify identity of user (typically requires password)
pam_sm_setcred:  	 set user's credentials
pam_sm_acct_mgmt: 	 determine if user's account is valid (e.g. password/account expiration)
pam_sm_chauthtok: 	 change the user's authentication token (i.e. password)
pam_sm_close_session: terminate session management
</pre><p>
When a caller (i.e. an SSS Client Application) calls ones of these functions, the PAM Client extracts the caller's arguments (e.g. pam_user) from the pam handle, prompts the caller for a password (if needed), and creates a request message using common client functions to interact with a PAM Responder. After it receives a response, it extracts the pam_status from the response. At this point, if the pam_status is PAM_SUCCESS, then PAM Client simply returns PAM_SUCCESS to the caller, which can expect that the operation was successful. If not successful, the PAM Client's behavior will depend on the particular pam_status (e.g. display error message, etc). 
</p>
<p>
One complication that arises is when a user is successfully authenticated (after contacting the AD Server), but the user's password has expired. Since the authentication succeeds, the PAM Client's authentication code would normally ignore the fact that the password has expired, knowing that the account management code would discover this for itself (but only after contacting the AD Server). However, since we already have this information at the time of authentication, we optimize the situation by having the authentication code set a flag in the pam handle (for consumption by the account management code) indicating that the user's password has expired (and there is no need to contact the AD Server again to establish this fact). 
</p>
<h2 id="a7.3.Responder">7.3. Responder</h2>
<p>
In this section, we describe the common functionality shared by both NSS and PAM Responders. Subsequent sections will discuss Responder-specific functionality.
</p>
<p>
The role of a Responder is:
</p>
<ul><li>to receive request messages from a matching SSS Client
</li><li>to fulfill the requests in one of two ways, by either:
<ul><li>directly retrieving a valid cached result from the sysdb Cache, or
</li><li>asking the Backend to update the sysdb Cache (e.g. after contacting the remote AD server), and then retrieving an up-to-date result from the sysdb Cache
</li></ul></li><li>to send back response messages to the matching SSS Client
</li></ul><h3 id="a7.3.1.resp_ctx">7.3.1. resp_ctx</h3>
<p>
The (Generic) Responder's context (resp_ctx) is created at startup by sss_process_init(). The resp_ctx data structure represents a common set of Responder information that is referenced by a number of other responder-related data structures. At startup, an NSS Responder or PAM Responder calls nss_process_init() or pam_process_init(), which both internally call sss_process_init() with Responder-specific arguments. Note that some fields of the resp_ctx apply only to the Responder's client-facing interface, some fields apply only to the Responder's backend-facing interface, and some fields apply to both. When sss_process_init() is called, the actions that take place include:
</p>
<ul><li>retrieving config information from the confdb (including all domain stanzas)
</li><li>registering the Responder with the Monitor, by sending it a RegisterService SBus message
</li><li>registering the Responder with the Backend, by sending it a RegisterService SBus message
</li><li>initializing connections to each per-domain sysdb cache (only one for our use case)
</li><li>creating a socket and listening for client connections
</li><li>creating a dp request hash table (an optimization technique discussed later)
</li></ul><h3 id="a7.3.2.Client-FacingInteractionsGeneric">7.3.2. Client-Facing Interactions (Generic)</h3>
<p>
As mentioned earlier, an SSS Client communicates with its matching Responder using our SSS_CLI protocol. In order to set up a listening server socket, the Responder retrieves an fd by calling set_unix_socket, (which internally makes the standard socket, bind, listen calls), and which then registers the fd with the main loop (along with its accept_fd_handler, and READ flag). Once the Responder receives a connection from an SSS Client, the main loop dutifully calls accept_fd_handler, which, in turn, calls the standard accept call, which returns a new fd for message traffic, and registers the new fd with the main loop (along with its client_fd_handler and READ flag). This new fd (and client_fd_handler) will be used for the duration of the connection, while the original fd remains listening for new connections. When the SSS Client sends a request message to the Responder, the main loop notices that the Responder's client socket is ready for READ, and calls client_fd_handler, which results in client_recv being called. After processing the command (i.e. consulting cache, forwarding to backend, etc), the Responder registers the fd with the main loop (along with its client_fd_handler, but this time, with a WRITE flag). When the socket is available for writing, the main loop calls client_fd_handler, which, this time (as a result of the WRITE flag), calls client_send to send a response to the SSS Client.
</p>
<p>
As opposed to the resp_ctx object (which represents the entire Responder process), the cli_ctx object (client_context) represents per-client information. For example, the single file descriptor which listens for connections from SSS Clients is stored in the resp_ctx, while the per-client information (such as the file descriptor used to exchange data with a client, a client's request/response messages, etc) is stored in cli_ctx.
</p>
<h3 id="a7.3.3.CommonOptimizationTechniques">7.3.3.Common Optimization Techniques</h3>
<p>
Much of a Responder's functionality has to do with implementing performance-enhancing optimizations. In addition to the sysdb system cache, there are several additional optimizations used in the Responder code. In this section, we examine the optimizations that are common to both the NSS and PAM Responder. Responder-specific optimizations will be discussed in their corresponding sections. After receiving an SSS Client request, both Responders only resort to making SBus method calls to the Backend if none of the optimization techniques they support can fulfill the request.
</p>
<h4 id="a7.3.3.1.DataProviderRequestTable">7.3.3.1. Data Provider Request Table</h4>
<p>
A Data Provider request table (dp_request_table) hashtable is maintained by a Responder to prevent it from sending identical requests to the Backend. For example, when a user logs in to a local machine, several different programs may call <em>getpwnam(“<span style="color: #FF0000">aduser</span>”)</em> in order to retrieve the user's uid and gid. Assuming an empty sysdb cache, the first such request received by a Responder will be sent over SBus to the Backend and the request will be stored in the Responder's dp_request_table. If a second <strong>identical</strong> request is received by the Responder, the Responder will notice that an existing request for the same information is already in progress, and it will register the second request (and any subsequent identical requests) to be called back when the results are ready (so that they receive the same reply information). Note that a dp_request_table is an in-memory data structure, resulting in the NSS Responder and PAM Responder processes maintaining their own separate dp_request_tables.
</p>
<h2 id="a7.4.NSSResponder">7.4. NSS Responder</h2>
<p>
This section examines the commands and optimization techniques supported by the NSS Responder, as well as its overall code flow.
</p>
<h3 id="a7.4.1.nss_ctx">7.4.1. nss_ctx</h3>
<p>
The NSS Responder's context (nss_ctx) is created at startup by nss_process_init(), which takes several actions, including:
</p>
<ul><li>calling sss_process_init() with Responder-specific arguments, including supported commands and supported SBus methods
</li><li>initializing idmap_ctx
</li><li>initializing Responder-specific optimizations (see NSS Optimizations section)
</li><li>retrieving Responder-specific config information from the confdb
</li></ul><h3 id="a7.4.2.Client-FacingInteractionsNSS">7.4.2. Client-Facing Interactions (NSS)</h3>
<p>
The commands supported by the NSS Responder are defined in nsssrv_cmd.c. These commands (and their inputs) are extracted from the packet sent to the Responder by the SSS Client. After processing the command, the NSS Responder returns a packet to the SSS Client containing command output and/or an error message. As such, each command has its own name, function, input, and output (very similar to a function prototype). For example, if the SSS Client Application is making a call with the function prototype of: struct passwd *getpwnam(foo_name), then the SSS Client sends a packet to the Responder containing the input (foo_name), along with an integer representing the command name (getpwnam); and the SSS Client expects to receive a packet from the Responder containing the same command integer, the output (struct passwd), as well as a status code.
</p>
<h3 id="a7.4.3.Backend-FacingInteractionsNSS">7.4.3. Backend-Facing Interactions (NSS)</h3>
<p>
The NSS Responder communicates with the Backend using a single SBus method named <em>getAccountInfo</em>. For <em>getAccountInfo</em>, the outgoing SBus request message is constructed by sss_dp_get_account_msg and “sent” by sbus_conn_send. The incoming SBus reply message is “received” by sss_dp_get_reply.
</p>
<h3 id="a7.4.4.CodeFlowNSS">7.4.4. Code Flow (NSS)</h3>
<p>
This section examines the NSS Responder's code flow. As with most of the code, an NSS Responder's basic code-flow has a “send” phase and a “recv” phase. In the “send” phase, the NSS Responder reads a packet from the client socket, processes it, and, assuming no optimization, writes an SBus message to the backend socket (or “be socket”). In the “recv” phase, the NSS Responder reads the SBus message reply from the backend socket, processes the reply (which typically includes getting the actual result from the updated Cache), and writes a reply packet to the client socket. Of course, the contents of the incoming and outgoing client packets, as well as the contents of the outgoing and incoming SBus messages are command-specific. Note that the same responder-specific search function (which has been underlined below) is called twice, once for the “send” part (when check_provider = TRUE), and once for the “recv” part (when check_provider = FALSE).
</p>

<pre>
<p style="color:red">

<b>"send" phase (NSS: getAccountInfo)</b>
<ul style="color:red">
<li> <b> main loop notices client socket is READABLE; calls <i>client_fd_handler</i> <b></b></b></li>
<ol>
<li> handler receives packet on client socket			// <i>client_recv</i>: uses <b>read</b> syscall </li>
<li> extracts command from packet      	      		 	// <i>sss_packet_get_cmd</i> </li>
<li> executes function that matches command				// <i>sss_cmd_execute</i> </li>
<li> extracts command-specific input from packet			// e.g. username </li>
<li> <u> calls command-specific search function (“send” part) <u> </u></u></li>
<li> tries to fulfill request using NSS Responder optimizations </li>
<li> creates SBus message for Backend				// <i>sss_dp_get_account_msg</i> </li>
<li> enqueues request (adds tevent_fd[WRITE] to ev) 	 	// <i>sss_dp_internal_get_send</i> </li>
<li> returns control to main loop </li>
</ol>
<li> <b>main loop notices be socket is WRITEABLE; calls <i>sbus_watch_handler</i></b> </li>
<ol start="10"><li> handler writes SBus message on backend socket		       // <i>client_send</i>: uses <b>write</b> syscall </li></ol>
</ul>
</p></pre>
<pre>
<p style="color:green">
<b>"recv" phase (NSS: getAccountInfo)</b>
<ul style="color:green">
<li> <b> main loop notices be socket is readable; calls <i> sss_dp_internal_get_done </i> </b> </li>
<ol start="11">
<li> handler extracts arguments from reply message			// <i> sss_dp_get_reply </i> </li>
<li> performs error processing (if needed) </li>
<li> <u> calls command-specific search function (“recv” part) </u> </li>
<li> retrieves updated information from sysdb cache			// <i> sysdb_getpwnam </i> </li>
<li> sets responder-specific optimizations (for next time) </li>
<li> modifies existing client socket's flags, so that it is WRITEABLE </li>
</ol>
<li> <b> main loop notices client socket is writeable; calls <i> client_fd_handler </i> </b> </li>
<ol start="17">
<li>  handler writes reply packet on client socket			// <i> client_send </i> </li>
</ol>
</ul>

</p></pre>
<h3 id="a7.4.5.OptimizationTechniquesNSS">7.4.5. Optimization Techniques (NSS)</h3>
<h4 id="a7.4.5.1.NegativeCache">7.4.5.1. Negative Cache</h4>
<p>
A negative cache is maintained by an NSS Responder to store information about operations that have not been successful. For example, when performing an identity lookup against a remote AD Server, an NSS Responder may determine that no such identity exists. At that point, an NSS Responder would put that information into its negative cache for some period of time (configurable with the entry_negative_timeout field). If a subsequent request came in within that time period for the same identity lookup, the NSS Responder would immediately return a result to the client indicating that no such identity exists (without going to the Backend). Since a negative cache is intended for identity lookups, it would seem that it should be also be used by the PAM Responder when it is looking up identities (i.e. when it is calling initgroups). WhilE this is not currently the case, it is expected that the PAM Responder will start using the negative cache in the near future. Note that a negative cache is an in-memory data structure.
</p>
<h4 id="a7.4.5.2.FastCacheakamemcache">7.4.5.2. Fast Cache (aka memcache)</h4>
<p>
A Fast Cache is a set of memory-mapped cache files, from which an SSS Client can retrieve identity (NSS) information without having to contact the NSS Responder. This was described earlier in the document.
</p>
<h2 id="a7.5.PAMResponder">7.5. PAM Responder</h2>
<p>
This section examines the commands and optimization techniques supported by the PAM Responder, as well as its overall code flow. Regardless of the PAM request sent by the SSS Client (e.g. pam_authenticate), the PAM responder always starts by determining the user's group memberships. It does this by internally calling initgroups on each domain stanza, until it finds a match. Once a match is found, the PAM Responder knows which domain to use, which identity to use, and the groups to which the identity belongs. In our use case, there is only a single domain, so if calling initgroups against our domain fails, then the whole client request fails. Note that the presence of subdomains makes this more complicated, but that has been discussed earlier in the document.
</p>
<h3 id="a7.5.1.pam_ctx">7.5.1. pam_ctx</h3>
<p>
The PAM Responder's context (pam_ctx) is created at startup by pam_process_init(), which takes several actions, including:
</p>
<ul><li>calling sss_process_init with Responder-specific arguments, including supported commands
</li><li>initializing Responder-specific optimizations (see Optimizations section)
</li><li>retrieving Responder-specific config information from the confdb
</li></ul><h3 id="a7.5.2.Client-FacingInteractionsPAM">7.5.2. Client-Facing Interactions (PAM)</h3>
<p>
The commands supported by the PAM Responder are defined in pamsrv_cmd.c. These commands (and their inputs) are extracted from the packet sent to the Responder by the SSS Client. After processing the command, the PAM Responder returns a packet to the SSS Client containing command output and/or an error message. As such, each command has its own name, function, input, and output (very similar to a function prototype). For example, if the SSS Client Application is making a call with the function prototype of: int pam_authenticate(pamh, flags), then the SSS Client sends a packet to the Responder containing the command name (pam_authenticate) and input (username); and the SSS Client expects to receive a packet from the Responder containing the command name (pam_authenticate), the output (e.g. user_info, text_message, etc), as well as a status code.
</p>
<h3 id="a7.5.3.Backend-FacingInteractionsPAM">7.5.3. Backend-Facing Interactions (PAM)</h3>
<p>
The PAM Responder communicates with the Backend using two SBus methods: <em>getAccountInfo</em> (for initgroups) and <em>pamHandler</em> (for pam-related functionality). The <em>getAccountInfo</em> request message is identical to that discussed in the NSS Responder section, except that the operation to perform (be_type) is always INITGROUPS. As such, we will only examine the <em>pamHandler</em> SBus message in this section.
</p>
<p>
For <em>pamHandler</em>, the outgoing SBus request message is constructed by pam_dp_send_req and “sent” by sbus_conn_send. The incoming SBus reply message is “received” by sss_dp_get_reply.
</p>
<h3 id="a7.5.4.CodeFlowPAM">7.5.4. Code Flow (PAM)</h3>
<p>
This section examines the PAM Responder's code flow. The code flow for <em>getAccountInfo</em> is very similar to that discussed in the NSS Responder section. In this section, we will focus on examining <em>pamHandler</em>'s code flow (which begins with the end of <em>getAccountInfo</em>'s flow). However, for the sake of clarity, we show the entire code flow, including both <em>getAccountInfo</em> and <em>pamHandler</em>.
</p>
<p>
The differences between the NSS:<em>getAccountInfo</em> and PAM:<em>getAccountInfo</em> are as follows:
</p>
<ul><li>PAM code uses PAM Responder-specific optimizations (not NSS Responder-specific ones)
</li><li>PAM code uses a different “search” function
</li><li>PAM code doesn't return a reply packet to the SSS Client after getting the initgroups result; rather, it makes a second SBus method call (<em>pamHandler</em>)
</li></ul><b><span style="color:red"> "send" phase (PAM: <i>getAccountInfo</i>) </span></b>
<ul style="color:red">
	<li> <pre> <b> main loop notices client socket is READABLE; calls <i>client_fd_handler</i></b> </pre> </li>
	<ol>
		<li> <pre>handler receives packet on client socket	// client_recv: uses read syscall</pre> </li>
		<li> <pre>extracts command from packet			// <i>sss_packet_get_cmd</i> </pre> </li>
		<li> <pre>executes function that matches command		// <i>sss_cmd_execute</i> </pre> </li>
		<li> <pre>extracts command-specific input from packet	// e.g. username</pre> </li>
		<li> <pre><u>calls pam_check_user_search (“send” part)</u></pre> </li>
		<li> <pre>tries to fulfill request using responder-specific optimizations </pre> </li>
		<li> <pre>creates SBus message for Backend		// <i>sss_dp_get_account_msg</i> </pre> </li>
		<li> <pre>enqueues request (adds tevent_fd[WRITE] to ev)	// <i>sss_dp_internal_get_send</i> </pre> </li>
		<li> <pre>returns control to main loop </pre> </li>
	</ol>
	<li> <pre> <b> main loop notices be socket is WRITEABLE; calls <i>sbus_watch_handler</i> <b> </b></b></pre> </li>
	<ol start="10">
		<li> <pre>handler writes SBus message on backend socket	// <i>client_send</i>: uses write syscall </pre> </li>
	</ol>
</ul>
<span style="color:green"> <b> “recv” phase (PAM: <i> getAccountInfo </i>) </b> </span>
<ul style="color:green">
    <li> <pre> <b> main loop notices be socket is readable; calls sss_dp_internal_get_done </b> </pre> </li>
    <ol>
	<li> <pre> handler extracts arguments from reply message	// <i> sss_dp_get_reply </i> </pre> </li>
	<li> <pre> performs error processing (if needed) </pre> </li>
	<li> <pre> <u>calls <i> pam_check_user_search </i> (recv part)</u> </pre> </li>
	<li> <pre> retrieves updated information from sysdb cache	// <i> sysdb_getpwnam </i> </pre> </li>
	<li> <pre> ets responder-specific optimizations (for next time) </pre> </li>
	<li> <pre> calls <i> pam_dom_forwarder </i> </pre> </li>
    </ol>
</ul>
<span style="color:red"><b>"send" phase (<i>pamHandler</i>)</b>
<ul style="color:red">
    <li> <b> pam_check_user_search (recv part) returns; code calls pam_dom_forwarder </b> </li>
    <ol>
	<li> <pre> creates SBus message for Backend				// <i>pam_dp_send_req</i> </pre> </li>
	<li> <pre>  enqueues request (adds tevent_fd[WRITE] to ev  		// <i>pam_dp_send_req</i> </pre> </li>
	<li> <pre> returns control to main loop </pre> </li>
   </ol>
   <li> <pre> <b> main loop notices be socket is WRITEABLE; calls sbus_watch_handler </b> </pre> </li>
   <ol start="4">
	<li> <pre> handler writes SBus message on backend socket			// <i>client_send</i>: uses <b>write</b> syscall </pre> </li>
   </ol>
</ul>
<span style="color:green"> <b>"recv" phase (<i>pamHandler</i>)</b></span>
<ul style="color:green">
    <li> <pre>  <b>main loop notices be socket is readable; calls <i>pam_dp_process_reply</i> </b></pre> </li>
   <ol start="5">
	<li> <pre>  handler extracts arguments from reply message		// <i>dp_unpack_pam_response</i> </pre> </li>
	<li> <pre>  construct reply massage    	    	  		// <i>pam_reply</i> </pre> </li>
	<li> <pre>  performs error processing (if needed) </pre> </li>
	<li> <pre>  sets responder-specific optimizations (for next time) </pre> </li>
	<li> <pre>  modifies existing client socket's flags, so that it is WRITEABLE </pre> </li>
   </ol>
   <li> <pre> <b>  NSS: main loop notices client socket is writeable; calls client_fd_handler </b> </pre> </li>
   <ol start="10">
	<li> <pre>  handler writes reply packet on client socket		// <i>client_send</i> </pre> </li>
   </ol>
</ul></span><h3 id="a7.5.5.OptimizationTechniquesPAM">7.5.5. Optimization Techniques (PAM)</h3>
<h4 id="a7.5.5.1.InitgroupsCache">7.5.5.1. Initgroups Cache</h4>
<p>
The Initgroups Cache (id_table) is maintained by the PAM Responder in order to store initgroups information for some (usually very short) period of time (configurable with the pam_id_timeout field) . While the PAM Responder does not initially consult the sysdb cache before going to the Backend, the PAM Responder does initially consult the intigroups cache. If it finds a valid entry in the initgroups cache, the PAM Responder does not send an internal initgroups request to the Backend. The reason for this cache is that a full PAM conversation typically includes multiple PAM requests sent by an SSS Client in quick succession (one for authentication, another for account management, etc). Having the Responder send a separate initgroups request for each PAM request would be inefficient and unnecessary. Note that the initgroups cache is an in-memory data structure used by the PAM Responder. This mechanism is not used by the NSS Responder.
</p>
<h2 id="a7.6.OptimizationsCodeFlow">7.6. Optimizations Code Flow</h2>
<p>
Having discussed both NSS and PAM Optimizations, this section walks through a couple of flowcharts showing how these optimizations come into play in the code flow. These flow charts only cover the optimizations performed during the “send” and “recv” phase of identity lookups (i.e. NSS Responder and initgroups part of PAM Responder), not authentication or other pam-related functionality. We first look at optimizations performed during the “send” phase and then at optimizations performed (or set for next time) during the “receive” phase.
</p>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 8" /></a>
</p>
<p>
<em>Optimizations performed during the "send" phase</em>
</p>
<p>
While the flowchart is fairly self-explanatory, there are a few things to note:
</p>
<ul><li>flowchart assumes that the function matching a client command has been executed, and we are now seeing if we can avoid going to the Backend using these optimization techniques
</li><li>if there is a valid entry in the initgroups cache, that is a good thing (list of group memberships)
</li><li>if there is a valid entry in the negative cache, that is a bad thing (“user didn't exist last time”)
</li><li>if there isn't a valid entry in the initgroups cache, it does not consult the sysdb Cache
</li><li>the dp_request_table optimization is only used if there are dp requests to be made (i.e. our optimizations have failed and message needs to be sent to the Backend).
</li><li>all dp requests (even the first one) are registered as callbacks
</li></ul><p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 9" /></a>
</p>
<p>
<em>Optimizations performed during the "recv" phase</em>
</p>
<p>
While the flowchart is fairly self-explanatory, there are a few things to note:
</p>
<ul><li>each of the registered callbacks receives their own copy of the return args
</li><li>if the PAM Responder finds a valid entry in sysdb cache, it adds entry to initgroups_cache
</li><li>NSS Responder again checks if entry should be dismissed because it exists in the negative cache
</li><li>if NSS Responder does not find a valid entry in sysdb cache, it adds an entry to the negative cache, and deletes an entry from the memcache (fast cache).
</li><li>the memcache is not being updated anywhere here (it only gets updated when the Backend sends an initgrCheck SBus message to the NSS Responder).
</li></ul><h2 id="a7.7.Backend">7.7. Backend</h2>
<p>
In this section, we describe the functionality of a Backend, which represent a domain stanza (e.g. [domain/<span style="color: #FF0000">foo.com</span>]. Recall that a domain stanza specifies the individual Provider Plugins to be used for each provider type, as well as information needed to access the remote server (e.g. ad_domain=<span style="color: #FF0000">foo.com</span>). As such, for each domain stanza in the configuration, the Monitor spawns a separate Backend process, and each Backend process dynamically loads its configured provider plugins. The role of a provider plugin is to provide plugin-specific implementations of generic functions (bet_ops) used to handle request messages, to perform check_online operations, and to perform finalize operations. Additionally, a provider plugin retrieves plugin-specific configuration (pvt_bet_data), which it passes to each of the above functions.
</p>
<p>
The role of a Backend (aka “Data Provider”) is:
</p>
<ul><li>to receive SBus request messages from Backend clients (e.g. Responders)
</li><li>to fulfill the requests, by calling the appropriate function registered by a Provider Plugin
</li><li>to send back SBus response messages to Backend clients
</li><li>to update the sysdb Cache with fresh results from the remote server
</li></ul><h3 id="a7.7.1.BackendConcepts">7.7.1. Backend Concepts</h3>
<h4 id="a7.7.1.1.ServicesandServers">7.7.1.1. Services and Servers</h4>
<p>
SSSD distinguishes between services and servers, in that a single server (i.e. IP address) can host multiple services (i.e. ports). In the code, a service (e.g. LDAP) is represented using an fo_service object, while each server that supports that service is represented by fo_server objects. A list of servers associated with a service are specified in the configuration. For example, in our use case, an AD Provider Plugin is capable of consuming the LDAP, GC, and KRB services on one or more AD Servers (as specified by the ad_users and ad_backup_users configuration fields). A Backend implements service failover by automatically switching to a different server if a server is unreachable.
</p>
<p>
If we are able to successfully resolve a server and establish an authenticated connection, SSSD enters online mode, and that connection can be re-used to transfer requests and responses, until the connection expires (or we go offline).
</p>
<p>
If we are unable to resolve a server on the service's list, that server is marked offline for all services, and we try to resolve the next server on the service's list. If we are unable to resolve any of the servers on the service's list, then SSSD enters offline mode. If we are able to resolve a server on the service's list, we then attempt to connect to the service (e.g. LDAP) on that server. If successful, we continue processing. If unsuccessful, that server is marked offline, but only for that service. Since only that one service (e.g. LDAP) is marked offline, the other services (e.g. KRB) on that server are still considered online. The failover mechanism then automatically tries to connect to the same service on the next server on the service's list of servers. If we are unable to connect to any of the servers on the service's list of servers, then SSSD enters offline mode.
</p>
<p>
Put another way, here is the algorithm for resolving and connecting to a service:
</p>
	<ol>
		<li> retrieve service's list of servers </li>
                <li> resolve next server on list </li>
                <li> if successful, goto step 5; else, mark server offline for all services </li>
                <li> if more servers on list, goto step 2; else, SSSD enters offline mode; DONE </li>
                <li> connect to service on resolved server </li>
                <li> if successful, DONE; else, mark server offline for that service </li>
                <li> if more servers on list, goto step 2; else, SSSD enters offline mode; DONE  </li>
        </ol>
<p>
 
</p>
<h4 id="a7.7.1.2.NameResolution">7.7.1.2. Name Resolution</h4>
<p>
Name resolution of a server (i.e. obtaining its IP address) is accomplished in different ways, depending on how the server is specified in the configuration:
</p>
<ul><li>if server specified by IP address, we're done (no resolution is required)
</li><li>if server specified by hostname, we resolve the server using DNS address records (A/AAAA)
</li><li>if server specified with the “_srv_” string, we resolve the service using DNS SRV records
</li></ul><p>
A Backend's Provider Plugin uses the external c-ares library to communicate with a DNS Server, in order to resolve a service's server names. The address of the DNS server is retrieved from /etc/resolv.conf.
</p>
<p>
In order to resolve a server on a service's list, a Backend calls be_resolve_server_send and includes the service's name as input. This function retrieves the list of servers (primary and secondary) associated with the service name input. For servers that support resolution using SRV records, the service name is resolved by calling resolv_srv_send; otherwise, the server name is resolved by calling fo_resolve_service_server. In either case, if the resolution is successful, an fo_server object is returned, which includes the desired addressing information in server_common-&gt;rhostent. If unsuccessful, the recv function indicates that there was an error, in which case upstream callers typically mark the server as being offline (be_mark_offline).
</p>
<h4 id="a7.7.1.3.ConfigurationLines">7.7.1.3. Configuration Lines</h4>
<p>
As we saw in an earlier example, a domain stanza (represented by a Backend) includes several provider lines, such as “id_provider = ad”. Internally, the information corresponding to a single provider line is stored in the be_ctx as a bet_info array element, which includes the following information:
</p>
<pre class="wiki">bet_type     	 // the provider type (e.g. BET_ID, BET_AUTH, etc)
bet_ops		 // plugin-specific functions used to handle requests, check_online, and finalize
pvt_bet_data	 // plugin-specific data passed to plugin-specific functions (see above)
mod_name	 // the provider plugin's name (e.g. AD, IPA)
req_queue	 // a bet_queue item, which includes a be_req and be_req_fn
</pre><p>
The bet_ops field (and pvt_bet_data arg field) are particularly important, as they specify the actual plug-in specific functions (and args) that are called by the Backend to invoke plug-in specific functionality. The bet_ops structure for each provider line contains three plug-in specific function pointers:
</p>
<ul><li>check_online: determines whether SSSD is in “online mode” (i.e. whether remote server is reachable on the network); this function pointer is only used by bet_info[BET_ID]. This function is called by check_if_online, which uses the results of check_online to determine whether the Backend has transitioned to “online mode”, in which case the Backend runs any registered online callbacks. The check_if_online function itself is called by data_provider_res_init and data_provider_reset_offline (i.e. the sbus_method functions that handle resInit and <em>resetOffline</em> SBus messages, respectively). 
</li><li>handler: provides the guts of the provider type's functionality; for example, the handler for bet_info[BET_ID] would implement identity lookups (e.g. contact the remote server, retrieve data, etc), while the handler for bet_info[BET_AUTH] would implement authentication processing.
</li><li>finalize: used to terminate the be_req and clean up any internal data; this is optional
</li></ul><p>
The provider line that specifies “id_provider = ad” indicates two things: “id_provider” indicates that we are dealing with a bet_type of BET_ID, and “ad” indicates that we should dynamically load “libsss_ad.so”, and we should use the bet_ops and pvt_bet_data specified by the AD provider plugin. In other words, “id_provider = ad” results in the creation of the following data structure:
</p>
<pre class="wiki">bet_info[BET_ID] = 
		 bet_type	BET_ID
		 bet_ops	ad_id_ops
		 pvt_bet_data	ad_opts.id_ctx
		 mod_name	"ad"	
</pre><p>
For example, our use case uses four provider lines (id_provider, auth_provider, access_provider, and chpass_provider). These are stored in the be_ctx as an array of bet_info data structures:
</p>
<ul><li>bet_info[BET_ID]
</li><li>bet_info[BET_AUTH]
</li><li>bet_info[BET_ACCESS]
</li><li>bet_info[BET_CHPASS]
</li></ul><p>
In theory, each provider line can reference a different provider plugin, resulting in multiple libraries being dynamically loaded. For example, “id_provider = ldap”, “auth_provider=krb5” would result in both libsss_ldap.so and libsss_krb5.so being dynamically loaded, with bet_info[BET_ID] populated with LDAP-specific operations, and bet_info[BET_AUTH] populated with KRB5-specific operations. Having said that, it is now more common to use layered provider plugins (e.g. AD, IPA) which greatly simplify configuration for an AD or IPA environment. Indeed, our use case is configured by specifying “id_provider = ad” (i.e. identity lookups are handled by the AD provider plugin) and “auth_provider = ad” (i.e. authentication processing is handled by the AD provider plugin). In this case, only a single library (libsss_ad.so) would be dynamically loaded, but it would internally make calls to the same shared code used by the LDAP and KRB5 provider plugins.
</p>
<h3 id="a7.7.2.be_ctx">7.7.2. be_ctx</h3>
<p>
A Backend Process has a single Backend context (be_ctx), which it shares with the various entities internal to the Backend that need it. The be_ctx is created at startup by be_process_init, at which time several actions take place, including:
</p>
<ul><li>retrieving config information from the confdb (mostly related to Backend's domain stanza)
</li><li>setting up the failover service
</li><li>initializing failover<em> allows backend to auto-switch to different server if current server fails
</em></li><li>initializing connection to sysdb cache for Backend's domain stanza
</li><li>registering the Backend with the Monitor, by sending it a RegisterService SBus message
</li><li>exporting sbus methods supported by the Backend (to be called by Responders or Monitor)
</li><li>loading and initializing provider plugins (aka Backend Modules), as specified in configuration
<ul><li>this includes initializing the array of bet_info structures with plugin-specific values
</li></ul></li></ul><h3 id="a7.7.3.Responder-FacingInteractions">7.7.3. Responder-Facing Interactions</h3>
<h4 id="a7.7.3.1.RegisteringResponders">7.7.3.1. Registering Responders</h4>
<p>
The Responder interacts with the Backend using SBus. For our use case, there are three Backend clients (NSS Responder, PAM Responder, Monitor). The SBus server running as part of the Backend is characterized by the following:
</p>
<pre class="wiki">server_address:		/var/lib/sss/pipes/private/sbus-dp_foo.com (domain_name=foo.com)
server_intf:		be_interface
srv_init_fn:		be_client_init
srv_init_data:		be_ctx
</pre><p>
When a Responder process is spawned by the monitor, it does two Backend-related things during initialization:
</p>
<ul><li>sends a connection request to the Backend, specifying Responder's sbus_interface
</li><li>registers itself with the Backend by sending a RegisterService message to the Backend
</li></ul><p>
In response to the connection request, the Backend performs generic SBus initialization, but also performs Backend-specific SBus initialization by calling be_client_init(conn, be_ctx), which creates a be_client object that represents a Backend client connection (which starts off uninitialized). This be_client object includes the conn, the be_ctx, and a 5-second tevent_timer (by which time the Responder must identify itself by sending a RegisterService message). This be_client object is then set as the sbus_connections's private data.
</p>
<p>
In response to the incoming RegisterService message, the corresponding client_registration method is called (with the request message and sbus_connection as inputs) which does the following:
</p>
<ul><li>retrieves be_client object from sbus_connection
</li><li>cancels the 5-second tevent timer (because the RegisterService message has been received)
</li><li>retrieves request args, extracted from request message (i.e. sender name, sender version)
</li><li>marks Backend client as initialized
</li><li>creates a reply message that matches the request message, indicating success
</li><li>appends output arguments to reply message (i.e. backend version)
</li><li>sends back reply message on same sbus_connection on which it received the request 
</li></ul><p>
Once initialization is complete, all Responders should be registered with the Backend.
</p>
<p>
Unlike the Responders, the Monitor process (which is also a Backend client) does not need to register itself with the Backend. This is because the Backend has already registered itself with the Monitor, and therefore the Backend already has access to the Monitor's sbus_interface.
</p>
<h4 id="a7.7.3.2.ReceivingSBusMessages">7.7.3.2. Receiving SBus Messages</h4>
<p>
A Backend is capable of receiving the SBus methods (name/function pairs) that were exported during its startup (be_process_init). The functions associated with each sbus method name are generic (i.e. not provider-plugin-specific). However, each function corresponds to a particular provider plugin type. For example, <em>getAccountInfo</em> is used for identity lookups and is therefore associated with the identity provider. When the Backend receives an SBus message that targets one of its sbus_method names, the Backend executes the corresponding generic function. In turn, this generic function executes the handler function registered for the particular provider plugin type associated with this SBus method. For example, since <em>getAccountInfo</em> is associated with the identity provider (i.e. BET_ID), we would extract its handler function from bet_info[BET_ID]-&gt;bet_ops-&gt;handler (which was registered by be_process_init). We would also extract the argument with which to call the handler from bet_info[BET_ID]-&gt;pvt_bet_data.
</p>
<p>
Since our use case uses only the NSS and PAM Responders, we will only be looking at the SBus methods sent by those Responders: <em>getAccountInfo</em> (for identity lookups) and <em>pamHandler</em> (for pam-related functionality).
</p>
<ul><li>sbus_method name: “<em>getAccountInfo</em>”
<ul><li>generic function:                            be_get_account_info
</li><li>provider_plugin type:                        BET_ID
</li><li>plugin/type-specific handler function:        bet_info[BET_ID]-&gt;bet_ops-&gt;handler
</li><li>plugin/type-specific handler argument:        bet_info[BET_ID]-&gt;pvt_bet_data
</li></ul></li><li>sbus_method_name: “<em>pamHandler</em>”
<ul><li>generic function:                            be_pam_handler
</li><li>provider_plugin type:                        BET_AUTH
</li><li>plugin/type-specific handler function:        bet_info[BET_AUTH]-&gt;bet_ops-&gt;handler
</li><li>plugin/type-specific handler argument:        bet_info[BET_AUTH]-&gt;pvt_bet_data
</li></ul></li></ul><h2 id="a7.8.ADProviderPlugin">7.8. AD Provider Plugin</h2>
<p>
The AD Provider Plugin supports the following provider types, which are initialized by corresponding functions in ad_init.c:
</p>
<pre>id_provider		// initialized by <i>sssm_ad_id_init</i></pre>
<pre>auth_provider	      	// initialized by <i>sssm_ad_auth_init</i></pre>
<pre>chpass_provider      	// initialized by <i>sssm_ad_chpass_init</i></pre>
<pre>access_provider      	// initialized by <i>sssm_ad_access_init</i></pre>
<p>
The ad_options global variable is used to maintain the configuration options for the various provider types supported by the AD Provider Plugin. This includes:
</p>
<ul><li>basic configuration: ad_domain, ad_server, krb5_keytab, ad_enable_dns_sites, etc
</li><li>id_provider configuration: sdap service, gc service, etc
</li><li>auth/chpass_provider configuration: principal name, service name, keytab_name, krb5 service
</li><li>dynamic dns updates configuration
</li></ul><p>
Since our use case uses the AD Provider Plugin for all provider lines, each bet_info array will be populated with the following AD-specific information:
</p>
<ul><li>bet_info[BET_ID]
<ul><li>bet_ops:            ad_id_ops
</li><li>pvt_bet_data:       ad_options.id_ctx
</li></ul></li><li>bet_info[BET_AUTH]
<ul><li>bet_ops:            ad_auth_ops
</li><li>pvt_bet_data:       ad_options.auth_ctx
</li></ul></li><li>bet_info[BET_CHPASS]
<ul><li>bet_ops:            ad_chpass_ops
</li><li>pvt_bet_data:       ad_options.auth_ctx
</li></ul></li><li>bet_info[BET_ACCESS]
<ul><li>bet_ops:            ad_access_ops
</li><li>pvt_bet_data:       access_ctx
</li></ul></li></ul><p>
The remainder of this section will examine each provider line in turn, focussing on the functionality implemented by each line's bet_ops functions. Note that the first three provider lines use fields from ad_options as the pvt_bet_data argument that is passed in to the corresponding bet_ops functions. 
</p>
<h3 id="a7.8.1.ADProviderPlugin:id_provider">7.8.1. AD Provider Plugin: id_provider</h3>
<p>
In this section, we examine the AD Provider Plugin's implementation of the id_provider type, including the AD-specific bet_ops and pvt_bet_data that are used. Unlike the other provider types, the bet_ops for the id_provider type includes values set for the check_online and finalize function pointers.
</p>
<ul><li>bet_ops:
<ul><li>check_online:        ad_check_online
</li><li>handler:                ad_account_info_handler
</li><li>finalize:                ad_shutdown
</li></ul></li><li>pvt_bet_data:                ad_opts.id_ctx (of type ad_id_ctx)
</li></ul><h4 id="a7.8.1.1.ad_id_ctx">7.8.1.1. ad_id_ctx</h4>
<p>
The ad_id_ctx is created as part of the initialization that takes place when the AD Provider Plugin is dynamically loaded for an id_provider line, at which time several actions take place, including:
</p>
<ul><li>retrieving relevant config info
</li><li>initializing failover
</li><li>initialized dynamic dns updates
</li><li>setting up sdap child process
</li><li>setting up various sdap options
</li><li>setting up tasks
</li><li>setting up id mapping object
</li><li>setting up tls
</li><li>setting up srv lookup plugin
</li><li>setting up periodic refresh of expired records
</li></ul><h4 id="a7.8.1.2.ad_account_info_handler">7.8.1.2. ad_account_info_handler</h4>
<p>
This function is used to fulfill an identity lookup request. In this section, we will use getpwnam(“<span style="color: #FF0000">aduser@foo.com</span>”) as our example. It is called by be_get_account_info, which is the generic sbus_method function that handles <em>getAccountInfo</em> messages, the details of which have been previously discussed. 
</p>
<p>
This function is called with a be_req input argument, from which it extracts two important things:
</p>
<ul><li>ad_id_ctx, which includes relevant config info, etc
</li><li>be_acct_req, which includes the input values sent in the SBus request message (entry_type, attr_type, filter and domain).
</li></ul><p>
Next, an entry_type-specific function is called (e.g. users_get_send), which does the following:
</p>
<ul><li>creates an sdap_id_op object to represent the operation request (using sdap_id_op_create)
</li><li>establishes LDAP connection by sending a connection request (or re-uses existing connection)
<ul><li>multi-step process, including resolving, connecting, and binding to an LDAP server
</li></ul></li><li>sends an operation request (and receives response) over the LDAP connection
<ul><li>performs ldap search using the be_acct_req fields as input params (sdap_get_generic_send).
</li></ul></li></ul><h4 id="a7.8.1.3.ad_check_online">7.8.1.3. ad_check_online</h4>
<p>
This function determines whether the Backend is in “online mode”. This function is called with a be_req input argument, from which it extracts the ad_id_ctx, after which it attempts to connect to the LDAP server. If the LDAP server is reachable, this function sets its output to DP_ERR_OK; otherwise, it sets its output to DP_ERR_OFFLINE.
</p>
<h3 id="a7.8.2.ADProviderPlugin:auth_providerandchpass_provider">7.8.2. AD Provider Plugin: auth_provider and chpass_provider</h3>
<p>
Since the auth_provider and chpass_provider for the AD Provider Plugin have many similarities, we will discuss them together in this section. Both providers use the same bet_ops and pvt_bet_data.
</p>
<ul><li>bet_ops:
<ul><li>handler: krb5_pam_handler
</li></ul></li><li>pvt_bet_data: ad_opts.auth_ctx (of type krb5_auth_ctx)
</li></ul><h4 id="a7.8.2.1.krb5_auth_ctx">7.8.2.1. krb5_auth_ctx</h4>
<p>
The krb5_auth_ctx is created as part of the initialization that takes place when the AD Provider Plugin is dynamically loaded for an auth_provider line or chpass provider line, at which time several actions take place, including:
</p>
<ul><li>retrieving relevant config info
</li><li>forcing krb5_servers to match ad_servers
</li><li>forcing krb5_realm to match ad_krb5_realm
</li><li>setting up krb5 child process
</li></ul><h4 id="a7.8.2.2.krb5_pam_handler">7.8.2.2. krb5_pam_handler</h4>
<p>
This function is used to fulfill an authentication request, or to fulfill a change password request. For these requests, it is called by be_pam_handler, which is the generic sbus_method function that handles <em>pamHandler</em> messages, the details of which have been previously discussed.
</p>
<p>
This function is called with a be_req input argument, from which it extracts two important things:
</p>
<ul><li>krb5_ctx, which includes relevant config info, etc
</li><li>pam_data, which includes the many input values sent in the SBus request message (e.g. cmd, user, authtok, etc).
</li></ul><p>
This function performs the following high-level tasks:
</p>
<ul><li>retrieves several attributes for this user from the domain-specific sysdb (e.g. upn, uid, gid, etc)
</li><li>obtains addressing information for the KDC (which is also the kpasswd server in AD)
</li><li>forks a krb5_child, which will make the blocking krb5 api calls
</li><li>performs an asynchronous write to send the appropriate request information to the krb5_child
</li><li>performs an asynchronous read to receive the response from the krb5_child
</li></ul><p>
Next, the function calls be_resolve­_server to get the addressing information for the KDC. Since the IP address of the LDAP service and the KRB5 service is the same (i.e. that of the AD service), resolving the KRB5 service may not require going to DNS, since we may already have the information from resolving the LDAP service. Note that, in order to make the Kerberos library aware of which IP address to use for the AD server, we call write_krb5info_file, which writes a kdcinfo file to the filesystem, which is later read by the Kerberos library. More info on the kdcinfo files can be found in a separate subsection below.
</p>
<p>
In order to avoid blocking on synchronous Kerberos calls, this function then spawns a krb5_child process and sends it the relevant input (e.g. username, password, new password) using its write pipe. The krb_child makes the appropriate Kerberos library calls (to perform the authentication or password change), after which it returns a response to the calling process's read pipe, at which time the krb5_child process exits.
</p>
<h5 id="a7.8.2.2.1.ParentChild">7.8.2.2.1. Parent =&gt; Child</h5>
<p>
The information sent from the AD Provider Plugin to the krb5_child process includes:
</p>
<ul><li>cmd                <em> e.g. SSS_PAM_AUTHENTICATE, SSS_PAM_CHAUTHTOK
</em></li><li>upn                <em> (from sysdb)
</em></li><li>validate        <em> whether TGT validation is desired (default: TRUE)
</em></li><li>is_offline        <em> whether SSSD is offline
</em></li><li>send_pac        <em> whether to send PAC to PAC Responder (for AD, always TRUE)
</em></li><li>ccname        <em> credentials cache name
</em></li><li>keytab        <em> keytab name (used for TGT validation)
</em></li><li>authtok        <em> current password
</em></li><li>newauthtok        <em> new password (only used by chpass_provider; not by auth_provider)
</em></li></ul><p>
For an authentication request, the krb5_child process uses the krb5_principal (parsed from upn) and specified password to obtain authentication credentials (i.e. TGT) from the ticket-granting service on the AD KDC. If successful, and if validate is set to TRUE, the krb5_child process proceeds to locally validate the TGT using the specified keytab. As part of validation, if send_pac is set to TRUE, the krb5_child extracts the PAC from the TGT and sends the PAC (along with the user principal) to the PAC Responder, which decodes the PAC information, such as group memberships from trusted domains, and updates the System Cache accordingly. Finally, the authentication credentials (i.e. TGT) are stored in the specified credentials cache for that principal.
</p>
<p>
For a password change request, the krb5_child process also uses the krb5_principal and password, but uses it to get change password credentials from the password-change service on the AD KDC. If successful, and with valid change password credentials in hand, the krb5_child then asks the password-change service to change the password to the specified new password, after which it obtains it sends an authentication request (as above), by which a new TGT is obtained from the ticket-granting service, and stored in the credentials cache for that principal.
</p>
<h5 id="a7.8.2.2.2.ChildParent">7.8.2.2.2. Child=&gt;Parent</h5>
<p>
While it is processing, the krb5_child process can add pam responses to the pam_data object's response list (resp_list), where each response consists of a {type,length,value} tuple. It is this response_list which is returned from the child to its parent after it has completed processing. After receiving the responses, the parent passes the responses back to the Responder, which passes back the responses (after filtering some of them out) to the Client Library, which acts upon them in some way. As such, these responses may be for consumption by the parent, the Responder, and/or the Client Library.
</p>
<p>
For example, the krb5_child may wish to convey an error message to the Client Library, indicating that a password change request has failed (b/c the wrong password was entered for authentication). In this case, the krb5_child would append the following response to the response list, which the Client Library could use to display an error message to the SSS Client Application.
</p>
<ul><li>type: SSS_PAM_USER_INFO
</li><li>len: data_length
</li><li>data:
<ul><li>resp_type: SSS_PAM_USER_INFO_CHPASS_ERROR
</li><li>len: err_len
</li><li>user_error_message: “Old password not accepted”
</li></ul></li></ul><p>
As another example, the krb5_child may wish to convey some data (e.g. TGT lifetime) to the parent. In this case, the krb5_child might also append the following response to the response list, which the parent (i.e. AD Provider Plugin) could use as a parameter when adding the TGT to a renew table.
</p>
<ul><li>type: SSS_KRB5_INFO_TGT_LIFETIME
</li><li>len: data-length
</li><li>data: value of tgt lifetime
</li></ul><h4 id="a7.8.2.3.kdcinfofiles">7.8.2.3. kdcinfo files</h4>
<p>
The SSSD might discover additional KDC or Kadmin servers that are not defined in krb5.conf. However, it would still be prudent if tools like kinit or kpasswd could talk to the same servers the SSSD talks to. To this end, the SSSD implements a plugin for libkrb5, located in the <a class="ext-link" href="https://git.fedorahosted.org/cgit/sssd.git/tree/src/krb5_plugin/sssd_krb5_locator_plugin.c"><span class="icon">​</span>sssd_krb5_locator_plugin.c</a> file. When a new KDC is discovered, the sssd_be process writes the IP address of this KDC into a file under the /var/lib/sss/pubconf directory. With the help of the locator plugin, libkrb5 is able to read these files in the pubconf directory and use the KDC servers discovered by the SSSD.
</p>
<h3 id="a7.8.3.ADProviderPlugin:access_provider">7.8.3. AD Provider Plugin: access_provider</h3>
<p>
In this section, we examine the AD Provider Plugin's implementation of the access_provider type, including the AD-specific bet_ops and pvt_bet_data that are used.
</p>
<ul><li>bet_ops:
<ul><li>handler: ad_access_handler
</li></ul></li><li>pvt_bet_data: access_ctx (of type ad_access_ctx)
</li></ul><h4 id="a7.8.3.1.ad_access_ctx">7.8.3.1. ad_access_ctx</h4>
<p>
The ad_access_ctx is created as part of the initialization that takes place when the AD Provider Plugin is dynamically loaded for an access_provider line, at which time several actions take place, including:
</p>
<ul><li>setting up sdap_access_ctx for checking expired/locked accounts
</li></ul><h4 id="a7.8.3.2.ad_access_handler">7.8.3.2. ad_access_handler</h4>
<p>
This function is used to fulfill an access check request, such as determining whether the password of "<span style="color: #FF0000">aduser@foo.com</span>" has expired. It is called for account management requests by be_pam_handler, which is the generic sbus_method function that handles <em>pamHandler</em> messages, the details of which have been previously discussed.
</p>
<p>
This function is called with a be_req input argument, from which it extracts two important things:
</p>
<ul><li>access_ctx, which includes relevant config info, etc
</li><li>pam_data, which includes the many input values sent in the SBus request message (e.g. cmd, user, authtok, etc).
</li></ul><p>
Currently, the ad_access_handler simply calls sdap_access_send, which determines whether or not the account is expired/locked, and returns the result.
</p>
<h1 id="a8.TeventBasics">8. Tevent Basics</h1>
<p>
This section examines events and requests based on file descriptors.
</p>
<h2 id="a8.1.Events">8.1. Events</h2>
<p>
The tevent library provides a main loop implementation capable of supporting various types of events, of which we focus here on fd-based events. A tevent_fd object encapsulates an fd, a set of flags (e.g. READ, WRITE), an event handler, and handler data. As with all events, a tevent_fd is managed by the tevent main loop, which monitors the events in its event context. When an event fires (e.g. fd becomes readable), the main loop calls the corresponding event handler callback, which uses the handler data to continue where it left off. When the main loop calls a handler, the main loop can not call a second handler until control has been returned to it by the first handler.
</p>
<p>
In the tevent model, the handler code is responsible for performing socket operations (e.g. accept, send, recv, etc) on a file descriptor, while the main loop is responsible for polling the file descriptors to determine which one is ready to send or recv data. When we call tevent_add_fd(ev, talloc_ctx, fd, flags, handler, data), we are simply asking the main loop to call the handler with the arg, when the specified fd is able to read or write (as specified by the flags). 
</p>
<h2 id="a8.2.Requests">8.2. Requests</h2>
<p>
The tevent library also supports generic asynchronous functions, by providing tevent request helper functions (and a naming convention). Unlike synchronous functions, which provide callers with a single interface that accepts inputs and returns outputs, asynchronous functions provide two interfaces for a particular computation: one to “send” the request (i.e. accept inputs) and another to “receive” the response (i.e. return outputs). As such, a tevent request's "implementation" refers to the code that implements the tevent request (e.g. comp_send and comp_recv), while a tevent request's "caller" refers to the code that calls comp_send or comp_recv. The tevent library includes support for nested requests, in which the "implementation" of one tevent request can be a "caller" for a different tevent request. This allows for better modularization of the codebase. This also enables the cancelling of a top-level request to result in the cancelling of all its nested requests.
</p>
<p>
The implementation of a tevent request is responsible for creating a tevent_req object, specifying data (used to hold inputs/outputs; private to the implementation) that the implementation may need to maintain, and determining whether or not the request has completed successfully. In addition, since the caller is not aware of the data details, the implementation has to provide a recv function so that the caller can extract the relevant outputs from the state.
</p>
<p>
The caller of a tevent request specifies its inputs when issuing a request, and also specifies a callback function (and argument) to be called when the request has completed. This callback function is typically used by the caller to receive the response (using the implementation-provided recv function). Note that the caller is not concerned with the details of the implementation (e.g. whether network I/O was required, whether the request was fulfilled by cache, etc), as long as the tevent request's send/recv contract (e.g. input/output) is maintained.
</p>
<p>
Let's look at the naming convention used by tevent requests for an example <strong>"comp"</strong> computation (note that this naming convention is not always precisely followed in the SSSD code):
</p>
<ul><li>the implementation of the comp computation:
<ul><li>specifies public interface for caller consumption:
<ul><li><strong><em>comp</em></strong><em>_send(mem_ctx, inputs)</em>: used by caller to specify inputs for request
</li><li><strong><em>comp</em></strong><em>_recv(req, outputs)</em>: used by caller to receive outputs of request
</li></ul></li><li>specifies private details for internal consumption by implementation
<ul><li><strong><em>comp</em></strong><em>_state: object used to pass around inputs/outputs between internal functions
</em></li></ul></li></ul></li><li>the caller of the <strong>comp</strong> computation:
<ul><li>calls the public interface with inputs/outputs
</li><li><strong><em>comp</em></strong><em>_done: specifies callback function and callback argument
</em></li></ul></li></ul><p>
The following example illustrates the material presented in this section. In this example, we are using <strong>“read_bytes”</strong> as the example computation. The implementation implements the caller-accessible <strong>read_bytes_send</strong> and <strong>read_bytes</strong><em>_recv</em> functions, as well as its own internal functions (such as <strong><em>read_bytes</em></strong>_<em>handler</em>). The caller calls the public interface with inputs/outputs, and also specifies the callback function.
</p>
<p>
Implementation Code
</p>
<div class="code"><pre><span class="k">struct</span> tevent_req <span class="o">*</span>read_bytes_send<span class="p">(</span>mem_ctx<span class="p">,</span> ev<span class="p">,</span> fd<span class="p">)</span> <span class="p">{</span>
       <span class="p">...</span>
       req <span class="o">=</span> tevent_req_create<span class="p">(</span>mem_ctx<span class="p">,</span> <span class="o">&amp;</span>state<span class="p">,</span> <span class="k">struct</span> read_bytes_state<span class="p">);</span>
       state<span class="o">-&gt;</span>fd <span class="o">=</span> fd<span class="p">;</span>
       state<span class="o">-&gt;</span>buf <span class="o">=</span> talloc_size<span class="p">(</span>state<span class="p">,</span> BUFSIZE<span class="p">);</span>
       state<span class="o">-&gt;</span>len <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       fde <span class="o">=</span> tevent_add_fd<span class="p">(</span>ev<span class="p">,</span> state<span class="p">,</span> fd<span class="p">,</span> TEVENT_FD_READ<span class="p">,</span> read_bytes_handler<span class="p">,</span> req<span class="p">);</span>
       <span class="k">return</span> req<span class="p">;</span>
<span class="p">}</span>
</pre></div><div class="code"><pre><span class="kt">void</span> read_bytes_handler<span class="p">(</span><span class="k">struct</span> tevent_context <span class="o">*</span>ev<span class="p">,</span> <span class="k">struct</span> tevent_fd <span class="o">*</span>fde<span class="p">,</span> <span class="kt">void</span> <span class="o">*</span>pvt<span class="p">)</span> <span class="p">{</span>
     <span class="p">...</span>
     req <span class="o">=</span> talloc_get_type<span class="p">(</span>pvt<span class="p">,</span> <span class="k">struct</span> tevent_req<span class="p">);</span>
     state <span class="o">=</span> tevent_req_data<span class="p">(</span>req<span class="p">,</span> <span class="k">struct</span> read_bytes_state<span class="p">);</span>
     read<span class="p">(</span>state<span class="o">-&gt;</span>fd<span class="p">,</span> buf<span class="p">,</span> BUFSIZE<span class="p">);</span>
     <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><div class="code"><pre><span class="kt">int</span> read_bytes_recv<span class="p">(</span>req<span class="p">,</span> mem_ctx<span class="p">,</span> uint8_t <span class="o">**</span>buf<span class="p">,</span> ssize_t <span class="o">*</span>len<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    state <span class="o">=</span> tevent_req_data<span class="p">(</span>req<span class="p">,</span> <span class="k">struct</span> read_bytes_state<span class="p">);</span>
    <span class="o">*</span>buf <span class="o">=</span> talloc_steal<span class="p">(</span>mem_ctx<span class="p">,</span> state<span class="o">-&gt;</span>buf<span class="p">);</span>
    <span class="o">*</span>len <span class="o">=</span> state<span class="o">-&gt;</span>len<span class="p">;</span>
    <span class="k">return</span> EOK<span class="p">;</span>
<span class="p">}</span>
</pre></div><p>
Caller Code
</p>
<div class="code"><pre><span class="kt">void</span> caller_func<span class="p">(</span>fd<span class="p">,</span> caller_data<span class="p">)</span> <span class="p">{</span>
     <span class="p">...</span>
     tevent_req <span class="o">*</span>req <span class="o">=</span> read_bytes_send<span class="p">(</span>mem_ctx<span class="p">,</span> ev<span class="p">,</span> fd<span class="p">)</span>
     tevent_req_set_callback<span class="p">(</span>req<span class="p">,</span> caller_func_complete<span class="p">,</span> caller_data<span class="p">);</span>
<span class="p">}</span>
</pre></div><div class="code"><pre><span class="kt">int</span> caller_func_complete<span class="p">(</span>tevent_req <span class="o">*</span>req<span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    caller_data <span class="o">=</span> tevent_req_callback_data<span class="p">(</span>req<span class="p">,</span> <span class="k">struct</span> caller_data<span class="p">);</span>
     <span class="p">...</span> <span class="k">do</span> something with caller_data <span class="p">...</span>
     read_bytes_recv<span class="p">(</span>req<span class="p">,</span> state<span class="p">,</span> <span class="o">&amp;</span>dp_error<span class="p">);</span>
      <span class="k">return</span> dp_error<span class="p">;</span>
<span class="p">}</span>
</pre></div><p>
Note the distinction between an event handler and a request callback. While they are both similar in function, the tevent main loop is only aware of the events and handlers in the event context that it is monitoring. A tevent request is not managed by the main loop. Rather, the request's implementation determines when the request has completed, resulting in the request's callback being called, which uses the callback data to continue where it left off. Unlike an event, a tevent request is quite flexible, as it represents a generic asynchronous function call. Also, when a main loop calls a handler, the main loop can not call a second handler until control has been returned to it by the first handler. However, the first handler's code may “send” a tevent request, which may itself “send” a second tevent request, and so on, all before returning control to the main loop.
</p>
<p>
Additionally, an event's handler and handler_data are registered using one of the tevent_add_* functions; when the event is triggered, the main loop calls event-&gt;handler(..., event-&gt;handler_data), just as we would expect. In other words, the handler and handler_data that we registered are the same handler and handler_data that are called. In contrast, since a request's callback and callback data are registered using tevent_req_set_callback(req, callback, callback_data), you might expect the code to call callback(callback_data). However, this is not the case; the code calls the tevent request's callback with the tevent request as a parameter, and the callback_data needs to be extracted from the tevent request. In other words, the code calls callback(req); the callback function then needs to extract the callback data from the req using tevent_req_callback_data(req, ...).
</p>
<h2 id="a8.3.Subrequests">8.3. Subrequests</h2>
<p>
If the async computation relies on a sub-computation taking place before the async function can make progress, it can create a request with its state, and then register the subcomputation by creating a subrequest (representing the subcomputation) and setting the subrequest's callback to a function which will allow the original computation to make progress. For example, you will often see the following pattern in the codebase (note that the code listing can be read from top to bottom, almost as if the calls were synchronous):
</p>
<div class="code"><pre>comp_send<span class="p">(</span>memctx<span class="p">,</span> inputs<span class="p">)</span>
        req <span class="o">=</span> tevent_req_create<span class="p">(</span>memctx<span class="p">,</span> <span class="o">&amp;</span>state<span class="p">,</span> <span class="k">struct</span> comp_state<span class="p">);</span>
        <span class="p">...</span>populate state<span class="err">'</span>s input fields <span class="p">(</span><span class="k">using</span> inputs<span class="p">)...</span>
        subreq <span class="o">=</span> subcomp_send<span class="p">(...);</span>
        tevent_req_set_callback<span class="p">(</span>subreq<span class="p">,</span> comp_done<span class="p">,</span> req<span class="p">);</span>
        <span class="k">return</span> req<span class="p">;</span>

comp_done<span class="p">(</span>subreq<span class="p">)</span>
        req <span class="o">=</span> tevent_req_callback_data<span class="p">(</span>subreq<span class="p">,</span> tevent_req<span class="p">)</span>
         comp_state <span class="o">=</span> tevent_req_data<span class="p">(</span>req<span class="p">,</span> comp_state<span class="p">)</span>
         <span class="p">...</span>populate state<span class="err">'</span>s output fields by calling comp_recv<span class="p">(</span>subreq<span class="p">,</span> <span class="o">*</span>state<span class="o">-&gt;</span>outputs<span class="p">)...</span>
         <span class="p">...</span>call tevent_req_done or tevent_req_error<span class="p">,</span> as appropriate<span class="p">...</span>
</pre></div><p>
In order to examine a nested chain of subrequests, it can be useful to create a diagram to help visualize it. The following diagram displays two such Kerberos-related visualizations. It is left as an exercise for the reader to create an SDAP-related visualization! ;)
</p>
<p>
<a style="padding:0; border:none"><img width="750px" title="Illustration 10" /></a>
</p>
<p>
<em>This diagram presents a visualization of the AD Provider Plugin's implementation of AUTH (top) and ACCT_MGMT (bottom). Several abbreviations are used here, including: BR=be_resolve_server, HAN_CHILD=handle_child, WR=write_pipe, RD=read_pipe, ID_OP = sdap_id_op, GG=sdap_get_generic. Also note that be_resolve_server makes several additional calls, which we have not shown.</em>
</p>
<h1 id="a9.Functions">9. Functions</h1>
<p>
This section provides documentation for several functions. We refer below to the entire computation as if it were a synchronous function, receiving logical inputs (i.e. comp_send), and returning logical ouputs (comp_recv). This makes it easier to see the function's input/output characteristics.
</p>
<h2 id="a9.1.SDAPConnectionFunctions">9.1. SDAP Connection Functions</h2>
<p>
This section describes several of the functions called in order to establish an authenticated LDAP connection. The call stack looks as follows:
</p>
<ul><li><strong>sdap_id_op_connect_send
</strong><ul><li>sdap_cli_connect_send
<ul><li>be_resolve_server_send
<ul><li>fo_resolve_service_send
<ul><li>resolv_gethostbyname_send
<ul><li>resolv_gethostbyname_dns_send
</li></ul></li></ul></li></ul></li><li>sdap_connect_send<strong>
</strong></li><li>sdap_cli_rootdse_step
<ul><li><strong>sdap_get_rootdse_send</strong>
</li></ul></li><li>sdap_cli_kinit_step
<ul><li><strong>sdap_kinit_send
</strong><ul><li>be_resolve_server_send
</li><li>sdap_get_tgt_send<strong>
</strong></li></ul></li></ul></li><li>sdap_cli_auth_step
<ul><li><strong>sdap_auth_send</strong>
</li></ul></li></ul></li></ul></li></ul><h3 id="a9.1.1.sdap_id_op_connect_sendrecv">9.1.1. sdap_id_op_connect_send/recv</h3>
<p>
Logical Input: sdap_id_op object
</p>
<p>
Logical Output:
</p>
<ul><li>if successful, returns
<ul><li>reply_count
</li><li>reply (sysdb_attrs)
</li><li>op created and added to sh-&gt;ops
</li></ul></li></ul><p>
Summary: This function initiates an LDAP connection, manages the connection cache, and calls <em>sdap_cli_connect_send</em> to do the heavy lifting.
</p>
<h3 id="a9.1.2.sdap_cli_connect_sendrecv">9.1.2. sdap_cli_connect_send/recv</h3>
<p>
Logical Input: sdap_options, sdap_service, skip_rootdse, force_tls, skip_auth
</p>
<p>
Logical Output:
</p>
<ul><li>can_retry boolean
</li><li>sdap_handle
</li><li>sdap_server_opts
</li></ul><p>
Summary: This functions attempts to perform multiple tasks in order to establish a server connection for the specified sdap_service. This function is called by ad_check_online in order to determine if we are able to connect to server (in which case we are in online mode). Internally, it makes the following calls to perform these tasks:
</p>
<ul><li>calls be_resolve_server to obtain addressing information for a server that supports the service
</li><li>calls sdap_connect_send to establish a connection to the resolved server
</li><li>calls sdap_cli_rootdse_step to read rootDSE info from the resolved server (if anonymous access allowed)
</li><li>calls cli_kinit_step to obtain addressing information for a KDC and to obtain a TGT from it
</li><li>calls cli_auth_step performs an LDAP bind (either sasl or simple); also, it we were unable to read rootDSE info anonymously, we try to read it again now that we're authenticated
</li></ul><h3 id="a9.1.3.be_resolve_server_sendrecv">9.1.3. be_resolve_server_send/recv</h3>
<p>
Logical Input: be_ctx, service_name, first_retry
</p>
<p>
Logical Output: 
</p>
<ul><li>if able to resolve an fo_server in fo_service-&gt;server_list
<ul><li>set request done; output can be retrieved from state-&gt;srv
</li><li>calls any cbs associated with service; for AD provider, this is ad_resolve_cb(service)
<ul><li>sets service-&gt;sdap-&gt;uri=ldap:        <em> srv-name; populates sockaddr with ip and LDAP_PORT
</em></li><li>sets service-&gt;gc-&gt;uri=ldap:                <em> srv-name:3268; populates sockaddr with ip and GC_PORT
</em></li></ul></li></ul></li><li>if unable to resolve any fo_server in fo_service-&gt;server_list
</li></ul><p>
 
</p>
<ul><li>set request error to EIO, indicating that caller should mark us as offline (be_mark_offline)
</li></ul><p>
Summary: attempts to resolve each server associated with service_name's fo_service, until server resolution succeeds or there are no more servers to resolve; if successful, calls any callbacks associated with service and returns resolved fo_server;
</p>
<h3 id="a9.1.4.fo_resolve_service_sendrecv">9.1.4. fo_resolve_service_send/recv</h3>
<p>
Logical Input: resolv_ctx, fo_ctx, fo_service
</p>
<p>
Logical Output:
</p>
<ul><li>if able to resolve hostname
<ul><li>set fo_server-&gt;common-&gt;status to SERVER_NAME_RESOLVED
</li><li>set request done; output can be retrieved from state-&gt;server
</li></ul></li><li>if unable to resolve hostname for fo_server
<ul><li>set fo_server-&gt;common-&gt;status to SERVER_NOT_WORKING
</li><li>set request error to EAGAIN, indicating that the caller should try the next fo_server (if any)
</li></ul></li></ul><p>
Summary: For next server on fo_service-&gt;server_list, if server supports resolution using SRV records, perform resolution by calling resolv_srv_send; otherwise, perform resolution by calling fo_resolve_service_server. If resolution successful, return fo_server, which includes the desired addressing information in fo_server-&gt;server_common-&gt;rhostent. If unsuccessful, return EAGAIN, indicating that caller should try next fo_server (if any).
</p>
<p>
Internals: While a name resolution request is being processed, if a second identical request is received (i.e. for the same server name), the Backend will notice that an existing request for the same information is already in progress, and it will register the second request (and any subsequent identical requests) to be called back when the results are ready (so that they receive the same reply information). While the Responder is able to maintain a single dp_request_table to perform a similar function, the Backend has to maintain a separate request list for each server.
</p>
<h3 id="a9.1.5.resolv_gethostbyname_sendrecv">9.1.5. resolv_gethostbyname_send/recv</h3>
<p>
Logical Input: res_ctx, name, family_order, db
</p>
<p>
Logical Output: status, rhostent, error
</p>
<p>
Summary: Attempts to resolve server name using each host database in the specified db list, until successful. If successful, returns the rhostent object (containing IP address) and returns EOK; if unsuccessful, returns embedded error. In all cases, returns query status and how many times query timed out.
</p>
<p>
Internals: If server name is an IP address, returns a fake hostent structure populated with IP address. Translates family_order input to family before calling subsequent functions. If first family doesn't work, tries second family.
</p>
<h3 id="a9.1.6.resolv_gethostbyname_dns_sendrecv">9.1.6. resolv_gethostbyname_dns_send/recv</h3>
<p>
Logical Input:res_ctx, name, family
Logical Ouput: status, timeouts, rhostent, error
</p>
<p>
Summary: Sends a DNS query for the specified server name over the DNS connection represented by the specified resolv_ctx's channel. If successful, returns the rhostent object (containing the IP address associated with specified server name); if domain name not found, sets error to ENOENT; else sets error corresponding to status. In all cases, returns query status and how many times query timed out.
</p>
<p>
Internals: This function registers a callback function (resolv_gethostbyname_dns_query_done) with the c-ares library to be called by the library when the query has completed or failed. When called, the callback function parses the response (using resolv_gethostbyname_dns_parse) and retrieves the hostent object.
</p>
<h3 id="a9.1.7.sdap_connect_sendrecv">9.1.7. sdap_connect_send/recv</h3>
<p>
Logical Input: uri (ldap://server-name:port) and sockaddr (popoulated with ip-address and port)
</p>
<p>
Logical Output:
</p>
<ul><li>if connection successfully established,
<ul><li>set ldap connection callbacks
</li><li>set various options on ldap handle
</li><li>if not using start_tls, set request done; sdap_handle output can be retreived from state-&gt;sh
</li><li>if using start_tls, calls ldap_start_tls, sdap_set_connected, sdap_op_add
</li></ul></li></ul><p>
Summary: This function establishes a connection to the LDAP server, obtains the resulting LDAP handle, and registers a pair of connection callbacks with the LDAP handle. These tasks are implemented in different ways, depending on whether the system's OpenLDAP library supports the ldap_init_fd call, and whether it supports the LDAP_OPT_CONNECT_CB option. In this description, we will assume that both are supported.
</p>
<p>
This function establishes the LDAP connection by calling sss_ldap_init_send, which returns an initialized LDAP handle. After the connection has been established, sdap_sys_connect_done registers a pair of callbacks with OpenLDAP, such that OpenLDAP will call the add connection callback (sdap_ldap_connect_callback_add) after a connection is established, and will call the delete connection callback (sdap_ldap_connect_callback_del) after a connection is closed. Since we have just established a connection, the add_connection_callback is called, which registers a handler (<em>sdap_ldap_result</em>) to handle incoming responses.
</p>
<p>
At this point, several options are set on the LDAP handle (e.g. version, timeouts, etc). 
</p>
<p>
At this point, if TLS was not requested, we don't consider the connected to be connected (i.e. we don't call sdap_set_connected); it will be considered connected after the bind call succeeds. However, if TLS was requested, we call ldap_start_tls, call sdap_set_connected, and call sdap_add_op(sdap_connect_done). sdap_connect_done calls ldap_parse_result to parse the StartTLS result. 
</p>
<h3 id="a9.1.8.sss_ldap_init_sendrecv">9.1.8. sss_ldap_init_send/recv</h3>
<p>
Logical Input: uri (ldap://server-name:port) and sockaddr (popoulated with ip-address and port)
</p>
<p>
Logical Output: if successful, returns LDAP handle and file descriptor for LDAP socket
</p>
<p>
Summary: creates a socket fd, connects to the ip-address of an LDAP server, and initializes OpenLDAP by passing the connected fd to ldap_init_fd, which returns an opaque LDAP structure, which is to be used in subsequent OpenLDAP calls.
</p>
<p>
Internals: This function establishes an LDAP connection using the given IP address and URI:
</p>
<ul><li>fd = socket(...);
</li><li>connect(fd, ip-address, ...)
</li><li>ldap_init_fd(fd, uri)
</li></ul><h3 id="a9.1.9.sdap_get_rootdse_sendrecv">9.1.9. sdap_get_rootdse_send/recv</h3>
<p>
Logical Input: sdap options, sdap handle
</p>
<p>
Logical Output: if successful, returns set of sysdb_attrs
</p>
<p>
Summary: This function retrieves several attributes from the LDAP server's rootdse by calling sdap_get_generic_send with the following inputs:
</p>
<ul><li>search_base:[]
</li><li>filter: [(objectclass=*)]; 
</li><li>attrs: [*,altServer,namingContexts,supported{Control,Extension,Features,LDAPVersion,SASLMechanisms}, domainControllerFunctionality,defaultNamingContext, last,highestCommitted}USN]
</li></ul><h3 id="a9.1.10.sdap_kinit_sendrecv">9.1.10. sdap_kinit_send/recv</h3>
<p>
Logical Input: sdap handle, krb_service_name, keytab, principal, realm
</p>
<p>
Logical Output: expire_time
</p>
<p>
Summary: This function first calls be_resolve_server_send to obtain addressing information for a Kerberos server (KDC) that supports the given service (i.e. as specified by krb_service_name). If successful, this function then calls sdap_get_tgt_send to obtain a TGT for the host principal from the resolved KDC server from the previous step.
</p>
<h3 id="a9.1.11.sdap_get_tgt_sendrecv">9.1.11. sdap_get_tgt_send/recv</h3>
<p>
Logical Input: realm, principal, keytab, lifetime, timeout
</p>
<p>
Logical Output: result, krb5_error_code, ccname, expire_time_out
</p>
<p>
Brief: This function attempts to obtain a TGT from the KDC for the host principal, using the host's key entry (in its key table) to perform the necessary authentication.
</p>
<p>
Internals: In order to avoid blocking on synchronous Kerberos calls, this function spawns an ldap_child process, and sends it a TGT request message (consisting of the realm, principal, and keytab) using its write pipe. The ldap_child makes the necessary Kerberos library calls to attempt to get a TGT, and returns a response to the calling process's read pipe, at which time the ldap_child process exits. 
</p>
<p>
Kerberos library calls used by ldap_child include:
</p>
<ul><li>krb5_init_context: create a krb5 library context
</li><li>krb5_parse_name: convert a string principal name to a krb5_principal structure
<ul><li>krb5_unparse_name: convert a krb5_principal structure to a string representation
</li></ul></li><li>krb5_kt_default: resolve the default key table
<ul><li>krb5_kt_start_seq_get: start a sequential retrieval of key table entries
</li><li>krb5_kt_next_entry: retrieve the next entry from the keytable
</li><li>krb5_free_keytab_entry_contents: free the contents of a key table entry
</li><li>krb5_kt_end_seq_get: release a keytab cursor
</li></ul></li><li>krb5_get_init_creds_opt_set_address_list: set address restrictions in initial credential options
<ul><li>krb5_get_init_creds_opt_set_forwardable: set/unset forwardable flag in initial cred options
</li><li>krb5_get_init_creds_opt_set_proxiable: set/unset proxiable flag in initial credential options
</li><li>krb5_get_init_creds_opt_set_tkt_life: set the ticket lifetime in initial cred options
</li><li>krb5_get_init_creds_opt_set_canonicalize: set/unset canonicalize flag in init cred options
</li></ul></li><li>krb5_get_init_creds_keytab: get initial credentials using a key table (request TGT)
</li><li>krb5_cc_resolve: resolve a credential cache name
<ul><li>krb5_cc_initialize: initialize a credential cache
</li><li>krb5_cc_store_cred: store credentials in a credential cache
</li></ul></li><li>krb5_get_time_offset: return the time offsets from the os context
</li></ul><h3 id="a9.1.12.sdap_auth_sendrecv">9.1.12. sdap_auth_send/recv</h3>
<p>
Logical Input: sdap_handle, sasl_mech, sasl_user, user_dn, authtok
</p>
<p>
Logical Output: if successful, returns EOK and (for simple bind only) an sdap_ppolicy_data object
if unsuccessful, returns ERR_AUTH_FAILED
</p>
<p>
Brief: This function peforms an LDAP bind by calling either sdap_sasl_bind or sdap_simple_bind (based on whether the specified sasl_mech is non-NULL). If the bind is successful, and we were not able to read the rootDSE during unauthenticated bind, we try to read the rootDSE again now that we're authenticated.
</p>
<p>
If sasl_mech is specified, sdap_sasl_bind is called with the specified sasl_mech and sasl_user. For the AD use case, the value for sasl_mech is obtained from the ldap_sasl_mech configuration field (which is typically GSSAPI). The value for sasl_user is obtained from the ldap_sasl_authid configuration field. Internally, we make a blocking call to ldap_sasl_interactive_bind_s.
</p>
<p>
If sasl_mech is not specified, sdap_simple_bind is called with the specified user_dn and with a password retrieved from the specified authtok. In an AD use case, the value for the specified user_dn is obtained from the ldap_default_bind_dn configuration field. The value for the specified password is obtained from the ldap_default_authtok configuration field. Internally, we make a call to ldap_sasl_bind. If it succeeds, we set the sdap handle to the connected state.
</p>
<h2 id="a9.2.SDAPOperationRequestFunctions">9.2. SDAP Operation Request Functions</h2>
<h3 id="a9.2.1.users_get_sendrecv">9.2.1. users_get_send/recv</h3>
<p>
Logical Input: sdap_id_ctx, sdap_domain, sdap_id_conn_ctx, name, filter_type
</p>
<p>
Logical Output:
</p>
<ul><li>returns dp_error and sdap_ret
</li></ul><p>
Summary: This function is called in order to handle a USER request (i.e. getpw*) with the specified inputs.
</p>
<p>
Internals:
This function creates an sdap_id_op object to represent the operation request. It then uses the specified inputs to create an LDAP filter.
</p>
<ul><li>creates an sdap_id_op object to represent the operation request (using sdap_id_op_create)
</li><li>establishes LDAP connection by sending a connection request (or re-uses cached connection)
<ul><li>multi-step process, including connecting and binding to an LDAP server
</li></ul></li><li>sends an operation request (and receives response) over the LDAP connection
<ul><li>performs asynchronous ldap search using the be_acct_req fields as input params (sdap_get_generic_send).
</li></ul></li></ul><h3 id="a9.2.2.sdap_get_generic_sendrecv">9.2.2. sdap_get_generic_send/recv</h3>
<p>
Logical Input: sdap handle (including sdap_op objects), search_base, scope, filter, attrs
</p>
<p>
Logical Output:
</p>
<ul><li>if successful, returns
<ul><li>reply_count
</li><li>reply (sysdb_attrs)
</li><li>op created and added to sh-&gt;ops
</li></ul></li></ul><p>
Summary: This function performs an asynchronous ldap search operation by calling ldap_search_ext with the specified inputs, which include where to start the search (base), how deep to search (scope), what to match on (filter), and which attributes to return (attrs). If successful, the recv function returns the specified attributes of entries matching the specified filter. If unsuccessful, the recv function indicates that there was an error.
</p>
<h3 id="a9.2.3.sdap_get_generic_ext_sendrecv">9.2.3. sdap_get_generic_ext_send/recv</h3>
<p>
Logical Input: sdap handle, search_base, scope, filter, attrs, parse_cb
</p>
<p>
Logical Output:
</p>
<ul><li>if successful
<ul><li>set request done; output can be retrieved from state-&gt;sreply
</li></ul></li><li>else returns error
</li></ul><p>
Summary: This function performs an asynchronous ldap search operation by calling ldap_search_ext with the specified inputs, obtaining the resulting msgid, and created an sdap_op object using the msgid.
</p>
<p>
Internals: The recv function is called when the ldap response messages (corresponding to the search request) are received. Note that a search request can generate several <em>search entry</em> responses (LDAP_RES_SEARCH_ENTRY), followed by a single <em>search done</em> response (LDAP_RES_SEARCH_RESULT). For each <em>search entry</em> response that is received, we call the specified parse_cb function (e.g. sdap_get_generic_parse_entry), which parses the response and adds the returned attributes to an sdap_reply object. If a <em>search done</em> response is received, then we call the standard ldap_parse_result function to parse the response, primarily to extract the error message (if any). 
</p>
<h1 id="a10.FilesystemLocations">10. Filesystem Locations</h1>
<p>
This section describes the locations of the primary source code and installation artifacts for each component.
</p>
<table class="wiki">
<tr><td><em>Component</em></td><td><em>Source File Location</em></td><td><em>Installation Location</em></td><td style="text-align: left"><em>Log File and Prefix</em>
</td></tr><tr><td>NSS Client Library</td><td>sss_client/nss_*.c</td><td>/usr/lib64/security/nss_sss.so</td><td style="text-align: left">n/a
</td></tr><tr><td>PAM Client Library</td><td>sss_client/pam_sss.c</td><td>/usr/lib64/security/pam_sss.so</td><td style="text-align: left">n/a
</td></tr><tr><td>Monitor</td><td>monitor/monitor.c</td><td>/usr/sbin/sssd</td><td style="text-align: left">sssd.log;
</td></tr><tr><td>NSS Responder</td><td>responder/nss/nsssrv.c</td><td>/usr/libexec/sssd/sssd_nss</td><td style="text-align: left">sssd_nss.log;
</td></tr><tr><td>PAM Responder</td><td>responder/pam/pamsrv.c</td><td>/usr/libexec/sssd/sssd_pam</td><td style="text-align: left">sssd_pam.log;
</td></tr><tr><td>Backend</td><td>providers/data_provider_be.c</td><td>/usr/libexec/sssd/sssd_be</td><td style="text-align: left">sssd_<span style="color: #FF0000">foo.com</span>.log;
</td></tr><tr><td>AD Provider Plugin</td><td>providers/ad/ad_init.c</td><td>/usr/lib64/sssd/libsss_ad.so</td><td style="text-align: left">n/a
</td></tr><tr><td>Config DB</td><td>confdb/confdb.c</td><td>/var/lib/sss/db/config.ldb</td><td style="text-align: left">n/a
</td></tr><tr><td>System DB</td><td>db/sysdb.c</td><td>/var/lib/sss/db/cache_<span style="color: #FF0000">foo.com</span>.ldb</td><td style="text-align: left">n/a
</td></tr></table>
<h1 id="a11.HelpfulLinks">11. Helpful Links</h1>
<ul><li>SSSD Overview Video
<ul><li>Presented by Stephen Gallagher- <a class="ext-link" href="http://www.youtube.com/user/opensourceidm"><span class="icon">​</span>http://www.youtube.com/user/opensourceidm</a>
</li></ul></li><li>SSSD Wiki - <a class="ext-link" href="https://fedorahosted.org/sssd/wiki/"><span class="icon">​</span>https://fedorahosted.org/sssd/wiki/</a>
<ul><li>This is the main repository for SSSD information. It includes:
<ul><li>[Design Docs] - <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DesignDocs.html"><span class="icon">​</span>https://fedorahosted.org/sssd/wiki/DesignDocs</a>
</li><li>[Developer Pages] - <a class="ext-link" href="https://docs.pagure.org/sssd-test2/DevRes.html"><span class="icon">​</span>https://fedorahosted.org/sssd/wiki/DevRes</a>
<ul><li>such as Developer Tips and Tutorials
</li></ul></li><li>[Documentation] - <a class="ext-link" href="https://docs.pagure.org/sssd-test2/Documentation.html"><span class="icon">​</span>https://fedorahosted.org/sssd/wiki/Documentation</a>
<ul><li>such as Man Pages, Deployment Guides, Conference Presentations
</li></ul></li></ul></li></ul></li><li>Realmd Page - <a class="ext-link" href="http://www.freedesktop.org/software/realmd/"><span class="icon">​</span>http://www.freedesktop.org/software/realmd/</a>
<ul><li>[Realmd Page] This is the main repository for Realmd information. Among other things, it includes man pages, as well as an Administrative Guide.
</li></ul></li><li>Samba Components
<ul><li>[Talloc Tutorial] - <a class="ext-link" href="http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html"><span class="icon">​</span>http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html</a>
</li><li>[Tevent Tutorial] - <a class="ext-link" href="http://tevent.samba.org/tevent_tutorial.html"><span class="icon">​</span>http://tevent.samba.org/tevent_tutorial.html</a>
</li><li>[LDB Tutorial] -  <a class="ext-link" href="http://wiki.samba.org/index.php/Samba4/LDBIntro"><span class="icon">​</span>http://wiki.samba.org/index.php/Samba4/LDBIntro</a>
</li></ul></li><li>FreeIPA Design Proposals (out-of-date)
<ul><li>SSSD was originally conceived of as the IPAv2 Client, so these documents are useful in understanding the initial client design. However, keep in mind that these documents are out-of-date. For example, the sections on Policy Kit Back-End Daemon (PKBED) and the Info Pipe Daemon (IPD) are not relevant to SSSD. Also, the Service Controller Daemon in these documents refers to what later became known as the SSSD Monitor process.
<ul><li>[Design Overview] <a class="ext-link" href="http://www.freeipa.org/page/V2/IPA_Client_Design_Overview"><span class="icon">​</span>http://www.freeipa.org/page/V2/IPA_Client_Design_Overview</a>
</li><li>[Monitor] <a class="ext-link" href="http://www.freeipa.org/page/SSSD/Service_Controller_Daemon"><span class="icon">​</span>http://www.freeipa.org/page/SSSD/Service_Controller_Daemon</a>
</li><li>[SBus] <a class="ext-link" href="http://www.freeipa.org/page/SSSD/SBUS"><span class="icon">​</span>http://www.freeipa.org/page/SSSD/SBUS</a>
</li></ul></li></ul></li></ul></body></html>