<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><font color="#16569E"><font size="2">(08:40:21 AM)</font> <b>sgallagh:</b></font> Ok, so let's talk SSSD Backends 101<br />
<font color="#16569E"><font size="2">(08:41:02 AM)</font> <b>sgallagh:</b></font> pzuna: I assume you're planning to build an open-source backend within our existing framework?<br />
<font color="#A82F2F"><font size="2">(08:41:23 AM)</font> <b>pzuna:</b></font> sgallagh: you assume right :)<br />
<font color="#16569E"><font size="2">(08:41:24 AM)</font> <b>sgallagh:</b></font> (Closed-source backends have a completely different - and unfinished - interface)<br />
<font color="#A82F2F"><font size="2">(08:42:10 AM)</font> <b>pzuna:</b></font> open source backend for winbind, but I just read in the design docs, that it&amp;apos;s supposed to be somehow a part of the IPA backend... didn&amp;apos;t have time to read the whole wall of text there, so I don&amp;apos;t know if I got it right<br />
<font color="#16569E"><font size="2">(08:42:17 AM)</font> <b>sgallagh:</b></font> Ok, so the first thing to understand is that we have a set of generic wrapper code for back-ends<br />
<font color="#16569E"><font size="2">(08:43:52 AM)</font> <b>sgallagh:</b></font> In the SSSD source tree, this is located in src/providers/data_provider_be.c<br />
<font color="#16569E"><font size="2">(08:44:46 AM)</font> <b>sgallagh:</b></font> There are currently four backend types that can be implemented.<br />
<font color="#16569E"><font size="2">(08:45:09 AM)</font> <b>sgallagh:</b></font> ID, AUTH, ACCESS and CHPASS<br />
<font color="#16569E"><font size="2">(08:46:59 AM)</font> <b>sgallagh:</b></font> in order to provide these interfaces, a plugin must present a function named sssm_&lt;backend_name&gt;_&lt;backend_type&gt;_init()<br />
<font color="#16569E"><font size="2">(08:47:11 AM)</font> <b>sgallagh:</b></font> e.g. sssm_ldap_id_init()<br />
<font color="#16569E"><font size="2">(08:48:54 AM)</font> <b>sgallagh:</b></font> This init function must take a 'struct be_ctx *' as input and return 'struct bet_ops *' and 'void *' to the caller.<br />
<font color="#16569E"><font size="2">(08:49:14 AM)</font> <b>sgallagh:</b></font> The bet_ops are the set of callback points that the sssd_be process will invoke to do the heavy lifting<br />
<font color="#16569E"><font size="2">(08:50:00 AM)</font> <b>sgallagh:</b></font> The definition for 'struct bet_ops' can be found in src/providers/dp_backend.h<br />
<font color="#16569E"><font size="2">(08:50:41 AM)</font> <b>sgallagh:</b></font> Each backend type can provide up to three callbacks: handler, check_online and finalize<br />
<font color="#16569E"><font size="2">(08:52:06 AM)</font> <b>sgallagh:</b></font> Each of these callbacks receives a single argument, a 'struct be_req' (also described in dp_backend.h)<br />
<font color="#16569E"><font size="2">(08:54:41 AM)</font> <b>sgallagh:</b></font> The most important piece of the be_req is the be_req-&gt;req_data void pointer.<br />
<font color="#A82F2F"><font size="2">(08:54:48 AM)</font> <b>pzuna:</b></font> sgallagh: what&amp;apos;s supposed to be returned in the third argument of sssm_&lt;backend&gt;_&lt;type&gt;_init? (void **pvt_data)<br />
<font color="#16569E"><font size="2">(08:55:13 AM)</font> <b>sgallagh:</b></font> pzuna: That's private data for the provider that you may need. Such as an initialized context.<br />
<font color="#A82F2F"><font size="2">(08:55:26 AM)</font> <b>pzuna:</b></font> ok<br />
<font color="#16569E"><font size="2">(08:55:47 AM)</font> <b>sgallagh:</b></font> That will always be passed back to you as be_ctx-&gt;bet_info[BET_ID].pvt_bet_data<br />
<font color="#16569E"><font size="2">(08:56:00 AM)</font> <b>sgallagh:</b></font> Which you can then re-cast into the appropriate type<br />
<font color="#16569E"><font size="2">(08:56:53 AM)</font> <b>sgallagh:</b></font> just a second<br />
<font color="#A82F2F"><font size="2">(08:57:07 AM)</font> <b>pzuna:</b></font> ok, I see it in the sssm_ldap_id_init function, makes sense<br />
<font color="#16569E"><font size="2">(08:58:50 AM)</font> <b>sgallagh:</b></font> Ok, so the req_data void pointer<br />
<font color="#16569E"><font size="2">(08:59:10 AM)</font> <b>sgallagh:</b></font> For ID providers, this needs to be cast to a 'struct be_acct_req *'<br />
<font color="#16569E"><font size="2">(08:59:48 AM)</font> <b>sgallagh:</b></font> For the other three provider types, this would be cast to 'struct pam_data *'<br />
<font color="#16569E"><font size="2">(09:01:49 AM)</font> <b>sgallagh:</b></font> So between the pvt_bet_data and the req_data, you should have all information necessary to perform a user lookup or a PAM action<br />
<font color="#16569E"><font size="2">(09:03:12 AM)</font> <b>sgallagh:</b></font> The responsibility of the backend is to populate the sysdb cache with updated information from the directory<br />
<font color="#16569E"><font size="2">(09:03:37 AM)</font> <b>sgallagh:</b></font> (I'll get into that more in a bit)<br />
<font color="#16569E"><font size="2">(09:05:06 AM)</font> <b>sgallagh:</b></font> So once the backend performs an identity lookup, it needs to do one of two things in the sysdb. If the user/group/netgroup existed in the directory, then it needs to update the sysdb cache with the latest information. If the entry did NOT exist, then the sysdb must be purged of the same entry (if it previously existed)<br />
<font color="#16569E"><font size="2">(09:06:08 AM)</font> <b>sgallagh:</b></font> Once the sysdb is updated, the be_req-&gt;fn() should be called with a DP_ERR_OK for the second argument, which informs the responders that it's okay to return the updated information from the cache.<br />
<font color="#16569E"><font size="2">(09:07:12 AM)</font> <b>sgallagh:</b></font> If for one reason or another the directory is unreachable, the provider should be marked offline with the be_mark_offline() function and be_req-&gt;fn() should be called with DP_ERR_OFFLINE<br />
<font color="#16569E"><font size="2">(09:08:51 AM)</font> <b>sgallagh:</b></font> Behavior for the auth and chpass providers are very similar, except that instead of caching user data, the sysdb_cache_password() function would be used to store successful passwords (if and only if cache_password = true in sssd.conf)<br />
<font color="#16569E"><font size="2">(09:09:22 AM)</font> <b>sgallagh:</b></font> (sorry, cache_credentials, not cache_password)<br />
<font color="#16569E"><font size="2">(09:11:04 AM)</font> <b>sgallagh:</b></font> When returning information for AUTH or CHPASS, you need to send back both DP_ERR_OK or DP_ERR_OFFLINE as well as the pam_result (e.g. PAM_SUCCESS, PAM_PERM_DENIED, etc.).<br />
<font color="#16569E"><font size="2">(09:11:15 AM)</font> <b>sgallagh:</b></font> (also for ACCESS)<br />
<font color="#16569E"><font size="2">(09:11:27 AM)</font> <b>sgallagh:</b></font> pzuna: Questions so far?<br />
<font color="#A82F2F"><font size="2">(09:12:48 AM)</font> <b>pzuna:</b></font> sgallagh: everything makes sense so far, I&amp;apos;ll probably have questions when I start implementing the backend :)<br />
<font color="#16569E"><font size="2">(09:13:05 AM)</font> <b>sgallagh:</b></font> I'm sure<br />
<font color="#16569E"><font size="2">(09:13:34 AM)</font> <b>sgallagh:</b></font> The biggest gotcha is that you have to remember that the ID provider does NOT return results directly<br />
<font color="#16569E"><font size="2">(09:13:48 AM)</font> <b>sgallagh:</b></font> It always stores them in the sysdb<br />
</body></html>