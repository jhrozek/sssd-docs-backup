<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#SSSDDevelpage">SSSD Devel page</a>
    <ol>
      <li>
        <a href="#Arethereanyintroductorytutorialsavailable">Are there any introductory tutorials available?</a>
        <ol>
          <li>
            <a href="#Talloc">Talloc</a>
          </li>
          <li>
            <a href="#Teventandtevent_req">Tevent and tevent_req</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#WhenIdebuganSSSDprocessinadebuggeritalwaysgetskilledwithSIGTERMorreceivesSIGRTperiodically">When I debug an SSSD process in a debugger, it always gets killed with …</a>
        <ol>
          <li>
            <a href="#Untilandincludingsssd-1.13">Until and including sssd-1.13</a>
          </li>
          <li>
            <a href="#sssd-1.14orlater">sssd-1.14 or later</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#Usingvalgrindtoidentifymemoryaccessproblems">Using valgrind to identify memory access problems</a>
      </li>
      <li>
        <a href="#UsingstracetotracktheSSSDprocesses">Using strace to track the SSSD processes</a>
      </li>
      <li>
        <a href="#HowdoItrackwork-in-progressofotherdevelopers">How do I track work-in-progress of other developers?</a>
      </li>
      <li>
        <a href="#Whydoesmakechecktakesolong">Why does make check take so long?</a>
      </li>
      <li>
        <a href="#Usingclangtoperformstaticanalysisofsourcecode">Using clang to perform static analysis of source code</a>
      </li>
      <li>
        <a href="#WhenIcompiletheSSSDfromsourcethereisanerrorthatsaysusrlibldbmemberof.la:invalidELFheader">When I compile the SSSD from source there is an error that says …</a>
      </li>
      <li>
        <a href="#WhenItrytodebugtestsusinggdbIgetmessagesimilartohomeusersssd.sysdb-tests:notinexecutableformat:Fileformatnotrecognized">When I try to debug tests using <span class="icon">​</span>gdb I …</a>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h1 id="SSSDDevelpage">SSSD Devel page</h1>
<p>
This wiki page contains a collection of tips that might be useful for SSSD
developers and contributors. If you use a trick that is not mentioned here, tell
us on the <a class="ext-link" href="https://fedorahosted.org/mailman/listinfo/sssd-devel"><span class="icon">​</span>SSSD development list</a>
or the <a class="ext-link" href="irc://irc.freenode.net/sssd"><span class="icon">​</span>IRC</a>
</p>
<h2 id="Arethereanyintroductorytutorialsavailable">Are there any introductory tutorials available?</h2>
<h3 id="Talloc">Talloc</h3>
<p>
SSSD relies on the talloc memory allocator that originated in the Samba project.
</p>
<p>
SSSD developer Pavel Březina wrote a very detailed tutorial on its design, use and best practices. This is a must-read for anyone interested in contributing to SSSD.
</p>
<ul><li><a class="ext-link" href="http://talloc.samba.org/talloc/doc/html/libtalloc__tutorial.html"><span class="icon">​</span>Talloc Tutorial</a>
</li></ul><p>
Other resources:
</p>
<ul><li><a class="ext-link" href="http://sgallagh.wordpress.com/2010/03/17/why-you-should-use-talloc-for-your-next-project/"><span class="icon">​</span>Why you should use talloc for your next project</a>
</li></ul><h3 id="Teventandtevent_req">Tevent and tevent_req</h3>
<ul><li><a class="ext-link" href="https://tevent.samba.org/tevent_tutorial.html"><span class="icon">​</span>Tevent Tutorial</a>
</li></ul><h2 id="WhenIdebuganSSSDprocessinadebuggeritalwaysgetskilledwithSIGTERMorreceivesSIGRTperiodically">When I debug an SSSD process in a debugger, it always gets killed with <tt>SIGTERM</tt> or receives <tt>SIGRT</tt> periodically</h2>
<p>
The behaviour here depends a bit on your SSSD version.
</p>
<h3 id="Untilandincludingsssd-1.13">Until and including sssd-1.13</h3>
<p>
The main SSSD process (the monitor) sends "heartbeat" checks called pings
to the other SSSD services, both responders and providers. If the service
does not respond in a specified time interval, the monitor sends the <tt>SIGTERM</tt>
signal to the service in an attempt to terminate a non responding instance
and start a new one.
</p>
<p>
However, in the case a service is being traced in a debugger, it is quite
common to examine the process for long enough that the monitor would consider
the service hung and send SIGTERM. The SSSD has an option simply called
<tt>timeout</tt> that specifies the interval between the pings the monitor sends
to the services. Currently the monitor sends three pings before sending
the terminating signals, each ping is sent after 10 seconds by default.
</p>
<p>
To change the monitor settings to send pings after one hour:
</p>
<pre class="wiki">    timeout = 3600
</pre><p>
An alternate approach while debugging is to send SIGSTOP to the 'sssd' process, which will halt the monitor process. However, you must remember to send SIGCONT when you're done debugging, or your monitor will be unable to manage the other processes or shut down gracefully.
</p>
<h3 id="sssd-1.14orlater">sssd-1.14 or later</h3>
<p>
In order to support socket-activated services better, we removed the watchdog ping-pong in 1.14 and replaces it with a "watchdog" in the services themselves. The services send themselves a <tt>SIGRT</tt> signal and increase a counter each time <tt>SIGRT</tt> is delivered. There is also a timer event using the SSSD event loop that periodically re-sets the counter to signal the service is still processing event loop events and thus can be considered alive. Once the counter reaches a threshold (3 by default), the service exits and the monitor restarts the service upon receiving a <tt>SIGCHLD</tt> signal.
</p>
<p>
To change the period of <tt>SIGRT</tt> signals and therefore to change how often is the counter increased, change the <tt>timeout</tt> parameter in the service section, for example to be increased only once per hour:
</p>
<pre class="wiki">    timeout = 3600
</pre><p>
Alternatively, you can disable the function that stops the watchdog completely:
</p>
<pre class="wiki">    p teardown_watchdog()
</pre><p>
You can place this command to a <tt>.gdbinit</tt> file so that it gets executed once you attach gdb to a sssd process.
</p>
<h2 id="Usingvalgrindtoidentifymemoryaccessproblems">Using valgrind to identify memory access problems</h2>
<p>
<a class="ext-link" href="http://valgrind.org"><span class="icon">​</span>valgrind</a> is an immensely useful tool that is able
to check a wide range of memory access problems - from memory leaks to
use-after-free bugs.
</p>
<p>
When debugging the main SSSD program, one can just run the program as a
positional valgrind parameter:
</p>
<pre class="wiki">    valgrind /usr/sbin/sssd
</pre><p>
The situation is somewhat complex when the developer needs to debug one
of the services that the SSSD monitor spawns. The best solution is to use
the special (undocumented) parameter called <tt>command</tt>. By default, the
"command" defaults to <tt>${libexec}/sssd_${service</tt>} which expands to absolute
path pointing to <tt>/usr/libexec/sssd/sssd_${service</tt>} on Fedora.
</p>
<p>
The general format is <tt>valgrind &lt;path-to-service&gt;</tt>. For example to debug
the <tt>sss_nss</tt> process, you need to specify the following in the <tt>[nss]</tt>
section of the sssd.conf file:
</p>
<pre class="wiki">    command = valgrind --leak-check=full /usr/libexec/sssd/sssd_nss
</pre><p>
Some of the SSSD processes, notable the sssd_be processes that represent the
<tt>[domain/]</tt> sections of <tt>sssd.conf</tt>, require command line parameters
in order to function correctly. The easiest way to check how exactly the SSSD
spawns the worker processes is to simply check with the <tt>ps(1)</tt> utility:
</p>
<pre class="wiki">    ps -axu | grep sss
</pre><p>
The following example illustrates using valgrind to debug an SSSD domain
called "default", which is the name authconfig uses:
</p>
<pre class="wiki">    command = valgrind --leak-check=full --log-file=/tmp/valgrind.%p.log /usr/libexec/sssd/sssd_be --domain default
</pre><p>
This will log valgrind findings to a file in /tmp named with the process ID.
</p>
<h2 id="UsingstracetotracktheSSSDprocesses">Using strace to track the SSSD processes</h2>
<p>
Sometimes, the DEBUG messages are not enough in telling you what went wrong. A typical example, found in the wild was that <tt>libkrb5</tt> initialization was failing in krb5_child process:
</p>
<pre class="wiki">(Thu Feb 19 15:58:12 2015) [[sssd[krb5_child[54101]]]] [become_user] (0x0200): Trying to become user [9922][14].
(Thu Feb 19 15:58:12 2015) [[sssd[krb5_child[54101]]]] [create_ccache] (0x0020): 575: [13][Permission denied]
</pre><p>
So krb5_child couldn't access a resource, but how do we tell which one? It's best to start the back end under strace. This has to be done similarly to how we start <tt>sssd_be</tt> under <tt>valgrind</tt>, by adding the <tt>command</tt>
option to the <tt>[domain]</tt> section. For SSSD 1.13+ the <tt>command</tt> can be specified as:
</p>
<pre class="wiki">command = strace -ff -o /tmp/sssd_be_strace /usr/libexec/sssd/sssd_be --debug-level=10 --domain ipa.example.com --uid=0 --gid=0
</pre><p>
SSSD version 1.12 and lower require a slightly modified <tt>command</tt> option:
</p>
<pre class="wiki">command = strace -ff -o /tmp/sssd_be_strace /usr/libexec/sssd/sssd_be --debug-level=10 --domain ipa.example.com
</pre><p>
The <tt>-ff</tt> options are significant for debugging the child processes
<tt>sssd_be</tt> spawns. When the <tt>sssd_be</tt> process execs a subprocess, strace
would also track the child process by creating one file per process and
appending a numeric PID after the base filename <tt>/tmp/sssd_be_strace</tt>.
</p>
<p>
Then restart SSSD and run the sequence of commands that triggered the bug.
</p>
<p>
Please make sure SELinux should be set to Permissive, otherwise sssd_be
might not be able to execute child programs through strace.  After that,
you should see several files under <tt>/tmp/</tt> matching the base filename:
</p>
<pre class="wiki">$ ls /tmp/sssd_be_strace*
/tmp/sssd_be_strace.27067  /tmp/sssd_be_strace.27071  /tmp/sssd_be_strace.27079
</pre><p>
If you're looking for a file from a specific subprocess, it's best to just grep the strace log file for the binary name of the subprocess:
</p>
<pre class="wiki">$ grep krb5_child /tmp/sssd_be_strace*
/tmp/sssd_be_strace.27079:execve("/usr/libexec/sssd/krb5_child", ["/usr/libexec/sssd/krb5_child"], [/* 24 vars */]) = 0
/tmp/sssd_be_strace.27079:write(2, "krb5_child started.\n", 20)   = 20
</pre><h2 id="HowdoItrackwork-in-progressofotherdevelopers">How do I track work-in-progress of other developers?</h2>
<p>
Most of the core SSSD developers publish their work in progress patches
in topic branches of git repositories on <a class="ext-link" href="http://fedorapeople.org"><span class="icon">​</span>http://fedorapeople.org</a>
</p>
<p>
The web interface for the git repositories are available at
</p>
<pre class="wiki">    http://fedorapeople.org/gitweb?p=USERNAME/public_git/REPO_NAME
</pre><p>
where USERNAME is the FAS user name of the developer and in the particular case
of REPO_NAME is usually sssd.git
</p>
<p>
To add the repository as a git remote, issue the following:
</p>
<pre class="wiki">    git remote add REMOTE_NAME git://fedorapeople.org/home/fedora/USERNAME/public_git/REPO_NAME.git
    git fetch REMOTE_NAME
</pre><p>
You can then see all the branches you are tracking with:
</p>
<pre class="wiki">    git branch -a
</pre><p>
Or for a particular remote:
</p>
<pre class="wiki">    git branch -a | grep remotes/REMOTE_NAME
</pre><p>
If you'd like to publish your work in the fedorapeople.org repo, follow
<a class="ext-link" href="https://fedoraproject.org/wiki/Infrastructure/fedorapeople.org#BETA_git_hosting_support"><span class="icon">​</span>the guide</a> on the Fedora Project wiki -
</p>
<h2 id="Whydoesmakechecktakesolong">Why does make check take so long?</h2>
<p>
By default, the SSSD tests are performed in the build directory. Some
of the unit tests, in particular the sysdb test generate a lot of disk
activity and the test runs might take a long time if executed on local disk.
</p>
<p>
One solution is to use the <tt>--with-test-dir</tt> parameter which specifies
where the tests are creating their temporary files. Configuring the test
dir to use the in memory tmpfs filesystem located in <tt>/dev/shm</tt> will
mitigate the disk activity and improve the execution time.
</p>
<pre class="wiki">    ./configure --with-test-dir=/dev/shm
    make check
</pre><h2 id="Usingclangtoperformstaticanalysisofsourcecode">Using clang to perform static analysis of source code</h2>
<p>
The LLVM compiler suite contains a static analyzer that can help you find bugs that are otherwise hard to notice. The analysis is run by overriding
the <tt>$(CC)</tt> Makefile variable to point to the <tt>ccc-analyzer</tt> binary and then compiling the project. The clang suite contains a handy Perl script <tt>scan-build</tt>
that sets all the right variables for you. To run the analysis, on Fedora, make sure to have the <tt>clang-analyzer</tt> package installed. Then reconfigure
and rebuild the SSSD using the <tt>scan-build</tt> script:
</p>
<pre class="wiki">    scan-build ./configure
    scan-build make
</pre><p>
You should see individual functions being analyzed during the build process:
</p>
<pre class="wiki">    ANALYZE: src/db/sysdb_ops.c sysdb_mod_netgroup_member
    ANALYZE: src/db/sysdb_ops.c sysdb_remove_attrs
</pre><p>
The default output is one HTML page per defect that can be viewed using a special <tt>scan-view</tt> helper:
</p>
<pre class="wiki">    scan-build: 20 bugs found.
    scan-build: Run 'scan-view /tmp/scan-build-2012-05-09-2' to examine bug reports.
</pre><p>
See the <a class="ext-link" href="http://clang-analyzer.llvm.org/scan-build.html"><span class="icon">​</span>official documentation</a> for more info.
</p>
<h2 id="WhenIcompiletheSSSDfromsourcethereisanerrorthatsaysusrlibldbmemberof.la:invalidELFheader">When I compile the SSSD from source there is an error that says <tt>/usr/lib/ldb/memberof.la: invalid ELF header</tt></h2>
<p>
You can safely ignore this warning or remove the <tt>.la</tt> file completely. 
</p>
<p>
The .la file is a libtool archive and is a relic of how we generate the
module. They are only necessary for enabling <tt>make uninstall</tt> to work
properly, but if you are packaging an RPM or DEB file, the removal would be
handled by the packaging tools.
</p>
<h2 id="WhenItrytodebugtestsusinggdbIgetmessagesimilartohomeusersssd.sysdb-tests:notinexecutableformat:Fileformatnotrecognized">When I try to debug tests using <a class="ext-link" href="https://www.gnu.org/software/gdb/"><span class="icon">​</span>gdb</a> I get message similar to <tt>"/home/user/sssd/./sysdb-tests": not in executable format: File format not recognized</tt></h2>
<p>
The test you are trying to run is actually libtool script. To run for example the sysdb-tests, use the following command to run the actual binary file with gdb:
</p>
<pre class="wiki">libtool --mode=execute gdb ./sysdb-tests
</pre><p>
instead of just
</p>
<pre class="wiki">gdb ./sysdb-tests
</pre></body></html>