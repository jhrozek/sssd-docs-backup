<html><head><link rel="stylesheet" href="/sssd-test2/trac.css" type="text/css" /><link rel="stylesheet" href="/sssd-test2/wiki.css" type="text/css" /></head><body><h1 id="INIValidatorDesign">INI Validator Design</h1>
<h2 id="Concepts">Concepts</h2>
<p>
The INI validator is going to be an INI library function that would allow checking the configuration just read from the INI file against a predefined set of rules. The set of rules is specific for each kind of the configuration file so the validation interface should be able to read these rules from the schema definition, check that schema definition is consistent and then check that the configuration file complies with the grammar.
</p>
<h2 id="SchemaDefinition">Schema Definition</h2>
<p>
This section describes the schema definition grammar and rules. The schema definition will be represented by a file or a series of files in the INI format. This means that the structure of the schema definition file(s) can be read by the same INI parsing functions as the application configuration file. 
There are several main concepts related to schema
</p>
<ul><li>Schema defines rules about key value pairs (KVPs) of the application configuration file. This includes properties like type of the value, is it mandatory, is it a single value or a list of values etc.
</li><li>Schema defines rules about relations between different parts of the configuration file. With the rules one would be able to describe complex business logic. This is acknowledged that it is not a high priority to support rules in grammar in the first implementation so we are not going to describe the semantics of the rules here.
</li><li>Each KVP of the config file is described with the section in the schema file. The section in the schema file would have the following structure:
The name of the section is a global (to the schema) unique name used to refer to the KVP inside the schema definition. Do not confuse it with the name of the key. Keys with same name can be used in different sections of the config file. We will use the term “label” when we will talk about this name. The section itself will consist of the set of predefined keys and values. The keys would define the properties of the KVP in the config file.
So the structure will look like this:
[label]
property0 = value0
property1 = value1
property2 = value2
property3 = value3
property4 = value4
</li></ul><blockquote>
<p>
In real schema file the properties will be taken from a predefined set of properties described later on this page.
</p>
</blockquote>
<ul><li>Schema definitions allows implications – this means that there are some properties that imply other properties. For example a special property that would identify KVP as a section list would imply that the KVP is a list and that the type of the KVP is a string. This will be described in more details later on the page.
</li><li>Schema will be extensible. This means that it can be split between multiple files. Currently the logic implemented for the configuration file is the following: Read first files and then update the configuration using other files. So for config files the interface would automatically merge the configuration information. For the schema the logic is a bit different. The main schema file that comes with the application is the main file. It can't be altered only amended by the information read from the other schema file. The amending file would be able to describe KVPs that are not present in the main schema file or amend existing KVP definitions in a compliant way. The rules of compliance will be defined later on this page.
</li></ul><h2 id="CatalogoftheKVPproperties">Catalog of the KVP properties</h2>
<div class="document">
<p>For now we will cover only properties that describe the configuration file values not rules.</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="35%" />
<col width="7%" />
<col width="7%" />
<col width="8%" />
<col width="5%" />
<col width="7%" />
<col width="7%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Key</th>
<th class="head">Description</th>
<th class="head">Value type</th>
<th class="head">Mandatory</th>
<th class="head">Values</th>
<th class="head">Default</th>
<th class="head">Implies</th>
<th class="head">Implied by</th>
<th class="head">Collides</th>
<th class="head">Enabled by</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>type</td>
<td>Type of the section.</td>
<td>String</td>
<td>No</td>
<td>“field”
“extend”</td>
<td>field</td>
<td>&nbsp;</td>
<td>vtype</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<p>
Next table shows keys that can only be present in the section of the type “field” 
</p>
<div class="document">
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="35%" />
<col width="7%" />
<col width="6%" />
<col width="8%" />
<col width="5%" />
<col width="7%" />
<col width="7%" />
<col width="9%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Key</th>
<th class="head">Description</th>
<th class="head">Value type</th>
<th class="head">Mandatory</th>
<th class="head">Values</th>
<th class="head">Default</th>
<th class="head">Implies</th>
<th class="head">Implied by</th>
<th class="head">Collides</th>
<th class="head">Enabled by</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>vtype</td>
<td>Type of the value</td>
<td>String</td>
<td>Yes</td>
<td>“string”
“int”
“unsigned”
“long”
“ulong”
“double”
“bool”
“int32”
“uint32”
“int64”
“uint64”</td>
<td>&nbsp;</td>
<td>type</td>
<td>as string
if seclist
is yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>name</td>
<td>Name of the key</td>
<td>String</td>
<td>Yes</td>
<td>any</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>section</td>
<td>Name of the section</td>
<td>String</td>
<td>YC*</td>
<td>any</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>secref</td>
<td>&nbsp;</td>
</tr>
<tr><td>secref</td>
<td>Reference to a dynamically defined section</td>
<td>String</td>
<td>YC</td>
<td>label</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>section</td>
<td>&nbsp;</td>
</tr>
<tr><td>required</td>
<td>Is the value required</td>
<td>Bool</td>
<td>No</td>
<td>yes/no</td>
<td>no</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>requiredby</td>
<td>&nbsp;</td>
</tr>
<tr><td>requiredby</td>
<td>The value is conditionally required
by another key.
See what the value means in a separate section.</td>
<td>String</td>
<td>No</td>
<td>special*</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>required</td>
<td>&nbsp;</td>
</tr>
<tr><td>list</td>
<td>Is the value actually a list of values</td>
<td>Bool</td>
<td>No</td>
<td>yes/no</td>
<td>no</td>
<td>sep
(if true)</td>
<td>as yes
if seclist
is yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>sep</td>
<td>How to parse lists</td>
<td>String</td>
<td>No</td>
<td>any</td>
<td>“,”</td>
<td>&nbsp;</td>
<td>list
if list=
yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>min</td>
<td>Minimal value for a number
For lists applies to every value</td>
<td>Number</td>
<td>No</td>
<td>any</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>vtype is
numeric</td>
</tr>
<tr><td>max</td>
<td>Maximum value for a number
For lists applies to every value</td>
<td>Number</td>
<td>No</td>
<td>any</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>vtype is
numeric</td>
</tr>
<tr><td>enabledby</td>
<td>The list of other keys that enable
this key.</td>
<td>String</td>
<td>No</td>
<td>special*</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>seclist</td>
<td>The value is list of the subsection</td>
<td>Bool</td>
<td>No</td>
<td>yes/no</td>
<td>no</td>
<td>list=yes
vtype=
string</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>secpf</td>
<td>Prefix for the subsection</td>
<td>String</td>
<td>No</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>secpfref</td>
<td>&nbsp;</td>
</tr>
<tr><td>secpfref</td>
<td>Reference to a single value key
that defines prefix</td>
<td>String</td>
<td>No</td>
<td>label</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>secpf</td>
<td>&nbsp;</td>
</tr>
<tr><td>match</td>
<td>Multi value attribute that defines
a series of match patterns the KVP
values should match.</td>
<td>Strlist</td>
<td>No</td>
<td>regex*</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>choices</td>
<td>&nbsp;</td>
</tr>
<tr><td>choices</td>
<td>Multi value attribute that defines
a series of possible values for
the KVP value.</td>
<td>List</td>
<td>No</td>
<td>any</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>match</td>
<td>&nbsp;</td>
</tr>
<tr><td>extensible</td>
<td>Can the value be extended</td>
<td>Bool</td>
<td>No</td>
<td>yes/no</td>
<td>no</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>list is
yes</td>
</tr>
</tbody>
</table>
</div>
<p>
This table contains properties available in the section of the “extend” type
</p>
<div class="document">
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="35%" />
<col width="7%" />
<col width="7%" />
<col width="8%" />
<col width="5%" />
<col width="7%" />
<col width="7%" />
<col width="9%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Key</th>
<th class="head">Description</th>
<th class="head">Value type</th>
<th class="head">Mandatory</th>
<th class="head">Values</th>
<th class="head">Default</th>
<th class="head">Implies</th>
<th class="head">Implied by</th>
<th class="head">Collides</th>
<th class="head">Enabled by</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>name</td>
<td>Type of the value to extend.</td>
<td>String</td>
<td>Yes</td>
<td>label</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr><td>value</td>
<td>The value to use in extend
The value is treated as the value of the same
type as the referenced KVP.</td>
<td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>Yes</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<p>
Some of the clarification of the terms used above:
</p>
<ul><li><strong>special</strong> – the following syntax of the value will be used: 
key = label1[value1, ...], label2[value2, ...] 
where:
<ul><li><strong>key</strong> - is for now “requiredby” or “enabledby”
</li><li><strong>label</strong> - is a name of some other section
</li><li><strong>[...]</strong> - optional section, if present should contain a list of values that trigger the requirement or enablement. If omitted the presence of the key
</li></ul></li></ul><blockquote>
<blockquote>
<blockquote>
<p>
would trigger the enablement. 
</p>
</blockquote>
<p>
The list can consist of multiple enablers.
</p>
</blockquote>
</blockquote>
<ul><li><strong>YC</strong> - means yes but only one of the colliding properties must be present
</li><li><strong>regex</strong> - is a pcre based regular expression, actually a list of them  
</li></ul><p>
 
</p>
<h2 id="Processinglogichighlevel">Processing logic (high level)</h2>
<ul><li>Read schema
</li><li>Read configuration (already available)
</li><li>Validate
</li></ul><h3 id="ReadSchema">Read Schema</h3>
<ul><li>Open main schema file (do some permissions checks if needed)
</li><li>Read it with INI parser 
</li><li>Validate grammar
</li><li>For any additional schema file
<ul><li>Read file into separate handle
</li><li>Validate grammar and references
</li></ul></li><li>Create a validation object which is a collection (can be done partially on the fly)
It should include an expanded tree of possible dynamically defined subsections and possible
KVP that can be found in those sections. It will be searchable by section+key combination.  
The extends are merged in at that point and all the implications are translated.
</li></ul><p>
 
</p>
<h3 id="Validate">Validate</h3>
<ul><li>For each key in each section
<ul><li>Find its definition in validation object
</li><li>Check that value matches all defined properties
</li><li>Report error on failure
</li></ul></li></ul><p>
 
</p>
<h2 id="Outlineofthework">Outline of the work</h2>
<ul><li>Preparation
<ul><li>Add support for additional data types into conversion functions - patch is on the list
</li><li>Add support for sting lists with explicitly quoted elements - proposed approach is attached to the ticket <a class="closed ticket" href="https://fedorahosted.org/sssd/ticket/449" title="enhancement: INI allow trailing and leading spaces in the values (closed: wontfix)">#449</a>
</li></ul></li><li>Read the schema
<ul><li>Create a twin of the ini_to_collection function and convert it to schema_to_collection
</li><li>Wrap it into high level interfaces similar to the config ones 
</li><li>Define the internal representation of the value read from the schema. It should be decomposed for easier validation
</li></ul></li><li>Validate grammar itself
<ul><li>For each KVP definition :
<ul><li>Check: 
<ul><li>Mandatory properties are defined
</li><li>Not enabled properties are not defined
</li><li>Colliding properties are not defined
</li><li>Referenced properties are defined and they are not this same property (avoid reflexive references)
</li><li>Check collisions on implications
</li></ul></li><li>Translate into internal representation
<ul><li>Check the values match given type  
</li><li>Check correctness of the default values and regular expressions 
</li></ul></li></ul></li></ul></li><li>Construct or complete constructing the validation object
</li><li>Validate
<ul><li>For each key in each section of the config file
<ul><li>Find its definition in the validation object
</li><li>Check that value matches all defined properties (details TBD)
</li><li>Report error on failure
</li></ul></li></ul></li></ul></body></html>